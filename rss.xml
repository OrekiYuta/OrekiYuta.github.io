<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Canoe</title>
  
  <subtitle>「ろくでなし」</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://www.orekiyuta.cn/"/>
  <updated>2020-11-14T09:19:42.898Z</updated>
  <id>http://www.orekiyuta.cn/</id>
  
  <author>
    <name>Orekiyuta</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows Setting</title>
    <link href="http://www.orekiyuta.cn/archives/WindowsSetting/"/>
    <id>http://www.orekiyuta.cn/archives/WindowsSetting/</id>
    <published>2020-11-14T08:49:01.000Z</published>
    <updated>2020-11-14T09:19:42.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Win10-LTSB-Add-MicrosoftStore"><a href="#Win10-LTSB-Add-MicrosoftStore" class="headerlink" title="Win10 LTSB Add MicrosoftStore"></a>Win10 LTSB Add MicrosoftStore</h3><ul><li>To : <a href="https://github.com/kkkgo/LTSB-Add-MicrosoftStore" target="_blank" rel="noopener">LTSB-Add-MicrosoftStore</a></li><li>Run: Add-Store.cmd</li></ul><p><img src="/images/Windows/Win10LTSBAddMicrosoftStore/Snipaste_2020-11-14_16-53-39.png" alt></p><h3 id="Windows-show-Windows-File"><a href="#Windows-show-Windows-File" class="headerlink" title="Windows show Windows/File"></a>Windows show Windows/File</h3><ul><li><code>explorer .</code></li><li><code>explorer ..</code></li><li><code>explorer [dirName]</code><br><img src="/images/Windows/Explorer/Snipaste_2020-11-14_17-06-31.png" alt></li></ul><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Win10-LTSB-Add-MicrosoftStore&quot;&gt;&lt;a href=&quot;#Win10-LTSB-Add-MicrosoftStore&quot; class=&quot;headerlink&quot; title=&quot;Win10 LTSB Add MicrosoftStore&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="Windows" scheme="http://www.orekiyuta.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Java GenericTypes</title>
    <link href="http://www.orekiyuta.cn/archives/JavaGenericTypes/"/>
    <id>http://www.orekiyuta.cn/archives/JavaGenericTypes/</id>
    <published>2020-11-10T11:53:11.000Z</published>
    <updated>2020-11-11T15:41:09.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类,是在实例化类的时候, 指明 泛型的具体类型</p><h3 id="泛型的类型参数不支持基本类型-只能是类对象类型"><a href="#泛型的类型参数不支持基本类型-只能是类对象类型" class="headerlink" title="泛型的类型参数不支持基本类型,只能是类对象类型"></a>泛型的类型参数不支持基本类型,只能是类对象类型</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;<span class="keyword">int</span>&gt; genericl = <span class="keyword">new</span> Generic&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);          <span class="comment">// ❌</span></span><br><span class="line">Generic&lt;Integer&gt; genericl = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">100</span>);  <span class="comment">// ✔</span></span><br></pre></td></tr></table></figure></li></ul><p>👉<a href="https://qastack.cn/programming/2721546/why-dont-java-generics-support-primitive-types" target="_blank" rel="noopener">为什么Java泛型不支持基本类型？</a></p><ul><li>主要是为了向后兼容<a id="more"></a></li></ul><h3 id="泛型类在创建对象的时候-没有指定类型的话-将默认指定为-Object-类型"><a href="#泛型类在创建对象的时候-没有指定类型的话-将默认指定为-Object-类型" class="headerlink" title="泛型类在创建对象的时候,没有指定类型的话,将默认指定为 Object 类型"></a>泛型类在创建对象的时候,没有指定类型的话,将默认指定为 Object 类型</h3><p><img src="/images/JavaGenericTypes/1.png" alt></p><ul><li>由于 基本数据类型 不继承自 Object 因此, 泛型参数不支持基本类型</li><li>除了8种基本数据类型(byte,short,int,long,float,double,char,boolean)以外都是 Object 的子类</li></ul><h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p><img src="/images/JavaGenericTypes/2.png" alt></p><ul><li><code>Object object = 1;</code> 没有编译问题,因为在赋值过程种自动装箱;</li><li>8种基本类型都有对应的包装数据类型</li><li>上图运行结果可见,经过了自动装箱</li></ul><h3 id="由同一泛型类-创建的不同数据类型的对象-本质上是同一类型"><a href="#由同一泛型类-创建的不同数据类型的对象-本质上是同一类型" class="headerlink" title="由同一泛型类,创建的不同数据类型的对象,本质上是同一类型"></a>由同一泛型类,创建的不同数据类型的对象,本质上是同一类型</h3><p><img src="/images/JavaGenericTypes/3.png" alt></p><ul><li><code>stringGeneric.getClass() == integerGeneric.getClass()</code>结果为 true , 说明内存地址相同</li></ul><h3 id="子类是泛型类的话-子类要和父类的泛型类型保持一致"><a href="#子类是泛型类的话-子类要和父类的泛型类型保持一致" class="headerlink" title="子类是泛型类的话,子类要和父类的泛型类型保持一致"></a>子类是泛型类的话,子类要和父类的泛型类型保持一致</h3><ul><li><code>class ChildGeneric&lt;T&gt; extends Generic&lt;T&gt;</code></li><li>由子类来决定具体类型,就是调用的时候来指定的</li></ul><p><img src="/images/JavaGenericTypes/4.png" alt></p><ul><li><code>class ChildGeneric&lt;T,E,k&gt; extends Generic&lt;T&gt;</code> 可以多个类型,但是至少保证一个类型和父类一致</li></ul><h3 id="子类不是泛型类-父类要明确泛型的数据类型"><a href="#子类不是泛型类-父类要明确泛型的数据类型" class="headerlink" title="子类不是泛型类,父类要明确泛型的数据类型"></a>子类不是泛型类,父类要明确泛型的数据类型</h3><ul><li><code>class ChildGeneric extends Generic&lt;Integer&gt;</code></li></ul><p><img src="/images/JavaGenericTypes/5.png" alt></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h3 id="泛型接口的实现类是泛型类-实现类和接口的泛型类型要保持一致"><a href="#泛型接口的实现类是泛型类-实现类和接口的泛型类型要保持一致" class="headerlink" title="泛型接口的实现类是泛型类,实现类和接口的泛型类型要保持一致"></a>泛型接口的实现类是泛型类,实现类和接口的泛型类型要保持一致</h3><p><img src="/images/JavaGenericTypes/7.png" alt></p><h3 id="泛型接口的实现类不是泛型类-接口要明确数据类型"><a href="#泛型接口的实现类不是泛型类-接口要明确数据类型" class="headerlink" title="泛型接口的实现类不是泛型类,接口要明确数据类型"></a>泛型接口的实现类不是泛型类,接口要明确数据类型</h3><p><img src="/images/JavaGenericTypes/6.png" alt></p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法,是在调用方法的时候, 指明 泛型的具体类型</p><ul><li>前面的例子中 那些诸如 <code>public E getValue() {}</code> 只是普通的成员方法,并不是泛型方法</li><li>只有声明了 <code>&lt;T&gt;</code> 的方法才是泛型方法 , T 可以是其他符号（E,K…）</li></ul><p><img src="/images/JavaGenericTypes/8.png" alt></p><ul><li>泛型方法独立于类存在</li><li>即使 泛型方法的标识符和类标识符一致,泛型方法的类型取决于调用时候的类型</li><li>下图可以和上图做比较,可得出结论</li></ul><p><img src="/images/JavaGenericTypes/9.png" alt></p><ul><li>泛型方法 和 泛型类里面的成员方法 的区别在于:泛型方法的类型取决于调用时的类型;泛型类里面的成员方法在使用的时候,必须遵从泛型类的类型</li></ul><h3 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h3><ul><li>泛型类里面的成员方法 不能声明为静态 </li><li>泛型方法独立于类的存在,可以声明为静态</li></ul><p><img src="/images/JavaGenericTypes/10.png" alt></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><img src="/images/JavaGenericTypes/11.png" alt></p><h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p><img src="/images/JavaGenericTypes/12.png" alt></p><ul><li>按照多态思想, Integer 继承于 Number , 但是对泛型类型来说不适用</li></ul><p><img src="/images/JavaGenericTypes/13.png" alt></p><ul><li>顺着思路,尝试重载,但是依然不行;同理 <code>Box&lt;Object&gt;</code> 同样不行</li><li>因为,前面说过了; <code>Box&lt;Number&gt; box</code>和<code>Box&lt;Integer&gt; box</code> 本质上都是 <code>Box&lt;E&gt;</code>;所以这两个是同一个方法</li></ul><p><img src="/images/JavaGenericTypes/14.png" alt></p><ul><li>因此为了解决这个问题,引入了通配符<code>?</code></li></ul><p><img src="/images/JavaGenericTypes/15.png" alt></p><h3 id="上限"><a href="#上限" class="headerlink" title="上限"></a>上限</h3><ul><li><code>Box&lt;? extends Number&gt;</code> 指可以传 继承于 Number 的所有子类,最高上限传 Number</li></ul><p><img src="/images/JavaGenericTypes/16.png" alt></p><p><img src="/images/JavaGenericTypes/17.png" alt></p><ul><li>这里不允许添加元素,因为确定不了类型</li></ul><p><img src="/images/JavaGenericTypes/18.png" alt></p><ul><li>ArrayList 里面的 addAll() 就用了 上限通配符</li></ul><p><img src="/images/JavaGenericTypes/19.png" alt></p><p><img src="/images/JavaGenericTypes/20.png" alt></p><h3 id="下限"><a href="#下限" class="headerlink" title="下限"></a>下限</h3><ul><li>类/接口&lt;? super 实参类型&gt;</li><li>要求该泛型的类型，只能是实参类型，或实参类型的 父类类型</li></ul><p><img src="/images/JavaGenericTypes/21.png" alt></p><ul><li><p>遍历元素下限通配符元素的时候,拿 0bject 类型,因为无论是 Cat 还是所有的父类,都来自于 Object</p></li><li><p>这里可以添加元素,但是不保证元素数据类型的约束要求<br><img src="/images/JavaGenericTypes/22.png" alt></p></li></ul><p><img src="/images/JavaGenericTypes/23.png" alt></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cat.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MiniCat.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiniCat</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MiniCat&#123;"</span> +</span><br><span class="line">                <span class="string">"level="</span> + level +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mian.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Cat&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator2());</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Ami"</span>,<span class="number">13</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Bie"</span>,<span class="number">25</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Cna"</span>,<span class="number">34</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Dji"</span>,<span class="number">52</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Ewa"</span>,<span class="number">11</span>));</span><br><span class="line">        <span class="keyword">for</span> (Cat cat : treeSet) &#123;</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator1</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Animal o1, Animal o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator2</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Cat</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cat o1, Cat o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator3</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">MiniCat</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MiniCat o1, MiniCat o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.level - o2.level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/JavaGenericTypes/24.png" alt></p><ul><li><code>TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator2());</code> 根据年龄比较排序</li><li><p><code>TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator1());</code> 根据名字比较排序</p></li><li><p><code>TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator3());</code> 在下限 Cat 以下, MiniCat 达不到下限</p></li></ul><p><img src="/images/JavaGenericTypes/25.png" alt></p><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是泛型代码能够很好地和之前版本的代码兼容。</p><p>那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为–类型擦除。</p><ul><li>在前面的例子中，判断过泛型是否相等<ul><li>由同一泛型类,创建的不同数据类型的对象,本质上是同一类型 </li><li><code>stringGeneric.getClass() == integerGeneric.getClass()</code>结果为 true ,其实说明了这点</li><li>在进入JVM之前，与泛型相关的信息会被擦除掉</li><li><img src="/images/JavaGenericTypes/26.png" alt></li><li>在运行结果出来的时候,两者是相等的,说明了编译期间会把泛型的类型给移除掉</li></ul></li></ul><h3 id="无限制类型擦除"><a href="#无限制类型擦除" class="headerlink" title="无限制类型擦除"></a>无限制类型擦除</h3><p>泛型 T 在运行的时候,会被解释成 Object;就相当于用 Object 来代替</p><p><img src="/images/JavaGenericTypes/27.png" alt></p><p><img src="/images/JavaGenericTypes/28.png" alt></p><h3 id="有限制类型擦除"><a href="#有限制类型擦除" class="headerlink" title="有限制类型擦除"></a>有限制类型擦除</h3><p>将 泛型 T 转换成 上限类型 Number<br><img src="/images/JavaGenericTypes/29.png" alt></p><p><img src="/images/JavaGenericTypes/30.png" alt></p><h3 id="擦除-方法中类型定义的参数"><a href="#擦除-方法中类型定义的参数" class="headerlink" title="擦除 方法中类型定义的参数"></a>擦除 方法中类型定义的参数</h3><p>前面的是擦除 泛型类 的类型;这里是擦除 泛型方法 的类型</p><p><img src="/images/JavaGenericTypes/31.png" alt></p><p><img src="/images/JavaGenericTypes/32.png" alt></p><h3 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h3><p>接口定义 T 转成 Object ; 实现类 Integer 还是 Integer</p><p>只是多个了桥接; 为了保持编译后的接口和实现关系</p><p><img src="/images/JavaGenericTypes/33.png" alt></p><p><img src="/images/JavaGenericTypes/34.png" alt></p><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><h3 id="可以创建带泛型的数组引用，但是不能-直接-创建带泛型的-数组对象"><a href="#可以创建带泛型的数组引用，但是不能-直接-创建带泛型的-数组对象" class="headerlink" title="可以创建带泛型的数组引用，但是不能 直接 创建带泛型的 数组对象"></a>可以创建带泛型的数组引用，但是不能 直接 创建带泛型的 数组对象</h3><p><img src="/images/JavaGenericTypes/35.png" alt></p><p><img src="/images/JavaGenericTypes/36.png" alt></p><p>跳过原生 ArrayList 对象引用; 直接将 原生ArrayList 数组 赋给 泛型ArrayList; 后面就有类型检查</p><p><img src="/images/JavaGenericTypes/37.png" alt></p><p><img src="/images/JavaGenericTypes/38.png" alt></p><p>主要是因为泛型在编译的时候会做类型擦除，而数组会一直保持它的初始类型</p><h3 id="可以通过-java-lang-reflect-Array-的-newInstance-Class-int-创建-T-数组"><a href="#可以通过-java-lang-reflect-Array-的-newInstance-Class-int-创建-T-数组" class="headerlink" title="可以通过 java.lang.reflect.Array 的 newInstance(Class,int) 创建 T[] 数组"></a>可以通过 java.lang.reflect.Array 的 newInstance(Class,int) 创建 T[] 数组</h3><p><img src="/images/JavaGenericTypes/39.png" alt></p><h2 id="反射常用的泛型类"><a href="#反射常用的泛型类" class="headerlink" title="反射常用的泛型类"></a>反射常用的泛型类</h2><ul><li><code>Class&lt;T&gt;</code></li><li><code>Constructor&lt;T&gt;</code></li></ul><p><img src="/images/JavaGenericTypes/40.png" alt></p><p><img src="/images/JavaGenericTypes/41.png" alt></p><p>class.var IDEA的快捷方式生成引用 和 Ctrl+Alt+V 一个效果</p><p><img src="/images/JavaGenericTypes/42.png" alt></p><p><img src="/images/JavaGenericTypes/43.png" alt></p><p><img src="/images/JavaGenericTypes/44.png" alt></p><p><img src="/images/JavaGenericTypes/45.png" alt></p><p><img src="/images/JavaGenericTypes/46.png" alt></p><h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><ul><li>类型安全</li><li>减少强制类型转换</li></ul><h2 id="类型参数标识符"><a href="#类型参数标识符" class="headerlink" title="类型参数标识符"></a>类型参数标识符</h2><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（表示Java 类，包括基本的类和我们自定义的类）</li><li>K - Key（表示键，比如Map中的key）</li><li>V - Value（表示值）</li><li>N - Number（表示数值类型）</li><li>？ - （表示不确定的java类型）</li><li>S、U、V - 2nd、3rd、4th types</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型类&quot;&gt;&lt;a href=&quot;#泛型类&quot; class=&quot;headerlink&quot; title=&quot;泛型类&quot;&gt;&lt;/a&gt;泛型类&lt;/h2&gt;&lt;p&gt;泛型类,是在实例化类的时候, 指明 泛型的具体类型&lt;/p&gt;
&lt;h3 id=&quot;泛型的类型参数不支持基本类型-只能是类对象类型&quot;&gt;&lt;a href=&quot;#泛型的类型参数不支持基本类型-只能是类对象类型&quot; class=&quot;headerlink&quot; title=&quot;泛型的类型参数不支持基本类型,只能是类对象类型&quot;&gt;&lt;/a&gt;泛型的类型参数不支持基本类型,只能是类对象类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Generic&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; genericl = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Generic&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;// ❌&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Generic&amp;lt;Integer&amp;gt; genericl = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Generic&amp;lt;Integer&amp;gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// ✔&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👉&lt;a href=&quot;https://qastack.cn/programming/2721546/why-dont-java-generics-support-primitive-types&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么Java泛型不支持基本类型？&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是为了向后兼容
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSS Five Classic Layouts</title>
    <link href="http://www.orekiyuta.cn/archives/CSSFiveClassicLayouts/"/>
    <id>http://www.orekiyuta.cn/archives/CSSFiveClassicLayouts/</id>
    <published>2020-11-09T13:34:06.000Z</published>
    <updated>2020-11-09T14:44:29.766Z</updated>
    
    <content type="html"><![CDATA[<p>CSS的五种经典布局<br><a id="more"></a></p><h2 id="空间居中"><a href="#空间居中" class="headerlink" title="空间居中"></a>空间居中</h2><p><img src="/images/CSSFiveClassicLayouts/1.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span> <span class="attr">contenteditable</span>&gt;</span>:)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">place-items</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: lightblue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">resize</span>: both;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">background</span>: lightpink;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: system-ui, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定 Gird 布局,并且 <code>place-items:center;</code></li><li><code>place-items:center;</code> 是简写</li><li>全写为  <code>place-items:center center;</code> // <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code> 垂直 水平</li><li><code>place-items:start;</code>左上角  <code>place-items:end</code>右下角</li></ul><h2 id="并列式"><a href="#并列式" class="headerlink" title="并列式"></a>并列式</h2><p><img src="/images/CSSFiveClassicLayouts/2.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/3.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/4.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">  flex-wrap: wrap;//可换行</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">flex</span>: 0 1 300<span class="selector-tag">px</span>; <span class="comment">/*初始宽度300px,不可以扩大,宽度不足300px时可缩小*/</span></span></span><br><span class="line"><span class="css"> <span class="comment">/*flex: 1 1 300px;可扩大可缩小,就是始终占满*/</span></span></span><br><span class="line"><span class="undefined">  border: 1px solid red;</span></span><br><span class="line"><span class="undefined">  background: lightpink;</span></span><br><span class="line"><span class="undefined">  font-size: 2rem;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">  font-family: system-ui, serif;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>指定 flex 布局, <code>felx-wrap:wrap;</code>设置可换行</li><li><code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;</code></li><li>flex: &lt;初始宽度&gt;  &lt;足够宽时是否扩大&gt;  &lt;宽度不够时是否缩小&gt; </li></ul><h2 id="两栏式"><a href="#两栏式" class="headerlink" title="两栏式"></a>两栏式</h2><p>一边保持,另一边伸缩</p><p><img src="/images/CSSFiveClassicLayouts/5.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/6.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">  display: grid;</span></span><br><span class="line"><span class="undefined">  grid-template-columns: minmax(150px, 25%) 1fr;</span></span><br><span class="line"><span class="undefined">  padding: 0;</span></span><br><span class="line"><span class="undefined">  margin: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.sidebar</span> &#123;</span></span><br><span class="line"><span class="undefined">  height: 100vh;</span></span><br><span class="line"><span class="undefined">  background: lightpink;</span></span><br><span class="line"><span class="undefined">  font-size: 2rem;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="undefined">  padding: 2rem;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">  font-family: system-ui, serif;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">  Min: 150px</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  Max: 25%</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetur adipisicing elit. Omnis nulla architecto maxime modi nisi. Quas saepe dolorum, architecto quia fugit nulla! Natus, iure eveniet ex iusto tempora animi quibusdam porro?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>grid-template-columns: minmax(150px, 25%) 1fr;</code></li><li>minmax(150px, 25%) 左边最小150px,最大为总宽度25%</li><li>1fr 右边为剩余宽度</li></ul><h2 id="三明治"><a href="#三明治" class="headerlink" title="三明治"></a>三明治</h2><p>垂直分为三部分：页眉,内容,页脚;基本上只是内容区在变化</p><p><img src="/images/CSSFiveClassicLayouts/7.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/8.png" alt></p><ul><li><code>grid-template-rows: auto 1fr auto;</code> 上中下</li></ul><h2 id="圣杯"><a href="#圣杯" class="headerlink" title="圣杯"></a>圣杯</h2><p>页面分为五个部分：页眉,页脚,内容区划分为左边栏,主栏,右边栏</p><p><img src="/images/CSSFiveClassicLayouts/9.png" alt></p><ul><li>指定 Grid 布局</li><li><code>grid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;</code></li><li><code>grid-template: auto 1fr auto / auto 1fr auto</code> 上中下都分成三部分</li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://1linelayouts.glitch.me/" target="_blank" rel="noopener">1linelayouts (https://1linelayouts.glitch.me/)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS的五种经典布局&lt;br&gt;
    
    </summary>
    
    
    
      <category term="CSS" scheme="http://www.orekiyuta.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Java Review</title>
    <link href="http://www.orekiyuta.cn/archives/JavaReview/"/>
    <id>http://www.orekiyuta.cn/archives/JavaReview/</id>
    <published>2020-11-05T12:20:57.000Z</published>
    <updated>2020-11-09T14:46:22.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ul><li><code>Car carKey</code> 创建了引用实例</li><li><code>new Car()</code> 创建了对象</li><li><code>Car carKey = new Car();</code> 把对象赋给引用它的实例</li></ul><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><ul><li>静态属性 &gt; 静态方法 &gt; 普通属性 &gt; 普通方法 &gt; 构造函数 </li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>this 指向当前的对象</li><li>this 可以调用方法、调用属性、和指向对象本身</li><li><img src="/images/JavaReview/1.png" alt><a id="more"></a><h2 id="封装-访问控制权限"><a href="#封装-访问控制权限" class="headerlink" title="封装(访问控制权限)"></a>封装(访问控制权限)</h2></li><li><img src="/images/JavaReview/2.png" alt></li></ul><h2 id="多态实现"><a href="#多态实现" class="headerlink" title="多态实现"></a>多态实现</h2><ul><li>继承</li><li>重写父类方法</li><li>父类引用指向子类对象 <code>Fruit fruit = new Apple();</code></li></ul><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>就是将对象应用放在新的类中就可以了</p><ul><li>多用组合，少用继承</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoccerPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Soccer soccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soccer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String soccerName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><img src="/images/JavaReview/3.png" alt></p></li></ul><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ul><li>抽象等级: 接口 &gt; 抽象类</li><li>接口定义了方法，抽象类定义了稍微具体点的方法</li><li>接口的实现必须实现全部方法，否则就该使用抽象类定义</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>编译期异常、运行期异常</li><li>Throwable 类是 Java 语言中所有 errors 和 exceptions 的父类</li><li>除了 RuntimeException 和它的子类，以及 error 和它的子类，其他所有异常都是 checkedException</li><li><img src="/images/JavaReview/4.png" alt></li><li><img src="/images/JavaReview/5.png" alt></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>就是将一个类的定义放在另一个类的内部</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            name = <span class="string">"elias"</span>;</span><br><span class="line">            age = <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个内部类都能独立地继承一个（接口）的实现，无论外部类是否已经继承了某个（接口的）实现，隐藏了内部实现的细节</p></li><li>内部类拥有外部类的访问权限</li><li>内部类还可以定义在方法和作用域内部，称为 局部内部类</li><li>内部类可以实现 Java 中的多重继承</li><li><img src="/images/JavaReview/6.png" alt></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><img src="/images/JavaReview/7.png" alt></li><li><img src="/images/JavaReview/8.png" alt></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是一种参数化的集合，限制了你添加进集合的类型</p><ul><li><img src="/images/JavaReview/9.png" alt></li></ul><h3 id="用泛型表示类"><a href="#用泛型表示类" class="headerlink" title="用泛型表示类"></a>用泛型表示类</h3><ul><li>泛型可以加到类上面，来表示这个类的类型</li><li><img src="/images/JavaReview/10.png" alt></li></ul><h3 id="用泛型表示接口"><a href="#用泛型表示接口" class="headerlink" title="用泛型表示接口"></a>用泛型表示接口</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般泛型接口常用于 生成器（generator），生成器相当于对象工厂，是一种专门用来创建对象的类</p></li></ul><h3 id="用泛型来表示方法"><a href="#用泛型来表示方法" class="headerlink" title="用泛型来表示方法"></a>用泛型来表示方法</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>List 是泛型类，为了表示各种泛型 List 的父类，可以使用通配符（?）表示，它的元素类型可以匹配任何类型</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();     </span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();     </span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();     </span><br><span class="line">        name.add(<span class="string">"elias"</span>);</span><br><span class="line">        age.add(<span class="number">22</span>);</span><br><span class="line">        number.add(<span class="number">824</span>);</span><br><span class="line">        generic(name);</span><br><span class="line">        generic(age);</span><br><span class="line">        generic(number);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generic</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test cxuan :"</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  ```        </span><br><span class="line">- 上界通配符：&lt;? extends ClassType&gt; 该通配符为 ClassType 的所有子类型。他表示的是任何类型都是 ClassType 类型的子类</span><br><span class="line">- 下界通配符：&lt;? <span class="keyword">super</span> ClassType&gt; 该通配符为 ClassType 的所有超类型。他表示的是任何类型的父类都是 ClassType</span><br><span class="line"></span><br><span class="line">## 反射</span><br><span class="line">反射主要提供了以下几个功能</span><br><span class="line">- 在运行时，判断任意一个对象所属的类</span><br><span class="line">- 在运行时，构造任意一个类的对象 </span><br><span class="line">- 在运行时，判断任意一个类所有的成员变量和方法</span><br><span class="line">- 在运行时，调用任意一个对象的方法</span><br><span class="line">- `java.lang.reflect`所涉及的类</span><br><span class="line">- ![](/images/JavaReview/<span class="number">11</span>.png)</span><br><span class="line">以下实例验证了一下</span><br><span class="line">- ![](/images/JavaReview/<span class="number">12</span>.png)</span><br><span class="line">- ![](/images/JavaReview/<span class="number">13</span>.png)</span><br><span class="line"></span><br><span class="line">## 枚举</span><br><span class="line">- 编辑器会为创建好的枚举自动添加 toString(),ordinal(),values()</span><br><span class="line">- ordinal()表示Enum常量的声明顺序</span><br><span class="line">- values(）显示顺序的值</span><br><span class="line">- ![](/images/JavaReview/<span class="number">14</span>.png)</span><br><span class="line">- `Family father = Family.FATHER;` 枚举可以直接调用 </span><br><span class="line"></span><br><span class="line">一般 <span class="keyword">switch</span> 可以和 <span class="keyword">enum</span>  一起连用，来构造一个小型的状态转换机</span><br><span class="line">- ```java </span><br><span class="line">    <span class="keyword">enum</span> Signal&#123;</span><br><span class="line">        GREEN,YELLOW,RED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trafficlight</span></span>&#123;</span><br><span class="line">        Signal color = Signal.GREEN;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (color)&#123;</span><br><span class="line">                <span class="keyword">case</span> GREEN:</span><br><span class="line">                    color = Signal.YELLOW;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YELLOW:</span><br><span class="line">                    color = Signal.RED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RED:</span><br><span class="line">                    color = Signal.GREEN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><ul><li><img src="/images/JavaReview/15.png" alt></li><li><p><img src="/images/JavaReview/16.png" alt></p></li><li><p>路径分隔符（Window 是 ; linux 是 :）</p></li><li>路径名称分隔符（Window 是 \ linux 是 /）</li><li><img src="/images/JavaReview/17.png" alt></li></ul><p>对文件操作</p><ul><li><img src="/images/JavaReview/18.png" alt></li></ul><p>对文件夹操作</p><ul><li><img src="/images/JavaReview/19.png" alt></li><li>三种创建方式</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String directoryPath);</span><br><span class="line">File(String directoryPath, String filename); </span><br><span class="line">File(File dirObj, String filename);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"D:\\java\\file1.txt"</span>); </span><br><span class="line">System.out.println(file);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\java"</span>,<span class="string">"file2.txt"</span>);</span><br><span class="line">File parent = <span class="keyword">new</span> File(<span class="string">"D:\\java"</span>);</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent,<span class="string">"file3.txt"</span>);</span><br><span class="line">System.out.println(file3);</span><br></pre></td></tr></table></figure></li><li><p><img src="/images/JavaReview/20.png" alt></p></li></ul><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><ul><li><img src="/images/JavaReview/21.png" alt><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3></li><li><img src="/images/JavaReview/22.png" alt><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3></li><li><img src="/images/JavaReview/23.png" alt><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3></li><li><img src="/images/JavaReview/24.png" alt></li></ul><h2 id="java-io-lang-math-net"><a href="#java-io-lang-math-net" class="headerlink" title="java.io/lang/math/net"></a>java.io/lang/math/net</h2><ul><li><img src="/images/JavaReview/25.png" alt></li><li><img src="/images/JavaReview/26.png" alt></li><li><img src="/images/JavaReview/27.png" alt></li><li><img src="/images/JavaReview/28.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象创建&quot;&gt;&lt;a href=&quot;#对象创建&quot; class=&quot;headerlink&quot; title=&quot;对象创建&quot;&gt;&lt;/a&gt;对象创建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Car carKey&lt;/code&gt; 创建了引用实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new Car()&lt;/code&gt; 创建了对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Car carKey = new Car();&lt;/code&gt; 把对象赋给引用它的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;初始化顺序&quot;&gt;&lt;a href=&quot;#初始化顺序&quot; class=&quot;headerlink&quot; title=&quot;初始化顺序&quot;&gt;&lt;/a&gt;初始化顺序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;静态属性 &amp;gt; 静态方法 &amp;gt; 普通属性 &amp;gt; 普通方法 &amp;gt; 构造函数 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;this 指向当前的对象&lt;/li&gt;
&lt;li&gt;this 可以调用方法、调用属性、和指向对象本身&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;/images/JavaReview/1.png&quot; alt&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>How Networks Works / After reading</title>
    <link href="http://www.orekiyuta.cn/archives/HowNetworksWorks/"/>
    <id>http://www.orekiyuta.cn/archives/HowNetworksWorks/</id>
    <published>2020-06-27T13:29:16.000Z</published>
    <updated>2020-11-19T15:28:00.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器生成消息—浏览器内部"><a href="#浏览器生成消息—浏览器内部" class="headerlink" title="浏览器生成消息—浏览器内部"></a>浏览器生成消息—浏览器内部</h2><p><img src="/images/HowNetworksWorks/1.png" alt></p><h3 id="生成-HTTP-请求消息"><a href="#生成-HTTP-请求消息" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h3><h4 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h4><ul><li>URL:Uniform Resource Locator</li><li>FTP:File Transfer Protocol</li></ul><p><img src="/images/HowNetworksWorks/2.png" alt></p><ul><li>协议：通信操作的规则</li><li>URL 开头部分，表示浏览器应当使用的方法；比如：http,ftp,file,mailto</li><li>Web浏览器解析 URL 过程<ul><li><img src="/images/HowNetworksWorks/3.png" alt></li><li><img src="/images/HowNetworksWorks/4.png" alt><a id="more"></a><h4 id="URL-省略"><a href="#URL-省略" class="headerlink" title="URL 省略"></a>URL 省略</h4></li></ul></li><li><p><code>http://www.lab.glasscom.com/dir/</code></p><ul><li>像这个 URL 其实背后省略了具体文件</li><li>一般服务器上会事先设置好文件名省略时要访问的默认文件名</li><li>根据不同的服务器而不同，大多数情况是 index.html 之类</li><li>完整的访问地址为 <code>http://www.lab.glasscom.com/dir/index.html</code></li></ul></li><li><p><code>http:/www.lab.glasscom.com/</code> </p><ul><li>这种也是省略了的; 一般情况完整为 <code>http:?/www.lab.glasscom.com/index.html</code></li><li>其实以 “/” 结尾，表示它访问了名为 “/” 的目录; “/” 顶级目录，根目录</li><li>前面的 dir/ 就是访问 dir目录下的内容</li></ul></li><li><p><code>http:/www.lab.glasscom.com</code> </p><ul><li>这个连根目录 “/” 也省略了</li><li>连目录都不知道的情况下,也就是没有路径名的情况下；一般代表访问根目录下事先设置的默认文件</li></ul></li><li><p><code>http:/www.lab.glasscom.com/whatisthis</code></p><ul><li>这种情况，可能是末尾 “/” 省略了，可也能没省略 ;事实上是很多人没有正确理解省略文件名的规则，经常把目录结尾的 “/” 省略了</li><li>这种情况应该按照以下处理</li><li>如果 Web 服务器上存在名为 whatisthis 的文件,则将它作为文件名处理</li><li>如果存在名为 whatisthis 的目录，则当作目录名来处理</li><li>Linux 下无法创建两个名字相同的文件和目录；因此不可能既有一个名为 whatisthis 的文件，同时又有一个名为 whatisthis 的目录</li></ul></li></ul><h4 id="HTTP-基本思路"><a href="#HTTP-基本思路" class="headerlink" title="HTTP 基本思路"></a>HTTP 基本思路</h4><p><img src="/images/HowNetworksWorks/5.png" alt></p><ul><li>URI:Uniform Resource Identifier</li><li>一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等</li><li>不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为 URI</li><li><p>CGI 程序：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI，而按照 CGI 规范来工作的程序就称为 CGI 程序</p></li><li><p>HTTP 的主要方法<br><img src="/images/HowNetworksWorks/6.png" alt></p></li><li><p>请求/响应<br><img src="/images/HowNetworksWorks/7.png" alt></p></li></ul><p><img src="/images/HowNetworksWorks/8.png" alt></p><p><img src="/images/HowNetworksWorks/9.png" alt></p><p><img src="/images/HowNetworksWorks/10.png" alt></p><p><img src="/images/HowNetworksWorks/11.png" alt></p><ul><li>一次请求响应过程<br><img src="/images/HowNetworksWorks/12.png" alt></li></ul><p><img src="/images/HowNetworksWorks/13.png" alt></p><p><img src="/images/HowNetworksWorks/14.png" alt></p><h3 id="向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="向 DNS 服务器查询 Web 服务器的 IP 地址"></a>向 DNS 服务器查询 Web 服务器的 IP 地址</h3><h4 id="TCP-IP-结构思路"><a href="#TCP-IP-结构思路" class="headerlink" title="TCP/IP 结构思路"></a>TCP/IP 结构思路</h4><p><img src="/images/HowNetworksWorks/15.png" alt></p><ul><li>目前大部分路由器已经内置了集线器功能</li><li><p>数据是以包的形式传送的</p></li><li><p>IP地址：一串 32 bit 的数字，按照 8 bit 为一组分成4组，分别用十进制表示</p></li><li>但单凭这串数字还是无法区分哪部分是网络号，哪部分是主机号</li></ul><p><img src="/images/HowNetworksWorks/16.png" alt></p><ul><li>在IP地址的规则里，网络号加主机号总共是32bit，但是这两部分具体结构是不固定的</li><li>因此还要附加信息（子网掩码）来表示IP地址的内部结构</li></ul><p><img src="/images/HowNetworksWorks/17.png" alt></p><p><img src="/images/HowNetworksWorks/18.png" alt></p><h4 id="DNS-由来"><a href="#DNS-由来" class="headerlink" title="DNS 由来"></a>DNS 由来</h4><ul><li>确定通信对象需要知道它的IP地址</li><li>如果不知道通信对象的IP地址，就无法进行通信，需要事先查询记好</li><li>使用IP地址可以代替使用服务器名称（域名）去访问</li><li>但是如果通信对象的Web服务器使用了虚拟主机，有可能用IP地址访问不了</li><li>网络中存在无数的路由器，相互配合，根据IP地址来转发数据</li><li>用域名去访问对象比用IP去访问效率要低</li><li>因为IP地址长度32bit,4字节；而域名要几十字节；增加了路由器的负担，自然消耗的时间要更长</li><li>域名并不仅是长，而且其长度是不固定的。处理长度不固定的数据比处理长度固定的数据要复杂，这也是造成效率低下的重要原因之一</li><li>（1）由于IP难以记住（2）使用域名效率低下</li><li>因此，使用了折中的方案：让人使用域名，路由器使用IP</li><li>为了达成这个目的，把域名和IP做关联的机制就诞生了，称为DNS:Domain Name System</li><li>Domain Name System ：将服务器名称和 IP 地址进行关联是 DNS 最常见的用法，但 DNS 的功能并不仅限于此，它还可以将邮件地址和邮件服务器进行关联，以及为各种信息关联相应的名称</li></ul><h4 id="DNS-解析器"><a href="#DNS-解析器" class="headerlink" title="DNS 解析器"></a>DNS 解析器</h4><ul><li>相对于DNS服务器，我们的计算机上一定有相应的DNS客户端（解析器），存在于操作系统的 Socket 库中</li></ul><p><img src="/images/HowNetworksWorks/19.png" alt></p><ul><li>大概流程是<ul><li>（1）使用DNS解析器把域名解析写入内存，接着交给操作系统向DNS服务器发送查询消息</li><li>（2）然后DNS服务器响应消息，解析器取出IP地址，存入浏览器指定的内存地址</li><li>（3）浏览器在向Web服务器发送请求的时候，从该内存地址取出IP地址，将它和HTTP请求一起提交给操作系统</li></ul></li></ul><p><img src="/images/HowNetworksWorks/20.png" alt></p><ul><li>HTTP消息是用文本编写的，但DNS消息是使用二进制数据编写的</li><li><p>浏览器本身不具备使用网络收发数据的功能，都是由操作系统内部的协议栈（操作系统内部的网络控制软件，也叫协议驱动，TCP/IP驱动，等等）来执行的</p></li><li><p>向DNS服务器发送消息的时候，也是要知道DNS服务器的IP地址的，只不过这个IP地址作为TCP/IP的一个设置项目事先设置好了</p></li></ul><p><img src="/images/HowNetworksWorks/21.png" alt></p><h3 id="全世界-DNS-服务器的大接力"><a href="#全世界-DNS-服务器的大接力" class="headerlink" title="全世界 DNS 服务器的大接力"></a>全世界 DNS 服务器的大接力</h3><h4 id="DNS-基本工作"><a href="#DNS-基本工作" class="headerlink" title="DNS 基本工作"></a>DNS 基本工作</h4><ul><li>来自客户端解析器的查询信息<ul><li>域名</li><li>Class:以前设计的时候，还需要标识网络信息，不过现在除了互联网以外没有其他网络了</li><li>记录类型:标识域名对应何种记录类型；比如 A(Address) 标识了域名对应的是IP地址、MX(Mail eXchange) 标识了对应邮件服务器</li></ul></li></ul><p><img src="/images/HowNetworksWorks/22.png" alt></p><p><img src="/images/HowNetworksWorks/23.png" alt></p><h4 id="域名层次结构"><a href="#域名层次结构" class="headerlink" title="域名层次结构"></a>域名层次结构</h4><ul><li>互联网中存在无数的服务器，将这些服务器信息存在一台DNS服务器是不可能的</li><li>因此，将信息分布保存在多台DNS服务器中，层层追溯</li><li><p><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener">www.lab.glasscom.com</a></p><ul><li>越靠右边，层级越高</li><li><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener">www.lab.glasscom.com</a> &lt; lab.glasscom.com &lt; glasscom.com &lt; com</li><li>每个层级可以称为域，每个域作为一个整体存放在DNS服务器中（但是，DNS服务器和域也并不总是一对一的）</li></ul></li><li><p>互联网中那么多台DNS服务器，肯定不能挨个去找</p></li><li>因此，将下级域的IP地址注册到它们的上级域的DNS服务器中，就和链表，区块链一个意思</li><li>也就是说，负责管理 lab.glasscom.com 域的DNS服务器的IP地址注册到 glasscom.com 域的DNS服务器中，而 glasscom.com 域的DNS服务器的IP地址又注册到了 com 域的DNS服务器中</li><li>这样就可以从顶级开始层层追溯了<ul><li>目前来说，一般 com,jp 称为顶级域</li><li>但是事实上它们上面还有一级域，称为根域</li><li>根域并没有名字，因此常常被省略</li><li><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener">www.lab.glasscom.com</a>.  最后一个点就代表根域（和根目录一个思路）</li></ul></li></ul><p><img src="/images/HowNetworksWorks/24.png" alt></p><ul><li>根域的DNS服务器信息保存在全互联网所有DNS服务器中，这样一来就完成了<ul><li>分配给根域DNS服务器的IP地址在全世界只有13个，这些地址几乎不变化，所以就可以保存在所有DNS服务器中了</li><li>根域 DNS 服务器在运营上使用多台服务器来对应一个 IP 地址，因此尽管 IP 地址只有 13 个，但其实服务器的数量是很多的</li></ul></li></ul><p><img src="/images/HowNetworksWorks/25.png" alt></p><ul><li>客户端计算机第一次访问的DNS服务器也就是我们在TCP/IP中设置的DNS服务器（所以改DNS也是有讲究的）</li><li><p>第一次访问的DNS服务器作为所有访问查询的中继点，如图所示</p></li><li><p>上图追溯只是基本原理，真实互联网一台DNS服务器可以管理多个域的信息，因此并不是每个域都有一台自己的DNS服务器</p><ul><li>现实中上下级域有可能共享同一台DNS服务器</li><li>此外，有时候并不需要从最上级的根域开始查找，因为DNS服务器有个缓存功能</li><li>缓存可以记住之前查询过的域名；<ul><li>如果要查询的域名和相关信息已经在缓存中，就可以直接从缓存的位置开始向下查询；减少查询时间</li><li>并且，当要查询的域名信息不存在时，“不存在”这个响应结果也会被缓存；当下次查询这个不存在的域名时，也可以快速响应</li><li>需要注意的是，信息被缓存后，原本的注册信息可能会发生改变，这时缓存的信息就有可能是不正确的</li><li>因此，DNS服务器中保存的信息都会设置一个有效期；而且在查询响应时，DNS服务器也会告知客户端这个响应结果是来自缓存还是来自负责管理该域名的DNS服务器</li></ul></li></ul></li></ul><h3 id="委托协议栈发送信息"><a href="#委托协议栈发送信息" class="headerlink" title="委托协议栈发送信息"></a>委托协议栈发送信息</h3><h4 id="数据收发操作概览"><a href="#数据收发操作概览" class="headerlink" title="数据收发操作概览"></a>数据收发操作概览</h4><ul><li><p>知道IP地址后，就可以委托操作系统内部的协议栈像这个目标IP地址，发送HTTP消息（数字消息）了</p></li><li><p>收发数字消息这个操作不局限于浏览器，对于各种使用网络的应用程序都是共通的</p></li></ul><p><img src="/images/HowNetworksWorks/26.png" alt></p><p><img src="/images/HowNetworksWorks/27.png" alt></p><ul><li><p>在收发数据操作之前，双方需要先建立连接（建立如图的假设出来的管道）</p><ul><li>建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字</li><li>我们需要先创建套接字，然后再将套接字连接起来形成管道</li></ul></li><li><p>实际上过程如下</p><ul><li>服务器一方先创建套接字，等待客户端向该套接字连接管道</li><li>当服务器进入等待状态，客户端就可以连接管道了</li><li>客户端也会先创建套接字，然后从该套接字延伸出管道，</li><li>最后连接到服务器端的套接字上</li><li>之后就可以收发数据了</li><li>数据发送完毕后，断开时可以由任意一方发起</li></ul></li><li><p>综上所述，可以总结为4个阶段</p><ul><li>创建套接字（创建套接字阶段）</li><li>将管道连接到服务器段的套接字上（连接阶段）</li><li>收发数据（通信阶段）</li><li>断开管道并删除套接字（断开阶段）</li></ul></li><li><p>以上的操作都是由操作系统内部的协议栈来执行的，浏览器和应用程序并不会自己去做这些工作，而是“委托”协议栈来做</p></li><li>这些“委托”都是通过调用 Socket库中的程序组件来执行的，这些数据通信用的组件充当了桥梁的角色</li></ul><h4 id="创建套接字阶段"><a href="#创建套接字阶段" class="headerlink" title="创建套接字阶段"></a>创建套接字阶段</h4><p><img src="/images/HowNetworksWorks/28.png" alt></p><ul><li>套接字创建完毕后，协议栈会返回一个描述符</li><li>应用程序会将收到的描述符存在内存中</li><li>描述符用来识别不同的套接字，因为实际上会有多个数据同时通信</li></ul><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><ul><li>连接的时候还需要给出IP地址的具体端口号（表示具体哪个应用程序）</li><li>然后再从那个应用程序中找按照标识符找到对应的套接字</li></ul><p><img src="/images/HowNetworksWorks/29.png" alt></p><h4 id="通信阶段"><a href="#通信阶段" class="headerlink" title="通信阶段"></a>通信阶段</h4><ul><li>连接完毕之后，接下来就通过 Sokcet库委托协议栈来将 应用程序在内存中准备好的数据 送入套接字</li><li>接着协议栈再将数据发送到服务器</li><li>服务器接收到数据后，执行相应的操作，再返回消息给客户端</li></ul><h4 id="断开阶段"><a href="#断开阶段" class="headerlink" title="断开阶段"></a>断开阶段</h4><ul><li>Web 使用的HTTP协议规定，当Web服务器发送完响应消息后，应该主动断开操作</li><li>HTTP协议将HTML文档和图片都作为单独对象处理，因此要执行很多次连接断开操作</li><li>所以后来HTTP 1.1 就可以在一次连接中收发多个请求响应</li></ul><h2 id="用电信号传输-TCP-IP-数据—协议栈、网卡"><a href="#用电信号传输-TCP-IP-数据—协议栈、网卡" class="headerlink" title="用电信号传输 TCP/IP 数据—协议栈、网卡"></a>用电信号传输 TCP/IP 数据—协议栈、网卡</h2><p><img src="/images/HowNetworksWorks/30.png" alt></p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><ul><li>协议栈内部结构</li></ul><p><img src="/images/HowNetworksWorks/31.png" alt></p><p><img src="/images/HowNetworksWorks/32.png" alt></p><ul><li>ICMP用于告知网络包传送过程中产生的错误以及各种控制消息</li><li>ARP用于根据IP地址查询相应的以太网MAC地址</li><li>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等<ul><li>套接字只是一个概念而已，可以说这些控制信息就是套接字</li><li>协议栈根据套接字的信息进行活动，这就是套接字的作用</li></ul></li><li>下图的每一行相当于一个套接字</li><li><p>PID:Process ID<br><img src="/images/HowNetworksWorks/33.png" alt></p></li><li><p>下图是浏览器委托协议栈使用TCP协议来收发数据</p></li></ul><p><img src="/images/HowNetworksWorks/34.png" alt></p><ul><li>协议栈首先会分配用于存放一个套接字所需的内存空间</li><li>然后向套接字的内存空间里写入表示这一初始状态的控制信息</li><li>这样一来套接字就创建完毕了</li><li>然后将这个套接字的描述符告诉应用程序；之后应用程序在向协议栈进行收发数据委托的时候就带着这个描述符，就能确定了相应的套接字，协议栈就能获取在相应套接字内相关的控制信息了</li></ul><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><ul><li><p>“连接”是什么意思</p><ul><li>网线一直是连着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这个操作随时都可以进行</li><li>套接字创建完成的时候，里面还没有任何存放任何控制信息，这种状态下即使应用程序要求发送数据，协议栈也不知道发送给谁</li><li>协议栈需要等待我们在套接字中存入控制信息</li><li>服务器程序一般会在系统启动的时候就创建套接字并等待客户端连接</li><li>和客户端不同，服务器根本不知道想来通信的对象是谁<ul><li>就和打电话一样，对方在没接到电话之前，根本不可能知道打电话的人是谁</li></ul></li><li>连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作</li><li>连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备</li></ul></li><li><p>通信操作中使用的控制信息可以分为两大类</p><ul><li>（1）客户端和服务器相互联络交换的控制信息<ul><li>这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程都需要</li><li>这些内容在TCP协议中进行了定义</li><li><img src="/images/HowNetworksWorks/35.png" alt></li><li>这些信息会添加在客户端和服务器之间传递的网络包头部（这里是TCP的控制信息，简称TCP头部）<ul><li>其他协议也有自己的控制信息，以太网头部（MAC头部），IP头部</li></ul></li><li><img src="/images/HowNetworksWorks/36.png" alt></li></ul></li><li>（2）保存在套接字中，用来控制协议操作的信息<ul><li>应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作</li><li>我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的</li><li>“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同，但无论协议栈的实现如何不同，IP地址和端口号这些重要的信息都是共通的</li><li>虽然协议栈的实现不同，但是并不影响通讯；因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立</li><li>Windows 和Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同</li></ul></li></ul></li></ul><p><img src="/images/HowNetworksWorks/34.png" alt></p><ul><li><p>连接过程</p><ul><li>连接操作的第一步是在TCP模块出创建表示连接控制信息的头部（TCP头部）；通过TCP头部中的发送方和接受方端口号可以找到要连接的套接字</li><li>当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送  </li><li>IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器</li><li>然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块</li><li>服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字</li><li>当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接</li><li><p>然后 TCP 模块会返回响应到客户端，重复和客户端一样的过程</p><ul><li>服务器在返回响应的时候还需要再TCP头部设置发送方和接受方的端口号以及SYN比特，此外还要将ACK控制位设为1<ul><li>ACK 设为1表示以及接收到相应的网络包，ACK比特就是用来确认网络包是否送达的</li></ul></li></ul></li><li><p>客户端接收到响应信息并确认TCP头部信息的SYN为1,表示连接成功</p></li><li>接着就会向套接字中写入服务器的IP地址、端口号等信息；同时将状态改为连接完毕，</li><li>并将客户端的TCP头部ACK比特设置为1，发送给服务器，表明刚才的响应包已收到</li><li>这样连接就全部完成</li></ul></li></ul><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><h4 id="将-HTTP-请求信息交给协议栈"><a href="#将-HTTP-请求信息交给协议栈" class="headerlink" title="将 HTTP 请求信息交给协议栈"></a>将 HTTP 请求信息交给协议栈</h4><ul><li>协议栈收到应用程序传来的数据会先存放到发送缓冲区，等到应用程序继续传送数据，避免发送大量小网络包，导致网络效率下降</li><li><p>协议栈发送数据要根据以下几个要素来判断</p><ul><li><p>(1)每个网络包能容纳的数据长度，协议栈会根据一个叫作MTU（Maximum Transmission Unit）的参数来判断</p><ul><li>MTU表示每个网络包的最大长度，在以太网中一般是1500字节</li><li>MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS</li><li>当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去</li></ul><p><img src="/images/HowNetworksWorks/37.png" alt></p></li><li><p>(2)时间</p><ul><li>当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去</li><li>为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去</li></ul></li><li>两者其实是有矛盾的，具体如何达到平衡得看协议栈开发者</li></ul></li><li>如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项</li></ul><h4 id="拆分较大的数据"><a href="#拆分较大的数据" class="headerlink" title="拆分较大的数据"></a>拆分较大的数据</h4><ul><li>如果数据很大，比如长篇文章，这样发送缓冲区中数据长度就会超过MSS的长度</li><li>这样时候就不需要继续等待后面的数据了，直接以MSS长度为单位拆分</li><li>拆分出来的数据放进单独的网络包，在数据前面加上TCP头部，IP头部，MAC头部，然后发送</li></ul><p><img src="/images/HowNetworksWorks/38.png" alt></p><h4 id="使用-ACK-号确认网络包已收到"><a href="#使用-ACK-号确认网络包已收到" class="headerlink" title="使用 ACK 号确认网络包已收到"></a>使用 ACK 号确认网络包已收到</h4><p><img src="/images/HowNetworksWorks/39.png" alt></p><ul><li>TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能</li><li>TCP 模块在拆分数据的时候，会对数据做好标识，让服务器能够知道数据包有没有遗漏</li><li>返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网络包是用来告知 ACK 号的</li><li><p>实际的通信序号是随机的一个初始值，固定的序号容易被预测攻击</p><ul><li>因此在收发数据之前就将初始值告诉通信对象</li><li>在连接过程中将 SYN（Synchronize） 控制位设为 1 的时候，就在这一步同时设置了初始值</li></ul></li><li><p>上面的只是单项的数据传输，实际上客户端向服务器发送数据的同时，服务器也在向客户端发送数据</p></li></ul><p><img src="/images/HowNetworksWorks/40.png" alt></p><ul><li>实际的初始值序号和ACK确认流程如下</li></ul><p><img src="/images/HowNetworksWorks/41.png" alt></p><ul><li>因为有了 TCP 这个机制，我们可以确认接受方有没有收到某个包，如果没有收发则重新发送</li><li>这样一来，无论网络中发送任何错误，我们都可以发现并重传网络包</li><li>因此，网卡、集线器、路由器都不需要错误补偿机制了，一旦检测到错误，直接丢弃相应的包</li><li>在网络中断，服务器宕机，TCP 重传不起效，TCP会在尝试几次重传无效后强制结束通信，并向应用程序报错</li></ul><h4 id="根据网络包平均往返时间调整-ACK-号等待时间"><a href="#根据网络包平均往返时间调整-ACK-号等待时间" class="headerlink" title="根据网络包平均往返时间调整 ACK 号等待时间"></a>根据网络包平均往返时间调整 ACK 号等待时间</h4><ul><li><p>前面的只是基本原理，实际上网络的错误检测和补偿机制非常复杂</p></li><li><p>设置一个合理的返回 ACK 号的等待时间</p><ul><li>当网络拥塞的时候，ACK 号返回速度变慢，需要将等待时间设置长点，否则就会已经重传了包之后，前面的 ACK 号才姗姗来迟</li><li>重传了多余的包，数量多了之后会给本来就拥塞的网络雪上加霜</li><li>设置等待时间也不是越长越好，时间过长，包的重传就会出现很大的延迟，也会导致网络速度变慢</li><li>设置一个合理的值十分困难<ul><li>服务器的物理距离，拥塞情况，等都要考虑</li></ul></li><li>因此，TCP采用了动态调整等待时间的方法<ul><li>TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间 </li></ul></li></ul></li></ul><h4 id="使用窗口有效管理-ACK-号"><a href="#使用窗口有效管理-ACK-号" class="headerlink" title="使用窗口有效管理 ACK 号"></a>使用窗口有效管理 ACK 号</h4><p><img src="/images/HowNetworksWorks/42.png" alt></p><ul><li>使用滑动窗口的方式，时间是充分利用了，但是可能会出现发送包的频率超过接受方处理能力的情况<ul><li>接受方收到包后，会先将数据存放到接受缓冲区，然后计算ACK号，将数据块组装起来还原成数据并传递给应用程序</li><li>如果前面的操作没有完成，后面下一个包到了，会被暂存在接收缓冲区等待处理</li><li>如果数据到达的速率比处理这些数据并传递给应用程序的速率还要块，那么接受缓冲区中的数据越来越多，最终就会溢出</li><li>后面的数据包就收不到了，也就是超出了接受方的处理能力</li></ul></li><li>为了避免这种情况，首先接受方需要告诉发送方字节最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制</li></ul><p><img src="/images/HowNetworksWorks/43.png" alt></p><ul><li>这个能够接收的最大数据量称为 窗口大小 ，它是 TCP 调优参数中非常有名的一个</li></ul><h4 id="ACK-与-窗口的合并"><a href="#ACK-与-窗口的合并" class="headerlink" title="ACK 与 窗口的合并"></a>ACK 与 窗口的合并</h4><ul><li>要提高收发数据的效率，就要考虑返回ACK号和更新窗口的时机</li><li>更新窗口一般在接受方缓冲区剩余容量增加时，告知对方</li><li>ACK 号在接受到后就告知对方</li><li>如果这两个是单独的包，就会导致接受方给发送方的包太多，从而导致网络效率下降</li><li>因此，接受方会等待一段时，把两种通知的包合并在一个包发送</li></ul><h4 id="接收-HTTP-响应消息"><a href="#接收-HTTP-响应消息" class="headerlink" title="接收 HTTP 响应消息"></a>接收 HTTP 响应消息</h4><ul><li>首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号</li><li>然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序</li><li>具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序</li><li>将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新 </li></ul><h3 id="断开服务器并删除套接字"><a href="#断开服务器并删除套接字" class="headerlink" title="断开服务器并删除套接字"></a>断开服务器并删除套接字</h3><h4 id="数据发送完毕后断开连接"><a href="#数据发送完毕后断开连接" class="headerlink" title="数据发送完毕后断开连接"></a>数据发送完毕后断开连接</h4><ul><li>服务器的协议栈会生成包含断开信息的TCP头部，将控制位中的 FIN 比特设为 1</li><li>接下来，协议栈会委托IP模块向客户端发送数据</li><li>同时，服务器的套接字中也会记录下来断开操作的相关信息</li></ul><p><img src="/images/HowNetworksWorks/44.png" alt></p><ul><li>然后客户端接受到后，客户端的协议栈会将自己的套接字标记为进入断开操作状态</li><li><p>为了告诉服务器已经收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号</p></li><li><p>应用程序有可能在收到 FIN 为 1 的包之前就来读取数据，这时读取数据的操作会被挂起，等到 FIN 包到达再继续执行</p></li></ul><h4 id="删除套接字"><a href="#删除套接字" class="headerlink" title="删除套接字"></a>删除套接字</h4><ul><li>和服务器通信结束后，用来通信的套接字也不会再使用了</li><li>套接字并不会立刻被删除，而是等待一段时间之后再被删除<ul><li>为了防止误操作</li><li>假设，客户端先发起断开，则断开的操作顺序如下<ul><li>（1）客户端发送 FIN </li><li>（2）服务器返回 ACK 号</li><li>（3）服务器发送 FIN </li><li>（4）客户端返回 ACK 号</li></ul></li><li>如果最后客户端返回的 ACK 号丢失了，结果会如何呢？这时，服务器没有接收到 ACK 号，可能会重发一次 FIN。如果这时客户端的套接字已经删除了，会发生什么事呢？套接字被删除，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号 B，而服务器重发的 FIN 正好到达，会怎么样呢？本来这个 FIN 是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作</li></ul></li></ul><h4 id="TCP-整体流程"><a href="#TCP-整体流程" class="headerlink" title="TCP 整体流程"></a>TCP 整体流程</h4><p><img src="/images/HowNetworksWorks/45.png" alt></p><h3 id="IP-与以太网的包收发操作"><a href="#IP-与以太网的包收发操作" class="headerlink" title="IP 与以太网的包收发操作"></a>IP 与以太网的包收发操作</h3><h4 id="包的基本结构"><a href="#包的基本结构" class="headerlink" title="包的基本结构"></a>包的基本结构</h4><ul><li>网络包由头部和数据两部分构成<ul><li>头部包含了目的地址等控制信息，就和快递的地址电话一样</li><li>数据就相当于快递物件</li></ul></li></ul><p><img src="/images/HowNetworksWorks/46.png" alt></p><ul><li>发送网络包的时候，发送方的网络设备会负责创建包，创建包的过程就是生成含有正确控制信息的头部，然后再附上要发送的数据</li></ul><p><img src="/images/HowNetworksWorks/47.png" alt></p><p><img src="/images/HowNetworksWorks/48.png" alt></p><ul><li>首先会发往最近的网络转发设备，再发往其他网络设备，层层转发，最终达到接受方的网络设备<ul><li>路由器根据目标地址判断下一个路由器的位置</li><li>集线器在子网中将网络包传输到下一个路由</li></ul></li><li><p>集线器是按照 以太网 规则传输包的设备；而路由器是按照 IP 规则传输包的设备</p><ul><li>IP协议根据目标地址判断下一个IP转发设备的位置</li><li>子网中的以太网协议将包传输到下一个转发设备</li></ul></li><li><p>TCP/IP包含有两个头部:MAC头部（用于以太网协议）；IP头部（用于IP协议）</p></li></ul><h4 id="包的收发操作"><a href="#包的收发操作" class="headerlink" title="包的收发操作"></a>包的收发操作</h4><ul><li>在整个传输流程中，是由各种网络设备合力完成的；IP模块仅仅只是整个包的传输流程的入口</li></ul><p><img src="/images/HowNetworksWorks/49.png" alt></p><ul><li>包收发操作的起点是TCP模块委托IP模块发送网络包，这个过程中TCP模块在数据块前面加上TCP头部和指定通信对象的IP地址，然后传递给IP模块</li><li>收到委托后，IP模块将 前面的TCP头部和数据块 当作一个整体（二进制数据），然后在头部添加IP头部和MAC头部</li></ul><p><img src="/images/HowNetworksWorks/50.png" alt></p><ul><li>然后封装好的包会发送给网络设备，最近的就计算机的网卡；传递给网卡的网络包是二进制的</li><li>接着网卡将二进制的数字信息转换为电信号/光信号，通过网线/光纤发送出去</li><li>然后接受方收到后，逆向操作</li></ul><h4 id="生成包含接受方-IP-地址的-IP-头部"><a href="#生成包含接受方-IP-地址的-IP-头部" class="headerlink" title="生成包含接受方 IP 地址的 IP 头部"></a>生成包含接受方 IP 地址的 IP 头部</h4><p><img src="/images/HowNetworksWorks/51.png" alt></p><ul><li><p>IP头部最重要的内容就是接受方的IP地址，这个地址是由TCP模块告知的，而TCP模块又是在执行连接操作时从应用程序那里获得这个地址的</p></li><li><p>IP头部还需要有发送方的IP地址，这个IP地址一般大家认为是发送方的计算机IP地址</p><ul><li>实际上，IP地址不是分配给计算机的，而是分配给网卡的，当计算机有多块网卡的时候就有多个IP地址（服务器就有很多块网卡）</li></ul></li></ul><p><img src="/images/HowNetworksWorks/52.png" alt></p><ul><li>如何判断把包给那块网卡呢<ul><li>其实和路由器使用 IP 表判断下一个路由器位置的操作是一样的</li><li>因为协议栈的 IP模块与路由器中负责包收发的部分都是根据 IP 协议规则来进行包收发操作的，所以它们也都用相同的方法来判断把包发送给谁</li><li>IP 表又可以叫做 路由表</li></ul></li></ul><p><img src="/images/HowNetworksWorks/53.png" alt></p><ul><li>我们对套接字中记录的目的地 IP 地址与路由表左侧的 Network Destination 栏进行比较，找到对应的一行<ul><li>例如，TCP 模块告知的目标 IP 地址为 192.168.1.21，那么就对应图中的第 6 行，因为它和 192.168.1 的部分相匹配</li><li>如果目标 IP 地址为 10.10.1.166，那么就和 10.10.1 的部分相匹配，所以对应第 3 行</li></ul></li><li>Interface 列，表示网卡等网络接口，这些网络接口可以将包发送给通信对象</li><li>Gateway 列表示下一个路由器的 IP 地址，将包发给这个 IP 地址，该地址对应的路由器就会将包转发到目标地址 </li><li><p>路由表的第 1 行中，目标地址和子网掩码 A 都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行</p></li><li><p>最后还需要填写协议号，它标识包的内容来自哪个模块</p><ul><li>TCP模块，06（十六进制）</li><li>UDP模块，17（十六进制）</li></ul></li></ul><h4 id="生成以太网用的-MAC-头部"><a href="#生成以太网用的-MAC-头部" class="headerlink" title="生成以太网用的 MAC 头部"></a>生成以太网用的 MAC 头部</h4><p><img src="/images/HowNetworksWorks/54.png" alt></p><ul><li>生成了 IP 头部之后，接下来 IP 模块还需要在 IP 头部的前面加上MAC 头部</li><li>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里</li><li>但在以太网的世界中，TCP/IP 的这个思路是行不通的</li><li><p>以太网在判断网络包目的地时和 TCP/IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC 头部就是干这个用的</p></li><li><p>MAC 头部是以太网使用的头部，它包含了接受方和发送方的 MAC 地址信息等</p></li><li>IP 地址长度 32bit ; MAC 地址长度 48 bit</li><li><p>以太类型和协议号类似</p><ul><li>在IP中，协议号标识IP头部后面的包内容的类型</li><li>在以太网中，可以认为以太网类类型后面就是以太网包的内容<ul><li>而以太类型就表示后面内容的类型</li></ul></li><li>以太网包的内容可以是IP、ARP等协议的包</li></ul></li><li><p>以太类型，这里可以填写表示IP协议的值 0800（十六进制）</p></li><li><p>然后填写网卡本身的MAC地址，MAC地址是网卡生产时写入ROM里的，只要读取出来写入MAC头部就可以了</p></li><li><p>最后就和IP地址一样判断从那块网卡发送网络包，把这块网卡的MAC地址填进去<br><img src="/images/HowNetworksWorks/55.png" alt></p></li><li>但是，接受方的MAC地址根本不知道，所以我们还需要根据IP地址查询MAC地址的操作</li></ul><h4 id="通过-ARP-查询目标路由器的-MAC-地址"><a href="#通过-ARP-查询目标路由器的-MAC-地址" class="headerlink" title="通过 ARP 查询目标路由器的 MAC 地址"></a>通过 ARP 查询目标路由器的 MAC 地址</h4><ul><li><p>ARP：Address Resolution Protocol 地址解析协议</p></li><li><p>ARP 利用广播对连接在同一以太网中的所有设备查询 MAC 地址</p></li></ul><p><img src="/images/HowNetworksWorks/56.png" alt></p><ul><li>如果每次发送包都要这样查询一次，网络中就会增加很多 ARP包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用</li><li>也就是说，在发送包时，先查询一下 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址，而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询</li></ul><p><img src="/images/HowNetworksWorks/57.png" alt></p><p><img src="/images/HowNetworksWorks/58.png" alt></p><ul><li><p>ARP缓存中的地址会在一定时间后被删除，避免读取到IP地址发生变化后造成的差异</p></li><li><p>将 MAC 头部加在 IP 头部前面，整个包就完成了</p></li><li>到此为止，整个打包工作是由 IP 模块完成的<ul><li>这样的好处是，在把数据包交给网卡之前就打包好</li><li>这样一来，网卡就可以支持各种类型的包，网卡专注于收发</li></ul></li></ul><h4 id="以太网的结构"><a href="#以太网的结构" class="headerlink" title="以太网的结构"></a>以太网的结构</h4><ul><li>IP 模块的工作完成后，就轮到网卡开始工作了</li></ul><p><img src="/images/HowNetworksWorks/59.png" alt></p><ul><li>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术</li><li>收发器：将不同网线之间的信号连接起来</li><li>尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变<ul><li>即将包发送到 MAC 头部的接收方 MAC 地址代表的目的地</li><li>用发送方 MAC地址识别发送方</li><li>用以太类型识别包的内容</li></ul></li><li>因此，可以认为具备这3 个性质的网络就是以太网</li></ul><h4 id="将-IP-包转换成电或光信号发送出去"><a href="#将-IP-包转换成电或光信号发送出去" class="headerlink" title="将 IP 包转换成电或光信号发送出去"></a>将 IP 包转换成电或光信号发送出去</h4><ul><li>IP 生成的网络包只是存放在内存中的一串数字信息</li><li>因此，需要将数字信号转换成电信号或者光信号，才能在网线上传输</li><li>负责执行这个操作的就是网卡，但是网卡也无法单独工作，需要控制网卡就需要网卡驱动程序</li></ul><p><img src="/images/HowNetworksWorks/60.png" alt></p><ul><li>MAC:Media Access Control</li></ul><p><img src="/images/HowNetworksWorks/61.png" alt></p><ul><li>可以从网卡 ROM 中读出 MAC 值 设置给 MAC 模块</li><li>也可以从命令或配置中读取 MAC 值<ul><li>这种情况下，网卡会忽略ROM 中的 MAC 地址</li></ul></li><li>有人认为在网卡通电之后，ROM 中的 MAC 地址就自动生效了，其实不然，真正生效的是网卡驱动进行初始化时在 MAC模块中设置的那个 MAC 地址</li></ul><h4 id="给网络包再加3个控制数据"><a href="#给网络包再加3个控制数据" class="headerlink" title="给网络包再加3个控制数据"></a>给网络包再加3个控制数据</h4><p><img src="/images/HowNetworksWorks/62.png" alt></p><ul><li>网卡驱动从IP模块获取到包之后，将其复制到网卡内的缓冲区中，然后向 MAC 模块发送 “发送包” 的指令</li><li><p>MAC 模块将包从缓冲区中取出，并在开头添加 报头、起始帧分节符，在末尾添加用于检测错误的帧校验序列 （历史原因，帧和包是一个意思）</p></li><li><p>报头是一串像 10101010…这样 1 和 0 交替出现的比特序列，长度为 56比特，它的作用是确定包的读取时机</p></li><li>当这些 1010 的比特序列被转换成电信号后，会形成如下图这样的波形</li><li>接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机</li></ul><p><img src="/images/HowNetworksWorks/63.png" alt></p><ul><li>用电信号来表达数字信息是，需要让0和1两种比特分别对应特定的电压和电流</li></ul><p><img src="/images/HowNetworksWorks/64.png" alt></p><ul><li>在测量电压和电流的时候，必须先判断出每个比特的界限在哪，要不连续同种比特出现的时候就很难切分（连续1111或00000）</li><li>为了解决这个问题，引入一组用来区分比特间隔的时钟信号<ul><li>当时钟信号变化时，读取电压和电流值，和0或1对应</li><li>但是距离较远时，网线较长时，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移</li></ul></li><li>为了解决偏差，采用将数据信号和时钟信号叠加在一起的方法</li></ul><h4 id="向集线器发送网络包"><a href="#向集线器发送网络包" class="headerlink" title="向集线器发送网络包"></a>向集线器发送网络包</h4><ul><li>发送信号的操作分为两种<ul><li>一种是使用集线器的半双工模式</li><li>另一种是使用交换机的全双工模式</li></ul></li><li>在半双工模式中，为了避免信号碰撞，需要先判断网线中是否存在其他信号设备发送信号<ul><li>有则等待，没有即可发送</li></ul></li><li>首先，MAC 模块从报头开始将数字信号按每个比特转成电信号，然后由PHY或叫MAU的信号收发模块发送出去<ul><li>MAU：Medium Attachment Unit 介质连接单元</li><li>PHY：Physical Layer Device 物理层装置</li><li>根据以太网的信号方式的不同，叫法不同，速度在100Mbit/s以上的以太网中都叫PHY</li><li>在这里，将数字信号转换成电信号的速率就是网络传输速率<br><img src="/images/HowNetworksWorks/65.png" alt></li></ul></li><li>接下来，PHY模块会将信号转换为可以在网线上传输的格式，并通过网线发送出去<ul><li>以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定</li><li>但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给 PHY（MAU）模块</li><li>然后 PHY（MAU）模块再将其转换为可在网线上传输的格式</li></ul></li></ul><p><img src="/images/HowNetworksWorks/66.png" alt></p><ul><li>PHY不仅仅只是转换信号，还需要监控接收线路有无信号进来，避免信号碰撞</li><li><p>如果发生了信号碰撞，还会发送一段阻塞信号，通知所有发送操作停止</p><ul><li>并且根据 MAC 地址生成随机数，错开重新发送信号时间</li><li>当网络拥塞的时候，发送碰撞的可能性提高</li><li>多次拥塞等待后，就报告通信错误</li></ul></li><li><p>另一种全双工模式，可以同时接收和发送，不会发生碰撞</p></li></ul><h4 id="接收网络包"><a href="#接收网络包" class="headerlink" title="接收网络包"></a>接收网络包</h4><ul><li>PHY （MAU）模块会将信号转换成通用格式并发送给 MAC 模块</li><li>MAC 模块再从头开始将信号转换为数字信息，并存放到缓冲区中</li><li>当到达信号的末尾时，还需要检查 FCS</li><li>检查 MAC 头部中接收方MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致</li><li><p>无误后，网卡通知计算机收到了一个网络包</p></li><li><p>计算机并不是一直监控着网卡，需要网卡去打断计算机正在执行的任务，注意到自己，这种机制就是中断</p></li></ul><h4 id="将服务器的响应包从-IP-传递给-TCP"><a href="#将服务器的响应包从-IP-传递给-TCP" class="headerlink" title="将服务器的响应包从 IP 传递给 TCP"></a>将服务器的响应包从 IP 传递给 TCP</h4><ul><li>首先收到包，肯定是先检查以太类型，确定是什么协议；0800就是TCP/IP</li><li>接着检查IP头部、查看接受方IP地址<ul><li>如果IP格式无误，接受方IP地址和客户端网卡地址一致，就可以接收这个包了</li></ul></li><li>如果接受方的IP不是自己的，发生了这样的错误时，IP模块会通过ICMP消息将错误告诉发送方</li></ul><p><img src="/images/HowNetworksWorks/67.png" alt></p><h3 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h3><h4 id="不需要重发的数据用-UDP-发送更高效"><a href="#不需要重发的数据用-UDP-发送更高效" class="headerlink" title="不需要重发的数据用 UDP 发送更高效"></a>不需要重发的数据用 UDP 发送更高效</h4><ul><li>TCP 设计得如此完善，就是要确保它的数据可靠性</li><li>如果数据很短，不用分包，一个包就足够的情况下，就不需要考虑漏包等问题了<ul><li>一旦丢失或未送达就重发，就就一个包，根本不影响效率</li><li>这样就不需要 TCP 这么复杂的机制了</li></ul></li><li>发送了数据，对方给出回复就可以</li></ul><h4 id="控制用的短数据"><a href="#控制用的短数据" class="headerlink" title="控制用的短数据"></a>控制用的短数据</h4><ul><li>像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围就可以解决，这种场景就可以用 UDP 来代替 TCP<ul><li>UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立建立和断开连接的步骤</li><li>只需要从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 模块发送就可以了</li></ul></li></ul><p><img src="/images/HowNetworksWorks/68.png" alt></p><ul><li>在线播放音频和视频数据的时候，也会使用 UDP ，因为这些数据必须在规定时间内达到，否则会错过时机，导致卡顿<ul><li>一旦错过时间，重发数据也没有用；</li><li>在这些无需重发，或者重发也没意义的场景，用 UDP 效率更高</li></ul></li></ul><h2 id="从网线到网络设备—集线器、交换机、路由器"><a href="#从网线到网络设备—集线器、交换机、路由器" class="headerlink" title="从网线到网络设备—集线器、交换机、路由器"></a>从网线到网络设备—集线器、交换机、路由器</h2><p><img src="/images/HowNetworksWorks/69.png" alt></p><h3 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h3><ul><li>每个包都是独立传输的<ul><li>每个阶段的都不会关心上个阶段的包内部内容</li><li>每个后面的阶段只会根据上阶段传输过来的包头部中的控制信息，进行操作</li></ul></li></ul><p><img src="/images/HowNetworksWorks/70.png" alt></p><ul><li>电信号会在传输过程中逐渐衰弱<ul><li>电信号频率越高，能量损失率越大，因此传输过程就会失真</li><li>如果再加上噪音，失真就更厉害，进一步影响0，1的判断，这就是产生通信错误的原因<br><img src="/images/HowNetworksWorks/71.png" alt></li></ul></li><li>局域网使用的网线就是双绞线，双绞就是把两根信号线为一组缠绕在一起，这样就是为了抑制噪音<ul><li>产生噪音的原因就是网线周围的电磁波，电磁波接触到导体时会在其中产生电流，干扰原有的电流<br><img src="/images/HowNetworksWorks/72.png" alt></li></ul></li><li><p>影响网线的电磁波分为两种</p><ul><li>一种是电机、荧光灯、CRT显示器等设备泄露出来的电磁波，这类电磁波来自网线外部</li><li>另一种是是从网线相邻的信号线泄露出来的，这类内部产生的噪音称为串扰<br><img src="/images/HowNetworksWorks/73.png" alt></li></ul></li><li><p>除了用“双绞”的方式外，在信号线之间加入隔板距离以及在外面包裹可阻挡电磁波的金属屏蔽网等也可以抑制信号干扰</p></li><li>网线的性能是以“类”来区分的<br><img src="/images/HowNetworksWorks/74.png" alt></li></ul><ul><li>当信号到达集线器后，会被广播到整个网络中<ul><li>以太网的基本架构就是将包发到所有的设备</li><li>然后由设备根据接收方 MAC 地址来判断应该接收哪些包，</li><li>而集线器就是这一架构的忠实体现，它就是负责按照以太网的基本架构将信号广播出去<br><img src="/images/HowNetworksWorks/75.png" alt></li></ul></li></ul><h3 id="交换机的包转发操作"><a href="#交换机的包转发操作" class="headerlink" title="交换机的包转发操作"></a>交换机的包转发操作</h3><h4 id="交换机根据地址表进行转发"><a href="#交换机根据地址表进行转发" class="headerlink" title="交换机根据地址表进行转发"></a>交换机根据地址表进行转发</h4><p><img src="/images/HowNetworksWorks/76.png" alt></p><ul><li>信号到网线接口，由PHY模块接收，转换成数字信号，校验包末尾的FCS，无误则存放到缓冲区</li><li>交换机一个端口可以当作一个网卡，但是交换机端口不具有MAC地址</li><li>存到缓冲区之后，就会查询这个包的接受方地址是否在MAC地址表中<ul><li>该MAC地址表与端口一一对应，就能判断出包该转发到哪个端口</li></ul></li></ul><h4 id="MAC-地址表的维护"><a href="#MAC-地址表的维护" class="headerlink" title="MAC 地址表的维护"></a>MAC 地址表的维护</h4><ul><li>交换机在转发包的过程中，还需要对MAC地址表内容进行维护</li><li>维护分两种<ul><li>一种是记住每个发送方的MAC地址以及输出端口的号码，这样以后每次有一样的情况就可以重复执行</li><li>另一种是删除地址表中的某条记录，防止发送端的设备移动了，地址表信息造成错误，因此地址表也会在一段时间不使用后删除</li><li>重启交换机可立刻清空并更新地址表的记录<ul><li>在地址表错误的情况下又发送包，造成通信错误的情况下可重启交换机<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4></li></ul></li></ul></li></ul><p><img src="/images/HowNetworksWorks/77.png" alt></p><ul><li>交换机查询地址表之后发现记录中的目标端口和这个包的源端口是同一个端口<ul><li>当像上图这样用集线器和交换机连接在一起时就会遇到这样的情况</li><li>首先，计算机 A 发送的包到达集线器后会被集线器转发到所有端口上，也就是会到达交换机和计算机 B</li><li>这时，交换机转发这个包之后，这个包会原路返回集线器</li><li>然后，集线器又把包转发到所有端口，于是这个包又到达了计算机 A 和计算机 B</li><li>所以计算机 B 就会收到两个相同的包，这会导致无法正常通信</li><li>因此，当交换机发现一个包要发回到原端口时，就会直接丢弃这个包</li></ul></li><li>地址表中找不到指定的MAC地址<ul><li>这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了</li><li>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上</li><li>无论该设备连接在哪个端口上都能收到这个包</li><li>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包</li></ul></li></ul><h4 id="全双工模式可以同时进行发送和接收"><a href="#全双工模式可以同时进行发送和接收" class="headerlink" title="全双工模式可以同时进行发送和接收"></a>全双工模式可以同时进行发送和接收</h4><ul><li>全双工模式是交换机特有的工作模式，它可以同时进行发送和接收操作，集线器不具备这样的特性</li><li>使用集线器时，如果多台计算机同时发送信号，信号就会在集线器内部混杂在一起，进而无法使用<ul><li>这种现象称为碰撞，是以太网的一个重要特征</li><li>不过，只要不用集线器，就不会发生碰撞</li></ul></li><li>使用双绞线时，发送和接收的信号线是各自独立的<ul><li>如果不存在碰撞，也就不需要半双工模式中的碰撞处理机制了</li><li>也就是说，发送和接收可以同时进行</li><li>然而，以太网规范中规定了在网络中有信号时要等该信号结束后再发送信号，因此发送和接收还是无法同时进行</li><li>于是，人们对以太网规范进行了修订，增加了一个无论网络中有没有信号都可以发送信号的工作模式，同时规定在这一工作模式下停用碰撞检测，这种工作模式就是全双工模式</li><li>在全双工模式下，无需等待其他信号结束就可以发送信号，因此它比半双工模式速度要快</li><li>由于双方可以同时发送数据，所以可同时传输的数据量也更大，性能也就更高</li></ul></li></ul><h4 id="自动协商：确定最优传输速率"><a href="#自动协商：确定最优传输速率" class="headerlink" title="自动协商：确定最优传输速率"></a>自动协商：确定最优传输速率</h4><ul><li>随着全双工模式的出现，如何在全双工和半双工模式之间进行切换的问题也产生了</li></ul><p><img src="/images/HowNetworksWorks/78.png" alt></p><ul><li>在全双工模式出现的时候，需要手动切换模式</li><li>后来出现了自动切换模式的模式，可以由相互连接双方检测对方是否支持全双工模式，并自动切换成对应的工作模式<ul><li>此外，还能探测对方的传输速率进行自动切换，这种自动切换称为自动协商</li></ul></li><li><p>在以太网中，当没有数据在传输时，就会填充一种叫做连接脉冲的脉冲信号</p><ul><li>使得网络中一致保持一定的信号流过，从而能够检测对方是否在正常工作，或者说网线有没有正常连接</li><li>以太网设备的网线接口周围有个绿色指示灯，表示是否检测到正常的脉冲信号<ul><li>灯亮，说明PHY模块以及网线正常<br><img src="/images/HowNetworksWorks/79.png" alt></li></ul></li></ul></li><li><p>后来，人们又设计出了上图具有特定排列的脉冲信号，通过这种信号可以将自身的状态告知对方</p><ul><li>自动协商就利用了这样的脉冲信号，将自己能够支持的工作模式和传输速率相互告知对方，并从中选择一个最优的组合</li></ul></li></ul><p><img src="/images/HowNetworksWorks/80.png" alt></p><ul><li>假设现在连接双方的情况如上表所示<ul><li>网卡一方支持所有的速率和工作模式，而交换机只支持到 100 Mbit/s 全双工模式</li><li>当两台设备通电并完成硬件初始化之后，就会开始用脉冲信号发送自己支持的速率和工作模式</li><li>当对方收到信号之后，会通过读取脉冲信号的排列来判断对方支持的模式，然后看看双方都支持的模式有哪些</li><li>表是按照优先级排序的，因此双方都支持的模式就是第 3 行及以下的部分</li><li>越往上优先级越高，因此在本例中 100 Mbit/s 全双工模式就是最优组合</li><li>于是双方就会以这个模式开始工作</li></ul></li></ul><h4 id="交换机可以同时执行多个转发操作"><a href="#交换机可以同时执行多个转发操作" class="headerlink" title="交换机可以同时执行多个转发操作"></a>交换机可以同时执行多个转发操作</h4><p><img src="/images/HowNetworksWorks/76.png" alt></p><ul><li>交换机只将包转发到具有特定 MAC 地址的设备连接的端口，其他端口都是空闲的<ul><li>如图，当包从最上面的端口发送到最下面的端口时，其他端口都处于空闲状态，这些端口可以传输其他的包，</li><li>因此交换机可以同时转发多个包</li></ul></li><li>相对地，集线器会将输入的信号广播到所有的端口<ul><li>如果同时输入多个信号就会发生碰撞，无法同时传输多路信号</li><li>因此从设备整体的转发能力来看，交换机要高于集线器</li></ul></li></ul><h3 id="路由器的包转发操作"><a href="#路由器的包转发操作" class="headerlink" title="路由器的包转发操作"></a>路由器的包转发操作</h3><h4 id="路由器的基本结构"><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h4><ul><li>路由器也是通过查表判断包转发的目标的，工作原理和交换机类似</li><li>不过路由器是基于IP设计的，交换机是基于以太网设计的</li></ul><p><img src="/images/HowNetworksWorks/81.png" alt></p><ul><li><p>转发模块负责判断包的转发目的地，端口模块负责包的收发操作</p><ul><li>换句话说，路由器转发模块和端口模块的关系，就相当于协议栈的 IP 模块和网卡之间的关系</li><li>因此，可以将路由器的转发模块想象成 IP 模块，将端口模块想象成网卡</li><li>通过更换网卡，计算机不仅可以支持以太网，也可以支持无线局域网，路由器也是一样</li><li>如果路由器的端口模块安装了支持无线局域网的硬件，就可以支持无线局域网了</li><li>此外，计算机的网卡除了以太网和无线局域网之外很少见到支持其他通信技术的品种</li><li>而路由器的端口模块则支持除局域网之外的多种通信技术，如ADSL、FTTH，以及各种宽带专线等，只要端口模块安装了支持这些技术的硬件即可</li></ul></li><li><p>端口模块是以实际的发送方或接受方的身份来执行包收发操作的</p><ul><li>意味着路由器的各个端口都具有MAC地址和IP地址</li><li>而交换机只是将进来的包转发出去而已，它自己并不会称为发送方或者接受方</li></ul></li></ul><h4 id="路由表中的信息"><a href="#路由表中的信息" class="headerlink" title="路由表中的信息"></a>路由表中的信息</h4><ul><li>交换机是通过MAC头部中的接受方MAC地址来判断转发目标的，而路由器是根据IP头部中的IP地址来判断的</li></ul><p><img src="/images/HowNetworksWorks/82.png" alt></p><ul><li>路由器会忽略主机号，只匹配网络号</li></ul><p><img src="/images/HowNetworksWorks/83.png" alt></p><h4 id="路由器的包收发操作"><a href="#路由器的包收发操作" class="headerlink" title="路由器的包收发操作"></a>路由器的包收发操作</h4><ul><li>首先，信号到达网线接口部分，其中的 PHY（MAU）模块和 MAC 模块将信号转换为数字信息</li><li>然后通过包末尾的 FCS 进行错误校验，</li><li>如果没问题则检查 MAC 头部中的接收方 MAC 地址，</li><li>看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包</li><li>如果包的接收方 MAC地址不是自己，说明这个包是发给其他设备的，如果接收这个包就违反了以太网的规则</li></ul><p><img src="/images/HowNetworksWorks/84.png" alt></p><h4 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h4><ul><li>路由器接收到包之后，就会丢弃包开头的MAC头部<ul><li>因为这个包的MAC头部就是为了将包送达路由器，之后就没作用了，自然被丢弃<br><img src="/images/HowNetworksWorks/85.png" alt></li></ul></li><li>然后就根据MAC头部后方的IP头部中的内容判断转发操作</li><li>查询路由表判断转发目标，根据包的接受方IP查询路由表中的目标栏，找到相匹配的记录</li><li>如果路由表中无法找到匹配的记录，则会丢弃这个包，通过ICMP消息告知发送方<ul><li>这里和交换机不一样，交换机连接的的网络最多也就几千台设备的规模，交换机找不到匹配的记录的时候，会发送到所有端口</li><li>但是路由器的工作设备都在互联网上，规模还在持续扩大，因此为了不造成网络拥塞，只能将匹配不到对应记录的包丢弃</li></ul></li></ul><h4 id="找不到匹配路由时选择默认路由"><a href="#找不到匹配路由时选择默认路由" class="headerlink" title="找不到匹配路由时选择默认路由"></a>找不到匹配路由时选择默认路由</h4><ul><li><p>互联网中那么多转发目标，不可能都配置在路由器中</p><ul><li>关键就在于把子网掩码设置为 0.0.0.0 <ul><li>这样无论任何地址都能匹配到这条记录，就不会发生匹配不到的记录了</li></ul></li><li>这个配置的网关地址被称为默认网关，和在计算机里面设置TCP.IP填的默认网关一样<br><img src="/images/HowNetworksWorks/86.png" alt></li></ul></li><li><p>这样一来就可以层层追溯查找出转发目标</p></li></ul><h4 id="包的有效期"><a href="#包的有效期" class="headerlink" title="包的有效期"></a>包的有效期</h4><ul><li>找到转发目标后，还会更新IP头部中的TTL(Time to live)</li><li>TTL表示了包的有效期，包每经过一个路由器的时候，这个值就会减1，当这个值为0的时候，就会被丢弃</li><li>这个机制是为了包在一个地方进入死循环<ul><li>发生死循环的情况在于路由表配置信息有误，或者网络故障</li></ul></li><li>发送方在发送包时会将 TTL 设为 64 或 128，也就是说包经过这么多路由器后就会“寿终正寝”</li><li>现在的互联网即便访问一台位于地球另一侧的服务器，最多也只需要经过几十个路由器，因此只要包被正确转发，就可以在过期之前到达目的地</li></ul><h4 id="通过分片功能拆分大网络包"><a href="#通过分片功能拆分大网络包" class="headerlink" title="通过分片功能拆分大网络包"></a>通过分片功能拆分大网络包</h4><ul><li>路由器的端口并不只有以太网一种，也可以支持其他局域网或专线通信技术</li><li><p>由于不同线路的输出输入端口的最大包长度不同，所以为了避免数据包受影响，而采用IP协议中的分片功能对包进行拆分</p><ul><li>这里和TCP拆分的机制不同<ul><li>TCP是将拆好的数据块正好装进一个包里</li><li>从IP角度来看，这个包还是一个未拆分的整体</li></ul></li><li>IP分辨是对一个完整的包再拆分的过程<br><img src="/images/HowNetworksWorks/87.png" alt></li></ul></li><li><p>MTU：包能传输的最大数据长度</p></li><li>首先查看IP头部的标志字段，确认是否可以分片（一般都是可以的，除非发送方设置了不允许，或者这个包已经被分片过了）</li><li><p>如果不能分片，只能丢弃，并通过ICMP消息通知发送方</p></li><li><p>在分片中，TCP以及后面的数据都是可以分片的，从IP角度来看，TCP的请求数据也是网络包数据的一部分</p></li><li>然后就会在每个分片加上IP头部，MAC头部</li></ul><h4 id="路由器的发送操作和计算机相同"><a href="#路由器的发送操作和计算机相同" class="headerlink" title="路由器的发送操作和计算机相同"></a>路由器的发送操作和计算机相同</h4><ul><li>准备工作完成就会进入包的发送操作<ul><li>将包转换成什么信号，取决于输出端口的类型，以太网则是电信号<br><img src="/images/HowNetworksWorks/88.png" alt></li></ul></li></ul><h4 id="路由器和交换机的关系"><a href="#路由器和交换机的关系" class="headerlink" title="路由器和交换机的关系"></a>路由器和交换机的关系</h4><p><img src="/images/HowNetworksWorks/89.png" alt></p><ul><li>路由器在转发网络包的时候，都要在包的头部加上MAC头部<ul><li>准确说，应该是将IP网络包装进以太网包的数据部分</li><li>委托以太网去传输这些数据</li></ul></li><li>IP协议本身没有传输包的功能，包的实际传输要委托以太网来执行</li><li>路由器是基于IP设计的，交换机是基于以太网设计的<ul><li>IP与以太网的关系，也就是路由器与交换机的关系</li></ul></li><li>当然上面的基本理论只适用于“纯粹”的路由器和交换机</li><li><p>目前的路由器都内置有交换机功能了，但是底层本质还是不变</p></li><li><p>从包的转发目标也可以看出路由器和交换机之间的委托关系。IP 并不是委托以太网将包传输到最终目的地，而是传输到下一个路由器。在创建MAC 头部时，也是从 IP 的路由表中查找出下一个路由器的 IP 地址，并通过 ARP 查询出 MAC 地址，然后将 MAC 地址写入 MAC 头部中的，这表示 IP 对以太网的委托只是将包传输到下一个路由器就行了。当包到达下一个路由器后，下一个路由器又会重新委托以太网将包传输到再下一个路由器。随着这一过程反复执行，包就会最终到达 IP 的目的地，也就是通信的对象</p></li></ul><p><img src="/images/HowNetworksWorks/90.png" alt></p><h3 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h3><ul><li>地址转换、包过滤</li><li>最初的互联网没有内外网区分，所有客户端都是直接连接到互联网的，并每台设备都能够分配到属于自己的IP地址</li><li>后来设备越来越多，为了解决这个问题才有了内外网的概念</li></ul><p><img src="/images/HowNetworksWorks/91.png" alt></p><ul><li>内网地址-私有地址；外网地址-公有地址</li><li>内网可用的私有地址<ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul></li><li>为什么上面这些地址用作私有地址，其实在制定私有地址的时候，上面那些地址属于公有地址中还没被分配的范围而已</li><li>这样就解决了内外网分配不足的问题，但是两个内网想要通过互联网通信并且私有地址又相同怎么办<ul><li>这样的情况就需要用到了路由器的地址转换功能</li></ul></li></ul><h4 id="地址转换的原理"><a href="#地址转换的原理" class="headerlink" title="地址转换的原理"></a>地址转换的原理</h4><ul><li>地址转换的基本原理是在转发网络包时对IP头部中的IP地址和端口号进行改写</li><li>具备地址转换功能的设备不仅有路由器，有些防火墙也有地址转换功能</li></ul><p><img src="/images/HowNetworksWorks/92.png" alt></p><h4 id="改写端口号的原因"><a href="#改写端口号的原因" class="headerlink" title="改写端口号的原因"></a>改写端口号的原因</h4><ul><li>现在的地址转换机制是同时改写地址和端口号，但是早期的地址转换只是改写地址<ul><li>但是这种方法的前提是私有地址和公有地址一一对应</li><li>需求数量多起来共有地址就不够用了，因此也要改写端口号</li><li>端口号是一个16bit的数值，可用分配出几万个端口，就完全够用了</li></ul></li></ul><h4 id="从互联网访问公司内网"><a href="#从互联网访问公司内网" class="headerlink" title="从互联网访问公司内网"></a>从互联网访问公司内网</h4><ul><li>没有在访问互联网的内网设备，是无法从互联网想起发起网络包的</li><li>因为从内网去访问外网的时候，用来改写的公有地址就是地址转换设备自身的地址，端口号随便选个空闲的就行</li><li>从外网去访问内网的话，因为在地址表中没有记录，意味着地址转换设备无法判断公网地址和内网地址的对应关系<br><img src="/images/HowNetworksWorks/93.png" alt></li><li>但是如果想要从外网去访问内网的话，需要手动添加对应的关系记录</li></ul><h4 id="路由器的包过滤功能"><a href="#路由器的包过滤功能" class="headerlink" title="路由器的包过滤功能"></a>路由器的包过滤功能</h4><ul><li>包过滤就是在对包进行转发时，根据MAC头部、IP头部、TCP头部的内容，按照事先设置好的规则决定是转发这个包，还是丢弃这个包<ul><li>防火墙等软件，大多数就利用这个机制来防止非法入侵的</li></ul></li></ul><h2 id="通过接入网进入互联网内部—接入网、网络运营商"><a href="#通过接入网进入互联网内部—接入网、网络运营商" class="headerlink" title="通过接入网进入互联网内部—接入网、网络运营商"></a>通过接入网进入互联网内部—接入网、网络运营商</h2><h3 id="ADSL-接入网的结构和工作方式"><a href="#ADSL-接入网的结构和工作方式" class="headerlink" title="ADSL 接入网的结构和工作方式"></a>ADSL 接入网的结构和工作方式</h3><h3 id="光纤接入网（FTTH）"><a href="#光纤接入网（FTTH）" class="headerlink" title="光纤接入网（FTTH）"></a>光纤接入网（FTTH）</h3><h3 id="接入网中使用-PPP-和隧道"><a href="#接入网中使用-PPP-和隧道" class="headerlink" title="接入网中使用 PPP 和隧道"></a>接入网中使用 PPP 和隧道</h3><h3 id="网络运营商的内部"><a href="#网络运营商的内部" class="headerlink" title="网络运营商的内部"></a>网络运营商的内部</h3><h3 id="跨越网络运营商的网络包"><a href="#跨越网络运营商的网络包" class="headerlink" title="跨越网络运营商的网络包"></a>跨越网络运营商的网络包</h3><h2 id="服务器端的局域网中有什么玄机"><a href="#服务器端的局域网中有什么玄机" class="headerlink" title="服务器端的局域网中有什么玄机"></a>服务器端的局域网中有什么玄机</h2><h2 id="请求到达-Web-服务器，响应返回浏览器—短短几秒的“漫长旅途”迎来终点"><a href="#请求到达-Web-服务器，响应返回浏览器—短短几秒的“漫长旅途”迎来终点" class="headerlink" title="请求到达 Web 服务器，响应返回浏览器—短短几秒的“漫长旅途”迎来终点"></a>请求到达 Web 服务器，响应返回浏览器—短短几秒的“漫长旅途”迎来终点</h2><h2 id="网络包的路途"><a href="#网络包的路途" class="headerlink" title="网络包的路途"></a>网络包的路途</h2><p><img src="/images/HowNetworksWorks/last.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器生成消息—浏览器内部&quot;&gt;&lt;a href=&quot;#浏览器生成消息—浏览器内部&quot; class=&quot;headerlink&quot; title=&quot;浏览器生成消息—浏览器内部&quot;&gt;&lt;/a&gt;浏览器生成消息—浏览器内部&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/HowNetworksWorks/1.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成-HTTP-请求消息&quot;&gt;&lt;a href=&quot;#生成-HTTP-请求消息&quot; class=&quot;headerlink&quot; title=&quot;生成 HTTP 请求消息&quot;&gt;&lt;/a&gt;生成 HTTP 请求消息&lt;/h3&gt;&lt;h4 id=&quot;解析-URL&quot;&gt;&lt;a href=&quot;#解析-URL&quot; class=&quot;headerlink&quot; title=&quot;解析 URL&quot;&gt;&lt;/a&gt;解析 URL&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;URL:Uniform Resource Locator&lt;/li&gt;
&lt;li&gt;FTP:File Transfer Protocol&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/HowNetworksWorks/2.png&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议：通信操作的规则&lt;/li&gt;
&lt;li&gt;URL 开头部分，表示浏览器应当使用的方法；比如：http,ftp,file,mailto&lt;/li&gt;
&lt;li&gt;Web浏览器解析 URL 过程&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/images/HowNetworksWorks/3.png&quot; alt&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;/images/HowNetworksWorks/4.png&quot; alt&gt;
    
    </summary>
    
    
    
      <category term="Network" scheme="http://www.orekiyuta.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Crash Course / After reading</title>
    <link href="http://www.orekiyuta.cn/archives/MySQLCrashCourse/"/>
    <id>http://www.orekiyuta.cn/archives/MySQLCrashCourse/</id>
    <published>2020-06-11T16:45:25.000Z</published>
    <updated>2020-06-23T14:33:15.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a><center>Remarks<center></center></center></h2><ol><li>columnName = cN</li><li>tableName = tN</li></ol><h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a><center>检索数据</center></h2><h3 id="use-show"><a href="#use-show" class="headerlink" title="use / show"></a>use / show</h3><ul><li><code>use databaseName;</code></li><li><code>show databases;</code></li><li><code>show tables;</code></li><li><code>show columns from tN;</code></li></ul><h3 id="select-distinct"><a href="#select-distinct" class="headerlink" title="select / distinct"></a>select / distinct</h3><ul><li><code>select cN,cN2 from tN;</code></li><li><code>select * from tN;</code></li><li><code>select distinct cN from tN;</code></li></ul><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><ul><li><code>select cN from tN limit 3;</code>    返回3行</li><li><code>select cN from tN limit 3,4;</code>返回第3行后面的4行（第一个数为开始的位置，第二个为要检索的行数）</li><li><code>limit 3,4</code> 等同于 <code>limit 4 offset 3</code> 都是从第3行后面开始取4行</li></ul><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><ul><li><code>select tNX.cN from databaseName.tNX;</code>   完全限定列名、表名</li><li><code>select cN from tN order by cN;</code>    按照指定列名排序</li><li><code>select cN1,cN2,cN3 from tN order by cN2,cN3;</code>   按指定多个列名的顺序排序（只有在指定的前面的列值相同情况下，再对后面的列值排序）<a id="more"></a></li></ul><h3 id="desc-asc"><a href="#desc-asc" class="headerlink" title="desc / asc"></a>desc / asc</h3><ul><li><code>select cN1,cN2 from tN order by cN2 desc;</code> 降序排列，默认情况是升序 asc</li><li><code>select cN1,cN2 from tN order by cN1 desc ,cN2;</code>   desc只对它前面的列名生效（先按照 cN1 降序，再按照 cN2 默认的升序）</li><li><code>select cN1,cN2 from tN order by cN2 desc limit 1;</code></li></ul><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a><center>过滤数据</center></h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><ul><li><code>select cN1,cN2 from tN where cN1 = 2;</code></li><li><code>select cN1,cN2 from tN where cN2 = &#39;value&#39;;</code></li></ul><p><img src="/images/MySQLCrashCourse/01.png" alt> </p><h3 id="between-is-null"><a href="#between-is-null" class="headerlink" title="between / is null"></a>between / is null</h3><ul><li><code>select cN1,cN2 from tN where cN1 between 3 and 10;</code></li><li><code>select cN1,cN2 from tN where cN2 is null;</code>    返回 cN2 为 空值 的行</li></ul><h3 id="and-or-运算符"><a href="#and-or-运算符" class="headerlink" title="and / or / ( ) / 运算符"></a>and / or / ( ) / 运算符</h3><ul><li><code>select cN1,cN2,cN3 from tN where cN1 = 2 and cN3 &lt;= 19;</code></li><li><code>select cN1,cN2,cN3 from tN where cN1 = 2 or cN3 &lt;= 19;</code></li><li><code>select cN1,cN2,cN3 from tN where cN1 = 2 or cN2 = &#39;value&#39; and cN3 &lt;= 19;</code> and的优先级高于or</li><li>这句就理解为 cN2 等于 value 且 cN3 小于（含）19 或者 cN1 = 2   </li><li><u>cN1 = 2 </u>   or  <u>cN2 = ‘value’ and cN3 &lt;= 19</u> </li><li><code>select cN1,cN2,cN3 from tN where (cN1 = 2 or cN2 = &#39;value&#39;) and cN3 &lt;= 19;</code>   用括号提高优先级</li></ul><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><ul><li><code>select cN1,cN2 from tN where cN2 in (&#39;value&#39;,&#39;value2&#39;);</code></li><li><code>select cN1,cN2 from tN where cN1 in (2,4,5);</code></li><li><code>in (4,5)</code>等同于<code>cN1 = 4 or cN1 =5</code></li><li>优点：in 更直观方便，执行快，还可以包括 where 子句</li></ul><h3 id="not"><a href="#not" class="headerlink" title="not"></a>not</h3><ul><li><code>select cN1,cN2 from tN where cN1 not in (2,4,5);</code>     否定后面的条件</li></ul><h3 id="like-通配符"><a href="#like-通配符" class="headerlink" title="like / 通配符"></a>like / 通配符</h3><ul><li><code>select cN1,cN2 from tN where cN2 like &#39;val%&#39;;</code>    % 表示任何字符出现任意次数</li><li><code>select cN1,cN2 from tN where cN2 like &#39;%al%&#39;;</code>    % 无法匹配到 null</li><li><code>select cN1,cN2 from tN where cN2 like &#39;v%e&#39;;</code> </li><li><code>select cN1,cN2 from tN where cN2 like &#39;valu_&#39;;</code>  _ 只匹配一个字符</li><li>通配符处理更花时间，尽量用其他操作符，尽量不要把通配符用在搜索模式的开始处，影响效率</li></ul><h3 id="正则表达式-regexp"><a href="#正则表达式-regexp" class="headerlink" title="正则表达式 regexp"></a>正则表达式 regexp</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;value&#39;;</code>  regexp 后面跟的内容作为正则表达式</li><li><code>select cN1,cN2 from tN where cN1 regexp &#39;1&#39;;</code></li></ul><h3 id="like-和-regexp-的区别"><a href="#like-和-regexp-的区别" class="headerlink" title="like 和 regexp 的区别"></a>like 和 regexp 的区别</h3><ul><li><code>like &#39;value&#39;</code> 和 <code>regexp &#39;value&#39;</code> 返回内容一样</li><li><code>like &#39;alue&#39;</code> 和 <code>regexp &#39;alue&#39;</code>  like 没有返回内容， regexp 返回含有 value 值的行</li><li>like 匹配整个列，regexp 还对列值内进行匹配</li><li>这里没有列值为 alue 的行，所以 like 没有返回内容，而 regexp 对列值内匹配，所以有返回内容</li></ul><h3 id><a href="#" class="headerlink" title="|"></a>|</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;value1|value2&#39;;</code></li><li><code>select cN1,cN2 from tN where cN2 regexp &#39;value1|2&#39;;</code>  匹配含有 value1 或者 2 的值</li><li><code>select cN1,cN2 from tN where cN1 regexp &#39;1|2|3|4&#39;;</code></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title="[ ] / [^ ]"></a>[ ] / [^ ]</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;value[123]&#39;;</code>    匹配特定字符，返回 value1,value2,value3</li><li>[]其实是另一种形式的 or ; [123]是[1|2|3]的缩写</li><li><code>select cN1,cN2 from tN where cN2 regexp &#39;value[^123]&#39;;</code>   否定[123],匹配这些字符以外的任意字符</li></ul><h3 id="0-9-a-z"><a href="#0-9-a-z" class="headerlink" title="[0-9] / [a-z]"></a>[0-9] / [a-z]</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;value[1-3]&#39;;</code> </li><li><code>value[1-3]</code>等同于<code>value[123]</code>    [a-z]还可以匹配人以字母</li></ul><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符 \"></a>转义字符 \</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;.&#39;;</code> . 匹配任意字符</li><li><code>select cN1,cN2 from tN where cN2 regexp &#39;\\.&#39;;</code> 匹配 .</li><li><code>select cN1,cN2 from tN where cN2 regexp &#39;\\-&#39;;</code> 匹配 -</li><li>\\双反斜杠转义 ，用于匹配特殊字符</li></ul><p><img src="/images/MySQLCrashCourse/02.png" alt> </p><ul><li>多数正则表达式实现使用单个反斜杠转义特殊字符；但是MySQL使用两个反斜杠，MySQL自己解释一个，正则表达式库解释另外一个</li></ul><h3 id="预定义字符集"><a href="#预定义字符集" class="headerlink" title="预定义字符集"></a>预定义字符集</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;[:alnum:]&#39;;</code> 使用预定义字符集</li></ul><p><img src="/images/MySQLCrashCourse/03.png" alt> </p><h3 id="重复元字符"><a href="#重复元字符" class="headerlink" title="重复元字符"></a>重复元字符</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;valu?&#39;;</code> 匹配多个实例，匹配具体的字符次数</li></ul><p><img src="/images/MySQLCrashCourse/04.png" alt> </p><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><ul><li><code>select cN1,cN2 from tN where cN2 regexp &#39;^[v123]&#39;;</code>   匹配特定位置的字符</li></ul><p><img src="/images/MySQLCrashCourse/05.png" alt> </p><ul><li>^ 在集合中 [] 表否定该集合，否则表示串的起点</li><li>正如前面所说 like 匹配整个串，regexp 匹配子串</li><li>利用 ^ 和 $ 就可使 regexp 起到 like 的作用</li><li><code>select cN1,cN2 from tN where cN2 rehexp &#39;^value$&#39;;</code>  等同于 <code>select cN1,cN2 from tN where cN2 like &#39;value&#39;;</code> </li></ul><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a><center>计算字段</center></h2><ul><li>直接从数据库中检索出转换、计算或格式化过的数据</li><li>计算字段是运行时在 select 语句内创建的</li></ul><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><ul><li>把值联结到一起构成单个值</li><li><code>select Concat(cN1,cN2) from tN;</code> 返回结果为 cN1 和 cN2 的值构成的一个新值 </li><li><code>select Concat(cN1,RTrim(cN2)) from tN;</code>  RTrim()去掉值右边的所有空格</li><li><code>select Concat(cN1,LTrim(cN2)) from tN;</code>  RTrim()去掉值左边的所有空格</li><li><code>select Concat(cN1,Trim(cN2)) from tN;</code>  RTrim()去掉值左右两边的所有空格</li><li><code>select Concat(cN1,cN2) as NewcN from tN;</code> 形成的新值没有名称，需要赋予它一个字段名</li></ul><h3 id="算数计算"><a href="#算数计算" class="headerlink" title="算数计算"></a>算数计算</h3><ul><li><code>select cN1,cN2,cN3,cN1+cN3 as SumcN from tN;;</code> 同样可以用括号来提高优先级</li></ul><p><img src="/images/MySQLCrashCourse/06.png" alt> </p><h2 id="函数处理"><a href="#函数处理" class="headerlink" title="函数处理"></a><center>函数处理</center></h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li><code>select cN1,Upper(cN2) from tN;</code> 大写转换</li></ul><p><img src="/images/MySQLCrashCourse/07.png" alt> </p><p><img src="/images/MySQLCrashCourse/08.png" alt> </p><p><img src="/images/MySQLCrashCourse/09.png" alt> </p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p><img src="/images/MySQLCrashCourse/10.png" alt> </p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p><img src="/images/MySQLCrashCourse/11.png" alt> </p><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><ul><li><code>select cN1,AVG(cN2) from tN;</code> 平均值，AVG()函数忽略列值为 null 的行，同理 count(),max(),min(),sum()也是忽略 null 的行</li></ul><p><img src="/images/MySQLCrashCourse/12.png" alt> </p><ul><li><code>select count(*) from tN;</code>  行数目计数，无论是否 null 都会计数</li><li><code>select count(cN2) from tN;</code> 列值为 null 的行会被忽略 </li><li><code>select cN1,AVG(distinct cN2) from tN;</code> 忽略相同的列值</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> NewcN1,</span><br><span class="line">      <span class="keyword">min</span>(cN3) <span class="keyword">as</span> NewcN2,</span><br><span class="line">      <span class="keyword">max</span>(cN3) <span class="keyword">as</span> NewcN3,</span><br><span class="line">      <span class="keyword">avg</span>(cN3) <span class="keyword">as</span> NewcN4,</span><br><span class="line"><span class="keyword">from</span> tN;</span><br></pre></td></tr></table></figure></li></ul><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a><center>分组</center></h2><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,<span class="keyword">count</span>(*) <span class="keyword">as</span> NewcN </span><br><span class="line"><span class="keyword">from</span> tN </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cN1;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/MySQLCrashCourse/13.png" alt> </p><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><ul><li>where 过滤指定行并且没有分组的概念</li><li>where 过滤行，having 过滤分组</li><li>having 支持所有 where 操作符</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,<span class="keyword">count</span>(*) <span class="keyword">as</span> NewcN </span><br><span class="line"><span class="keyword">from</span> tN </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cN1</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>也可以理解为 where 在 group by 前过滤，having 在 group by 后过滤</p></li></ul><h3 id="group-by-与-order-by"><a href="#group-by-与-order-by" class="headerlink" title="group by 与 order by"></a>group by 与 order by</h3><p><img src="/images/MySQLCrashCourse/14.png" alt> </p><ul><li>group by 以分组的顺序输出，但是有时候需要以不同于分组默认的顺序输出</li><li>这种情况就需要提供 order by 子句 ，以明确输出的顺序方式</li></ul><h3 id="select-子句顺序"><a href="#select-子句顺序" class="headerlink" title="select 子句顺序"></a>select 子句顺序</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">limit</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/MySQLCrashCourse/15.png" alt> </p><p><img src="/images/MySQLCrashCourse/16.png" alt> </p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><center>子查询</center></h2><ul><li>子查询总是从内向外处理</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,cN2</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> cN5 <span class="keyword">in</span> (<span class="keyword">select</span> cN5</span><br><span class="line">              <span class="keyword">from</span> tN2</span><br><span class="line">              <span class="keyword">where</span> cN7 <span class="keyword">in</span> (<span class="keyword">select</span> cN7</span><br><span class="line">                            <span class="keyword">from</span> tN3</span><br><span class="line">                            <span class="keyword">where</span> cN9 = <span class="string">'v'</span></span><br><span class="line">                            )</span><br><span class="line">              );</span><br></pre></td></tr></table></figure></li><li><p>作为计算字段使用子查询</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,</span><br><span class="line">       cN2,</span><br><span class="line">       (<span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">        <span class="keyword">from</span> tN2</span><br><span class="line">        <span class="keyword">where</span> tN2.cN1 = tN.cN1) <span class="keyword">as</span> NewcN</span><br><span class="line"><span class="keyword">from</span> tN;</span><br></pre></td></tr></table></figure></li></ul><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a><center>联结表</center></h2><ul><li>关系表：各表通过某些常用值互相关联；在A表中建立了B表中某些字段的列，把两个表联系起来</li><li>外键：某个表中的一列，它包含另外一个表的主键值，定义了两个表之间的关系</li></ul><h3 id="内部联结-inner-join"><a href="#内部联结-inner-join" class="headerlink" title="内部联结 inner join"></a>内部联结 inner join</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1,tN2</span><br><span class="line"><span class="keyword">where</span> tN1.cN1 = tN2.cN1</span><br></pre></td></tr></table></figure></li><li><p>以上的联结称为 等值联结，基于两个表之间的相等测试，也成为 内部联结</p></li><li>可以用以下更为标准的联结语法</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1 <span class="keyword">inner</span> <span class="keyword">join</span> tN2</span><br><span class="line"><span class="keyword">on</span> tN1.cN1 = tN2.cN1</span><br></pre></td></tr></table></figure></li><li><p>联结表的数目没有限制，但是这种处理非常消耗资源，联结的表越多，性能下降越厉害</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3,cN4</span><br><span class="line"><span class="keyword">from</span> tN1,tN2,tN3,tN4</span><br><span class="line"><span class="keyword">where</span> tN1.cN1 = tN2.cN1</span><br><span class="line">  <span class="keyword">and</span> tN3.cN1 = tN1.cN1</span><br><span class="line">  <span class="keyword">and</span> tN4.cN1 = tN1.cN1</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1 <span class="keyword">as</span> a,tN2 <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">where</span> a.cN1 = b.cN1</span><br></pre></td></tr></table></figure></li></ul><h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1</span><br><span class="line"><span class="keyword">where</span> cN1 = (<span class="keyword">select</span> cN1</span><br><span class="line">             <span class="keyword">from</span> tN1</span><br><span class="line">             <span class="keyword">where</span> cN2=<span class="string">'x'</span></span><br><span class="line">             );</span><br></pre></td></tr></table></figure></li><li><p>从同一个表从查询内容，上面用了子查询，分了两步进行操作</p></li><li>下面用联结的方式进行相同查询</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1 <span class="keyword">as</span> a , tN1 <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">where</span> a.cN1 = b.cN1</span><br><span class="line">  <span class="keyword">and</span> b.cN2 = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure></li><li><p>因为对一个表自己进行联结，相当于每个字段出现了两次，所以要用别名把表的字段给区分开</p></li></ul><h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><ul><li>无论何时对表进行联结，都会出现至少一个列出现在不止一个表中。</li><li>自然联结可以排除多次出现，使每个列只返回一次</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.cN2,b.cN3</span><br><span class="line"><span class="keyword">from</span> tN1 <span class="keyword">as</span> a , tN2 <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">where</span> a.cN1 = b.cN1;</span><br></pre></td></tr></table></figure></li><li><p>对表 a 使用通配符全部检索列，对表 b 明确指出列</p></li></ul><h3 id="外部联结-left-right-outer-join"><a href="#外部联结-left-right-outer-join" class="headerlink" title="外部联结 left/right outer join"></a>外部联结 left/right outer join</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1 <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> tN2</span><br><span class="line"><span class="keyword">where</span> tN1.cN1 = tN2.cN1;</span><br></pre></td></tr></table></figure></li><li><p>内部联结是把满足条件的两个表的所有行组合起来，</p></li><li>外部联结主要区别在于（1）把满足条件的两个表的所有行组合起来（2）还要把未满足条件的 左/右 表的行也要附加组合进去</li><li><code>tN1 left outer join tN2;</code> 左外部联结</li><li><code>tN1 right outer join tN2;</code>    右外部联结</li><li><p>左/右 外部联结可以通过颠倒 from 中的表顺序转换，两种类型联结用哪种完全看方便而定</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN2,</span><br><span class="line">       cN3</span><br><span class="line"><span class="keyword">from</span> tN1 <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> tN2</span><br><span class="line"><span class="keyword">where</span> tN1.cN1 = tN2.cN1;</span><br></pre></td></tr></table></figure></li></ul><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a><center>组合查询</center></h2><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN2;</span><br></pre></td></tr></table></figure></li><li><p>union 组合的 select 语句出现的字段必须一致，顺序无所谓</p></li><li>union 组合查询出来的结果为各个查询语句按先后查询的顺序组合</li><li>union 的查询结果会自动去重，保留先查询出的行，去除后面查询出的重复的行</li></ul><h3 id="union-all"><a href="#union-all" class="headerlink" title="union all"></a>union all</h3><ul><li>如果想全部保留查询组合结果可使用 union all</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN2;</span><br></pre></td></tr></table></figure></li><li><p>union 几乎总是完成与多个 where 条件相同的工作</p></li><li>union all 可以完成匹配全部（包括重复行），而 where 就不行</li></ul><h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><ul><li>只能用一条 order by 子句，并且必须出现在最后一条 select 语句之后</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN2</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cN1;</span><br></pre></td></tr></table></figure></li><li><p>order by 子句放在最后，是对组合查询的整个结果进行排序</p></li></ul><h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a><center>全文本搜索</center></h2><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><ul><li>一般在创建表的时候启用 全文本搜索</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tN</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>          <span class="built_in">int</span>       <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  title       <span class="built_in">char</span>(<span class="number">10</span>)  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  note_text   <span class="built_in">text</span>      <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="keyword">id</span>),</span><br><span class="line">  fulltext(note_text)  </span><br><span class="line">)<span class="keyword">engine</span>=MyISAM;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>Match()指定被搜索的列，Against()指定要使用的搜索表达式</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'value'</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询结果为 note_text 列中带有 value 值的行</p></li><li>全文本搜索不区分大小写</li></ul><hr><ul><li>下面的 like 子句也可查询同样的结果</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> note_text <span class="keyword">like</span> <span class="string">'%value%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>全文本搜索返回的结果行顺序和 like 子句返回的行顺序稍有区别</p></li><li>全文本搜索返回的结果按照 词的出现的次序等级 对每个结果行进行排序（比如：value 出现在第一个词比出现在第三个词的等级高） ；具有较高等级的行先出现，排在前面</li><li>等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来</li><li>like 子句以不是特别有用的顺序返回数据</li></ul><hr><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line">       <span class="keyword">Match</span>(note_text) Against(<span class="string">'value'</span>) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> tN；</span><br></pre></td></tr></table></figure></li><li><p>如果在 select 子句中使用 Match() 和 Against(),则会返回一个计算列</p></li><li>计算列的值就是词的等级值，不包含检索值的等级值为 0</li><li>这些值帮助全文本搜索如何排除行（等级为0的行），如何排序结果（按等级降序排列）</li><li>由于数据是索引的，全文本搜索速度还比较快</li></ul><h3 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h3><ul><li><code>with query expansion</code>  用来放宽返回文本的搜索结果的范围</li><li>比如想查询包含 value 和其他包含相关信息的行，即使其它行中不包含 value </li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'value'</span> <span class="keyword">with</span> <span class="keyword">query</span> expansion);</span><br></pre></td></tr></table></figure></li><li><p>查询扩展的执行顺序：</p><ol><li>先执行基本全文本搜索，找出与条件匹配的所有行</li><li>其次，MySQL检查这些匹配行并选择与条件词相关的有用词</li><li>最后，MySQL再次执行全文本搜索，这次不仅使用原来的条件，还附带了相关有用词的条件</li></ol></li><li>利用查询扩展，能够尽可能的查询出相关结果，即使它们不是很精确</li></ul><h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><ul><li><code>in boolean mode</code></li></ul><p><img src="/images/MySQLCrashCourse/17.png" alt> </p><ul><li>没有指定操作符，搜索结果匹配 value 或 key 中至少一个词的行</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'value key'</span> <span class="keyword">in</span> <span class="built_in">boolean</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></table></figure></li><li><p>搜索结果匹配 value key 短语的行</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'"value key"'</span> <span class="keyword">in</span> <span class="built_in">boolean</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></table></figure></li><li><p>搜索结果匹配包含 value 排除 key 的行</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'"+value -key"'</span> <span class="keyword">in</span> <span class="built_in">boolean</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></table></figure></li><li><p>在布尔方式中，不按等级值降序返回的行</p></li></ul><p><img src="/images/MySQLCrashCourse/18.png" alt> </p><p><img src="/images/MySQLCrashCourse/19.png" alt> </p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><center>插入数据</center></h2><h3 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h3><ul><li><code>insert into tN values(&#39;key&#39;,&#39;value&#39;,&#39;null&#39;);</code> </li><li>每个列字段必须提供值，没有值可提供 null 值 （假设该列允许为空值）</li><li>上面的写法简单，但并不安全，极度依赖表字段的次序</li><li>应该用以下的标准写法</li><li><code>insert into tN(cN2,cN1，cN3) values(&#39;value&#39;,&#39;key&#39;,&#39;x&#39;);</code> </li><li>这种写法不依赖表字段次序，按照自定的列字段次序填充即可</li></ul><h3 id="insert-low-priority-into"><a href="#insert-low-priority-into" class="headerlink" title="insert low_priority into"></a>insert low_priority into</h3><ul><li>降低 insert 语句优先级，因为 insert 操作可以很耗时，而且它可能降低等待处理的 select 语句的性能</li><li><code>insert low_priority into tN(cN2,cN1，cN3) values(&#39;value&#39;,&#39;key&#39;,&#39;x&#39;);</code> </li><li>同样使用于 update 和 delete 语句</li></ul><h3 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h3><ul><li>使用多条 insert 语句，最后一次提交即可</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tN(cN2,cN1，cN3) <span class="keyword">values</span>(<span class="string">'value'</span>,<span class="string">'key'</span>,<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tN(cN2,cN1，cN3) <span class="keyword">values</span>(<span class="string">'value1'</span>,<span class="string">'key1'</span>,<span class="string">'x1'</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果插入同一个表，并且结构相同，也可以用以下方式</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tN(cN2,cN1，cN3) </span><br><span class="line"><span class="keyword">values</span>(<span class="string">'value'</span>,<span class="string">'key'</span>,<span class="string">'x'</span>)</span><br><span class="line">      (<span class="string">'value1'</span>,<span class="string">'key1'</span>,<span class="string">'x1'</span>)</span><br><span class="line">      (<span class="string">'value2'</span>,<span class="string">'key2'</span>,<span class="string">'x2'</span>);</span><br></pre></td></tr></table></figure></li><li><p>MySQL用单条 insert 语句处理多个插入 比 使用多条 insert 语句快</p></li></ul><h3 id="插入检索出的数据-insert-select"><a href="#插入检索出的数据-insert-select" class="headerlink" title="插入检索出的数据 insert select"></a>插入检索出的数据 insert select</h3><ul><li>可以从其他表导入数据</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tN(cN2,cN1，cN3) </span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN2;</span><br></pre></td></tr></table></figure></li><li><p>select 语句的每个列对应插入 insert 语句的每个列中</p></li><li>还可以添加 where 子句等条件</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tN(cN2,cN1，cN3) </span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN2</span><br><span class="line"><span class="keyword">where</span> cN1 &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新-删除-数据"><a href="#更新-删除-数据" class="headerlink" title="更新/删除 数据"></a><center>更新/删除 数据</center></h2><h3 id="update-set"><a href="#update-set" class="headerlink" title="update set"></a>update set</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tN</span><br><span class="line"><span class="keyword">set</span> cN2 = <span class="string">'value'</span></span><br><span class="line"><span class="keyword">where</span> cN1 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tN</span><br><span class="line"><span class="keyword">set</span> cN2 = <span class="string">'value'</span>,</span><br><span class="line"><span class="keyword">set</span> cN3 = <span class="string">'key'</span></span><br><span class="line"><span class="keyword">where</span> cN1 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除列值，可以把它设为 null （假设该列允许为空值）</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tN</span><br><span class="line"><span class="keyword">set</span> cN2 = <span class="string">'null'</span></span><br><span class="line"><span class="keyword">where</span> cN1 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul><li><code>delete from tN where cN1 = 1;</code> 删除行</li><li><code>delete from tN</code> 删除表所有内容/删除表中所有行</li></ul><h2 id="操纵表"><a href="#操纵表" class="headerlink" title="操纵表"></a><center>操纵表</center></h2><h3 id="create-table"><a href="#create-table" class="headerlink" title="create table"></a>create table</h3><ul><li>建立新表，指定的表名必须不存在，否则需要先手工删除已存在同名的表</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tN(</span><br><span class="line">  cN1 <span class="built_in">int</span>       <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  cN2 <span class="built_in">char</span>(<span class="number">10</span>)  <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">  cN3 <span class="built_in">char</span>(<span class="number">19</span>)  <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span> (cN1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>如果仅想在一个表不存在时创建它，可以在表名后给出 <code>if not exists</code></p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tN <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  cN1 <span class="built_in">int</span>       <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  cN2 <span class="built_in">char</span>(<span class="number">10</span>)  <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">  cN3 <span class="built_in">char</span>(<span class="number">19</span>)  <span class="literal">null</span>,</span><br><span class="line">  cN4 <span class="built_in">int</span>       <span class="literal">null</span> <span class="keyword">default</span> <span class="number">20</span></span><br><span class="line">  primary <span class="keyword">key</span> (cN1)</span><br><span class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></li><li><p>MySQL 语句中忽略空格</p></li></ul><p><img src="/images/MySQLCrashCourse/20.png" alt> </p><ul><li><code>select last_insert_id()</code> 这个函数可以获取最后插入行的自增id值 </li></ul><h3 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h3><ul><li>MySQL 有具体管理和处理数据的内部引擎</li><li>当使用<code>create table</code>时，该引擎具体创建表；当使用<code>select</code>等语句时，处理数据库操作请求</li><li>一般在 <code>ENGINE =</code>中表明使用的引擎类型</li><li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理</li><li>MEMORY在功能上等同于MyISAM,但由于数据存储在内存中，速度很快（特别适合于临时表）</li><li>引擎类型可以混用，在不同的表选用适合的引擎</li><li>外键不能跨引擎</li></ul><h3 id="alter-table"><a href="#alter-table" class="headerlink" title="alter table"></a>alter table</h3><ul><li>增加列</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tN</span><br><span class="line"><span class="keyword">add</span> cN5 <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除列</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tN</span><br><span class="line"><span class="keyword">drop</span> cN5 <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>alter table</code> 常用来定义外键</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tN</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_tN_tN1  </span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (cN9) <span class="keyword">references</span> tN1 (cN9)</span><br></pre></td></tr></table></figure></li></ul><h3 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h3><ul><li><code>drop table tN</code> 删除表</li></ul><h3 id="rename-table"><a href="#rename-table" class="headerlink" title="rename table"></a>rename table</h3><ul><li><code>rename table tN to NewtN</code>  重命名表</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> tN1 <span class="keyword">to</span> NewtN1,</span><br><span class="line">             tN2 <span class="keyword">to</span> NewtN2,</span><br><span class="line">             tN3 <span class="keyword">to</span> NewtN3;</span><br></pre></td></tr></table></figure></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a><center>视图</center></h2><ul><li>视图是虚拟的表，视图只包含使用时动态检索数据的查询</li><li>视图本身不包含数据，它们返回的数据是从其他表中检索出来的</li><li>视图相当于把 select 语句给封装起来，简化数据处理以及重新格式化基础数据或保护基础数据</li></ul><p><img src="/images/MySQLCrashCourse/21.png" alt> </p><ul><li>视图不能被索引，也不能有关联的触发器或默认值</li><li>视图可以和表一起使用</li></ul><h3 id="简化复杂联结"><a href="#简化复杂联结" class="headerlink" title="简化复杂联结"></a>简化复杂联结</h3><ul><li>视图的最常见应用之一是隐藏复杂的SQL</li><li>就是把复杂的查询结果作为视图，然后提供给之后的查询使用，提高便利和复用性</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> viewName <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3</span><br><span class="line"><span class="keyword">from</span> tN1,tN2,tN3</span><br><span class="line"><span class="keyword">where</span> tN1.cN1 = tN2.cN1</span><br><span class="line">  <span class="keyword">and</span> tn3.cN1 = tN2.cN1;</span><br></pre></td></tr></table></figure></li><li><p>有了上面的视图创建之后，下面就可以很方便的利用已经创建好的视图，简化SQL</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,cN2</span><br><span class="line"><span class="keyword">form</span> viewName</span><br><span class="line"><span class="keyword">where</span> cN1 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="重新格式化已检索的数据"><a href="#重新格式化已检索的数据" class="headerlink" title="重新格式化已检索的数据"></a>重新格式化已检索的数据</h3><ul><li>视图另一常见的用途是重新格式化检索出的数据</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(cN1),<span class="string">'('</span>,<span class="keyword">RTrim</span>(cN2),<span class="string">')'</span>) <span class="keyword">as</span> NewcN</span><br><span class="line"><span class="keyword">from</span> tN2</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cN1;</span><br></pre></td></tr></table></figure></li><li><p>如果经常会用到以上的格式的查询结果时，可以把这个结果创建成视图，就不必每次都执行联结</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> viewName <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(cN1),<span class="string">'('</span>,<span class="keyword">RTrim</span>(cN2),<span class="string">')'</span>) <span class="keyword">as</span> NewcN</span><br><span class="line"><span class="keyword">from</span> tN2</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cN1;</span><br></pre></td></tr></table></figure></li><li><p>然后就可以很方便的利用它了</p></li><li><code>select * from viewName</code> 返回和上面一样的结果</li></ul><h3 id="过滤数据-1"><a href="#过滤数据-1" class="headerlink" title="过滤数据"></a>过滤数据</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> viewName <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> cN1,cN2</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> cN2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>上面的可以理解为把 <code>select cN1,cN2 from tN</code>创建成视图 viewName</p></li><li>然后在 viewName 视图中使用 where 子句过滤</li><li>视图在处理 where 子句时，会把 where 子句添加到内部语句<code>select cN1,cN2 from tN</code>中，形成<code>select cN1,cN2 from tN where cN2 is not null;</code>进行查询，以便正确的过滤数据</li></ul><h3 id="计算字段-1"><a href="#计算字段-1" class="headerlink" title="计算字段"></a>计算字段</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cN1,cN2,cN3,cN1*cN3 <span class="keyword">as</span> NewcN</span><br><span class="line"><span class="keyword">from</span> tN</span><br><span class="line"><span class="keyword">where</span> cN2 = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> viewName <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> cN1,cN2,cN3,cN1*cN3 <span class="keyword">as</span> NewcN</span><br><span class="line"><span class="keyword">from</span> tN;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> viewName  </span><br><span class="line"><span class="keyword">where</span> cN2 = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><ul><li>视图没有数据，对视图进行增加或删除行，实际上是对其表的增加或删除行</li><li>通常，视图是可以更新的（insert/update/delete）,但是，并非所有视图都可以更新</li><li>也就是说，如果MySQL不能正确地确定被更新的基数据，则不允许更新</li><li>如果视图定义中有以下操作，则不能进行视图的更新<ol><li>分组 group by /having</li><li>联结</li><li>子查询</li><li>并</li><li>聚集函数</li><li>distinct</li><li>导出（计算）列</li></ol></li><li>换句话说，多数视图都是不可更新的</li><li>一般来说，应该将视图用于检索，而不用于更新</li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><center>存储过程</center></h2><ul><li>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合</li><li>为什么要使用存储过程<ol><li>把处理封装在容易使用的单元中，简化复杂操作</li><li>开发人员都一起用一套存储过程，保证了数据的完整性</li><li>简化对变动的管理，只需要修改存储过程的代码即可</li><li>提高性能，使用存储过程比使用单独的SQL语句要快</li><li>存在一些只能使用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码</li></ol></li></ul><h3 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h3><ul><li>MySQL称存储过程的执行为调用，因此执行存储过程的语句为 call</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br></pre></td></tr></table></figure></li><li><p>执行名为 productpricing 的存储过程，返回最低、最高、平均价格</p></li><li>存储过程的结果可以显示，也可以不显示</li></ul><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> productpricing()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> avh(prod_price) <span class="keyword">as</span> priceaverage</span><br><span class="line">  <span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>create procedure</code> 创建存储过程</p></li><li><code>create procedure productpricing()</code> 如果存储过程接受参数，可以在（）中列举</li><li>begin 和 end 用来限定存储过程体</li><li>过程体本身就是 SQL 语句</li></ul><p><img src="/images/MySQLCrashCourse/22.png" alt> </p><p><img src="/images/MySQLCrashCourse/23.png" alt> </p><ul><li><code>call productpricing();</code>  执行刚才创建的存储过程并返回结果</li><li>存储过程实际上是一直函数，所以存储过程名后需要有（）</li></ul><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><ul><li><code>drop procedure productpricing</code> 删除存储过程，存储过程名后面不带（）</li><li>如果指定的存储过程不存在，则产生错误提示</li><li><code>drop procedure is exist productpricing</code> 仅当存储过程存在的时候删除，不存在的时候删除也不会产生错误提示</li></ul><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> productpricing(</span><br><span class="line">  <span class="keyword">out</span> pl <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">out</span> ph <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">out</span> pa <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">min</span>(prod_price)</span><br><span class="line">  <span class="keyword">into</span> pl</span><br><span class="line">  <span class="keyword">from</span> products;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">max</span>(prod_price)</span><br><span class="line">  <span class="keyword">into</span> ph</span><br><span class="line">  <span class="keyword">from</span> products;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">avg</span>(prod_price)</span><br><span class="line">  <span class="keyword">into</span> pa</span><br><span class="line">  <span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>pl 最低价，ph 最高价，pa 平均价</p></li><li>out 关键字：从存储过程传出一个值给调用者</li><li>into 关键字：指定保存的变量</li><li>这里的整体意思是，把查询（select）的结果保存（into）到变量（pl/ph/pa）中，然后返回给调用者</li><li>此外、in 关键字：传递给存储过程；inout 关键字：对存储过程的传入和传出</li><li>以下调用该存储过程，传递对应数目的参数</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br></pre></td></tr></table></figure></li><li><p>检索返回的值</p></li><li><code>select @pricelow,@pricehigh,@priceaverage;</code></li></ul><hr><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal(</span><br><span class="line">  <span class="keyword">in</span> onmuber <span class="built_in">int</span>,</span><br><span class="line">  <span class="keyword">out</span> ototal <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">sum</span>(item_price*quantity)</span><br><span class="line">    <span class="keyword">from</span> orderitems</span><br><span class="line">    <span class="keyword">where</span> order_num = onumber</span><br><span class="line">    <span class="keyword">into</span> ototal;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>call ordertotal(20005,@total);</code></p></li><li><code>select @total;</code></li><li>想得到另外的结果，需要再次调用存储过程</li><li><code>call ordertotal(20009,@total);</code></li><li><code>select @total;</code></li></ul><h3 id="智能存储过程"><a href="#智能存储过程" class="headerlink" title="智能存储过程"></a>智能存储过程</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters: onumber = order number</span></span><br><span class="line"><span class="comment">--             taxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line">               ototal = order total variable</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal(</span><br><span class="line">  <span class="keyword">in</span> onumber <span class="built_in">int</span> ,</span><br><span class="line">  <span class="keyword">in</span> taxable <span class="built_in">boolean</span> ,</span><br><span class="line">  <span class="keyword">out</span> ototal <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">) <span class="keyword">comment</span> <span class="string">'Obtain order total, optiona11y adding tax'</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">-- Declare variable for total</span></span><br><span class="line">  <span class="comment">-- Declare tax percentage</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">declare</span> total <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">declare</span> taxrate <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Get the order total</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">Sum</span>(item_ price*quantity)</span><br><span class="line">  <span class="keyword">from</span> orderitems</span><br><span class="line">  <span class="keyword">where</span> order_ <span class="keyword">num</span> = onumber</span><br><span class="line">  <span class="keyword">into</span> total;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Is this taxable?</span></span><br><span class="line">  <span class="comment">-- Yes, so add taxrate to the total</span></span><br><span class="line"></span><br><span class="line">  if taxable then</span><br><span class="line">     <span class="keyword">select</span> total+(total/<span class="number">100</span>*taxrate) <span class="keyword">into</span> total;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- And finally,save to out variable</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">select</span> total <span class="keyword">into</span> ototal;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>注释（–）</p></li><li>declare 定义了局部变量</li><li>if , elseif , else 判断</li></ul><p><img src="/images/MySQLCrashCourse/24.png" alt> </p><ul><li>测试执行以上的存储过程</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> ordertotal(<span class="number">20005</span>,<span class="number">0</span>,@total);</span><br><span class="line"><span class="keyword">select</span> @total;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> ordertotal(<span class="number">20005</span>,<span class="number">1</span>,@total);</span><br><span class="line"><span class="keyword">select</span> @total;</span><br></pre></td></tr></table></figure></li></ul><h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><ul><li><code>show create procedure ordertotal;</code></li><li><code>show procedure status;</code></li></ul><p><img src="/images/MySQLCrashCourse/25.png" alt> </p><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a><center>游标</center></h2><ul><li>游标是一个存储在 MySQL 服务器上的数据库查询，他不是一条 select 语句，而是被该语句检索出来的结果集</li><li>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改</li><li>MySQL 游标只能用于存储过程</li></ul><h3 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h3><ul><li>在能够使用前，必须声明它</li><li>一旦声明后，必须打开游标以供使用</li><li>对于填有数据的游标，根据需要取出各行</li><li>在结束游标使用时，必须关闭游标</li></ul><h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><ul><li>游标用 declare 语句创建</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> processorders()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> ordernumbers <span class="keyword">cursor</span></span><br><span class="line">    <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> order_num <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>存储过程处理完成后，游标就消失（因为它局限于存储过程）</p></li></ul><h3 id="打开-关闭-游标"><a href="#打开-关闭-游标" class="headerlink" title="打开/关闭 游标"></a>打开/关闭 游标</h3><ul><li><code>open ordernumbers;</code>  打开游标</li><li>处理 open 语句时执行查询，存储检索出的数据以供浏览和滚动</li><li><code>close ordernumbers;</code> 关闭游标</li><li>close 释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭</li><li>声明过的游标不需要再次声明，用 open 语句打开它就可以了</li></ul><p><img src="/images/MySQLCrashCourse/26.png" alt></p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> processorders()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> ordernumbers <span class="keyword">cursor</span></span><br><span class="line">    <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> order_num <span class="keyword">from</span> orders;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    close ordernumbers;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>打开/关闭 游标的操作需要在存储过程中使用，相当于把检索出的数据用游标定位再做一次检索</p></li><li>主要操作还是通过 call 存储过程来体现</li></ul><h3 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h3><ul><li>fetch 关键字：指定检索什么数据（所需的列），检索出来的数据存储在什么地方；他还向前移动游标中的内部行指针，使下一条 fetch 语句检索下一行（不重复读取同一行）</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> processorders()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> o <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">declare</span> ordernumbers <span class="keyword">cursor</span></span><br><span class="line">  <span class="keyword">for</span></span><br><span class="line">  <span class="keyword">select</span> order_num <span class="keyword">from</span> orders;</span><br><span class="line"></span><br><span class="line">  open ordernumbers;</span><br><span class="line">  fetch ordernumbers into o;</span><br><span class="line">  close ordernumbers;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>fetch 检索了当前行 order_num 列（自动从第一行开始）到一个名为 o 的局部变量中</p></li></ul><hr><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> processorders()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">declare</span> o <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">declare</span> ordernumbers <span class="keyword">cursor</span></span><br><span class="line">  <span class="keyword">for</span></span><br><span class="line">  <span class="keyword">select</span> order_num <span class="keyword">from</span> orders;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  open ordernumbers;</span><br><span class="line">  repeat</span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line">  until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">  close ordernumbers;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>repeat</code> 和 <code>until done end repeat;</code>之间为循环体，执行到 done 为真</p></li><li><code>declare continue handler for sqlstate &#39;02000&#39; set done=1;</code> continu handler 指出当 sqlstate ‘02000’ 出现时，设置 done 为 1 </li><li>sqlstate ‘02000’是一个未找到条件，当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件</li></ul><p><img src="/images/MySQLCrashCourse/27.png" alt> </p><h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal(</span><br><span class="line">  <span class="keyword">in</span> onumber <span class="built_in">int</span> ,</span><br><span class="line">  <span class="keyword">in</span> taxable <span class="built_in">boolean</span> ,</span><br><span class="line">  <span class="keyword">out</span> ototal <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">) <span class="keyword">comment</span> <span class="string">'Obtain order total, optiona11y adding tax'</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> total <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">declare</span> taxrate <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">Sum</span>(item_ price*quantity)</span><br><span class="line">  <span class="keyword">from</span> orderitems</span><br><span class="line">  <span class="keyword">where</span> order_ <span class="keyword">num</span> = onumber</span><br><span class="line">  <span class="keyword">into</span> total;</span><br><span class="line"></span><br><span class="line">  if taxable then</span><br><span class="line">     <span class="keyword">select</span> total+(total/<span class="number">100</span>*taxrate) <span class="keyword">into</span> total;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">select</span> total <span class="keyword">into</span> ototal;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> processorders()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">declare</span> o <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">declare</span> t <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">declare</span> ordernumbers <span class="keyword">cursor</span></span><br><span class="line">  <span class="keyword">for</span></span><br><span class="line">  <span class="keyword">select</span> order_num <span class="keyword">from</span> orders;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> ordertotals(order_num <span class="built_in">int</span>,total <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  open ordernumbers;</span><br><span class="line">  repeat</span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line">    <span class="keyword">call</span> ordertotal(o,<span class="number">1</span>,t);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ordertotals(order_num,total)</span><br><span class="line">    <span class="keyword">values</span>(o,t);</span><br><span class="line">  until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">  close ordernumbers;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><center>触发器</center></h2><ul><li>触发器：在事件发生的时候自动执行；在某个表发生更改时自动处理</li><li>触发器响应的语句：（1）delete（2）insert（3）update</li></ul><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><ul><li>创建触发器的准则<ol><li>唯一的触发器名 </li><li>触发器关联的表</li><li>触发器应该响应的活动（delete/insert/update）</li><li>触发器何时执行（处理之前还是之后）</li></ol></li><li><code>create trigger</code> 创建触发器</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> newproduct <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> products</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">select</span> <span class="string">'product added'</span></span><br></pre></td></tr></table></figure></li><li><p>创建名为 newproduct 的触发器</p></li><li>after insert 在 insert 语句执行后执行</li><li>on products 对于这个表进行响应</li><li>for each row 代码对每个插入行执行</li><li>‘product added’ 对每个插入的行显示一次</li><li>整个流程为：对 products 表每使用 insert 语句添加一行或多行，会看到对每个成功的插入，都会显示 product added 消息</li></ul><p><img src="/images/MySQLCrashCourse/28.png" alt> </p><ul><li>触发器安每个表每个事件每次地定义</li><li>每个表每个事件每次只允许一个触发器</li><li>因此，每个表最多支持6个触发器（每条insert、update、delete的之前和之后）</li><li>单一触发器不能与多个事件或多个表关联</li></ul><p><img src="/images/MySQLCrashCourse/29.png" alt> </p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><ul><li><code>drop trigger newproduct</code> 删除触发器</li><li>触发器不能更新或覆盖；修改一个触发器，必须先删除它，然后再重新创建</li></ul><h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><h4 id="insert-触发器"><a href="#insert-触发器" class="headerlink" title="insert 触发器"></a>insert 触发器</h4><ol><li>在 insert 触发器代码内，可以引用一个名为 new 的虚拟表，访问被插入的行</li><li>在 before insert 触发器中，new 中的值也可以被更新（允许更改被插入的值）</li><li>对于 auto_increment 列，new 在 insert 执行之前包含0，在 insert 执行之后包含新的自动生成值</li></ol><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> neworder <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> orders</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">select</span> new.order_num;</span><br></pre></td></tr></table></figure></li><li><p>order_num 是 orders 中的自增字段</p></li><li>每次执行插入操作时，都会引用名为 new 的虚拟表，然后把 orders 中获得的 order_num 值填充到新的虚拟表中</li><li>order_num 是 orders 中的自增字段 ，因此该触发器必须 after insert , 因为 before insert 的话，order_num 还没生成</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(order_date,cust_id)</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">now</span>(),<span class="number">10001</span>);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|order_num|</span><br><span class="line">|—————————|              </span><br><span class="line">|  20001  |</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/MySQLCrashCourse/30.png" alt></p><h4 id="delete-触发器"><a href="#delete-触发器" class="headerlink" title="delete 触发器"></a>delete 触发器</h4><ol><li>在 delete 触发器代码内，可以引用一个名为 old 的虚拟表，访问被删除的行</li><li>old 中的值全都是只读的，不能更新</li></ol><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> deleteorder <span class="keyword">before</span> <span class="keyword">delete</span> <span class="keyword">on</span> orders</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> archive_orders(order_num,order_date,cust_id)</span><br><span class="line">  <span class="keyword">values</span>(old.order_num,old.order_date,old.cust_id)</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/MySQLCrashCourse/31.png" alt></p><h4 id="update-触发器"><a href="#update-触发器" class="headerlink" title="update 触发器"></a>update 触发器</h4><ul><li>在 update 触发器代码中，可以引用一个名为 old 的虚拟表访问以前（update语句前）的值，引用一个名为 new 的虚拟表访问新更新的值</li><li>在 before update 触发器中，new 中的值可能也被更新（允许更改将要用于 update 语句中的值）</li><li>old 中的值全都是只读的，不能更新</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> updatevendor <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">on</span> vendors</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">set</span> new.vend_state = <span class="keyword">upper</span>(new.vend_state);</span><br></pre></td></tr></table></figure></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><center>事务</center></h2><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><ul><li>并非所有引擎都支持事务处理</li><li>MyISAM 和 InnoDB 是两种最常用的引擎，前者不支持明确的事务处理管理，而后者支持</li><li>事务处理：可以用来维护数据库的完整性，保证成批的 MySQL 操作要么完全执行，要么完全不执行</li></ul><ol><li>事务（transaction）指一组SQL语句</li><li>回退（rollback）指撤销指定SQL语句的过程</li><li>提交（commit）指将未存储的SQL语句结果写入数据库表</li><li>保留点（savepoint）指事务处理中设置的临时占位符（place- holder），可以对它发布回退（与回退整个事务处理不同）</li></ol><h3 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h3><ul><li>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退</li><li><code>start transaction</code> 标识事务的开始</li></ul><h4 id="回退-rollback"><a href="#回退-rollback" class="headerlink" title="回退 rollback"></a>回退 rollback</h4><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ordertotals;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> ordertotals;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ordertotals;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ordertotals;</span><br></pre></td></tr></table></figure></li><li><p>rollback 语句回退 start transaction 之后的所有语句</p></li><li>整个流程为：（1）查看表内容不为空（2）标识事务开始（3）删除表内容（4）查看表内容为空（5）回退（6）查看表内容不为空</li><li>rollback 只能在一个事务处理内使用（在执行一条 start transaction 命令之后）</li></ul><p><img src="/images/MySQLCrashCourse/32.png" alt></p><h4 id="提交-commit"><a href="#提交-commit" class="headerlink" title="提交 commit"></a>提交 commit</h4><ul><li>一般的 MySQL 语句都是直接针对数据库表执行和编写的；这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的</li><li>但是，在事务处理块中，提交不会隐含地提交</li><li>为进行明确的提交，使用 commit 语句</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> orders <span class="keyword">where</span> order_num =<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/MySQLCrashCourse/33.png" alt></p><h4 id="保留点-savepoint"><a href="#保留点-savepoint" class="headerlink" title="保留点 savepoint"></a>保留点 savepoint</h4><ul><li>复杂一点的事务处理可能需要部分提交或回退</li><li>这个时候就需要在事务处理中合适的位置放置占位符，如果需要回退，就可以回退到占位符的位置，这些占位符就称为 保留点</li><li><code>savepoint delete1;</code> 创建保留点</li><li><code>rollback to delete1;</code> 回退到保留点</li></ul><p><img src="/images/MySQLCrashCourse/34.png" alt></p><p><img src="/images/MySQLCrashCourse/35.png" alt></p><h4 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h4><ul><li>默认的 MySQL 行为是自动提交所有更改；换句话说，任何时候你执行一条 MySQL 语句，该语句实际上都是针对表执行的，而且所做的更改立即生效</li><li><code>set autocommit = 0;</code>  为了让 MySQL 不自动提交更改 ，设置 autocommit 为0（假）</li></ul><p><img src="/images/MySQLCrashCourse/36.png" alt></p><h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a><center>全球化和本地化</center></h2><ul><li>数据库表用来存储和检索数据</li><li>不同的语言和字符集需要以不同的方式存储和检索</li><li>字符集：字母和符号的集合</li><li>编码：某个字符集成员的内部表示</li><li>校对：规定字符如何比较的指令</li></ul><p><img src="/images/MySQLCrashCourse/37.png" alt></p><ul><li><code>show character set;</code> 显示所有可用的字符集以及每个字符集的描述和默认校对</li><li><code>show collation;</code> 显示所有可用的校对，以及它们适用的字符集；有的字符集具有不止一次的校对</li></ul><hr><ul><li><code>show variables like &#39;character%&#39;;</code> 指定默认的字符集和校对</li><li><code>show variables like &#39;collation%&#39;;</code> </li><li>给表指定字符集和校对顺序</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mytable</span><br><span class="line">(</span><br><span class="line">  columnn1 <span class="built_in">int</span>,</span><br><span class="line">  columnn2 <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">) <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> hebrew</span><br><span class="line">  <span class="keyword">collate</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>给列指定字符集和校对顺序</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mytable</span><br><span class="line">(</span><br><span class="line">  columnn1 <span class="built_in">int</span>,</span><br><span class="line">  columnn2 <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">  columnn3 <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="built_in">character</span> <span class="keyword">set</span> latinl <span class="keyword">collate</span> latin1_general_ci  </span><br><span class="line">) <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> hebrew</span><br><span class="line">  <span class="keyword">collate</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>指定备用的顺序校对</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> customers</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> lastname,firstname <span class="keyword">collate</span> latin1_general_cs;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/MySQLCrashCourse/38.png" alt></p><ol><li>如果指定 character set 和 collate 两者，则使用这些值</li><li>如果只指定 character set ，则使用此字符集及其默认的校对</li><li>如果既不指定 character set ，也不指定 collate ，则使用数据库默认</li></ol><p><img src="/images/MySQLCrashCourse/39.png" alt></p><ul><li>如果绝对需要，串可以在字符集之间进行转换；使用 cast() 或 convert() 函数</li></ul><h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a><center>安全管理</center></h2><ul><li>MySQL 用户账号和信息存在名为 mysql 的数据库中</li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h3><p><img src="/images/MySQLCrashCourse/40.png" alt></p><ul><li><code>create user oreki identified by &#39;p@$$wOrd&#39;</code> 创建用户名和密码</li></ul><p><img src="/images/MySQLCrashCourse/41.png" alt></p><p><img src="/images/MySQLCrashCourse/42.png" alt></p><p><img src="/images/MySQLCrashCourse/43.png" alt></p><ul><li><code>rename user oreki to elias</code>  重命名一个用户账号</li><li><code>drop user elias</code> 删除一个用户账号</li></ul><p><img src="/images/MySQLCrashCourse/44.png" alt></p><ul><li><code>set password for elias = password(&#39;n3wp@$$wOrd&#39;)</code>  修改用户的密码</li><li><code>set password = password(&#39;n3wp@$$wOrd&#39;)</code>  不指定用户名时，更改当前登录用户的密码</li></ul><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><ul><li>在创建用户账号后，必须接着分配访问权限</li><li>新创建的用户账号没有访问权限</li><li>它们能登录MySQL，但不能看到数据，不能执行任何数据库操作</li><li><code>show grants for elias</code> 查看用户账号的权限</li><li>grant 语句需要给出的信息： （1）要授予的权限（2）被授予访问权限的数据库或表（3）用户名</li><li><code>grant select on crashcourse.* to elias;</code> 允许用户 elias 在 crashcourse 数据库的所有表上使用 select ; 只授予 select 访问权限，具有 只读 访问权限</li><li>grant 的反操作为 revoke ,撤销特定的权限</li><li><code>revoke select on crashcourse.* from elias</code></li></ul><p><img src="/images/MySQLCrashCourse/45.png" alt></p><p><img src="/images/MySQLCrashCourse/46.png" alt></p><p><img src="/images/MySQLCrashCourse/47.png" alt></p><p><img src="/images/MySQLCrashCourse/48.png" alt></p><p><img src="/images/MySQLCrashCourse/49.png" alt></p><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a><center>数据库维护</center></h2><ul><li><code>analyze table tN</code>  检查表键是否正确</li><li><code>check table tN</code> </li><li><code>flush tables</code>  刷新表</li><li><code>flush logs</code>  刷新日志</li></ul><p><img src="/images/MySQLCrashCourse/50.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Remarks&quot;&gt;&lt;a href=&quot;#Remarks&quot; class=&quot;headerlink&quot; title=&quot;Remarks&quot;&gt;&lt;/a&gt;&lt;center&gt;Remarks&lt;center&gt;&lt;/center&gt;&lt;/center&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;columnName = cN&lt;/li&gt;
&lt;li&gt;tableName = tN&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;检索数据&quot;&gt;&lt;a href=&quot;#检索数据&quot; class=&quot;headerlink&quot; title=&quot;检索数据&quot;&gt;&lt;/a&gt;&lt;center&gt;检索数据&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;use-show&quot;&gt;&lt;a href=&quot;#use-show&quot; class=&quot;headerlink&quot; title=&quot;use / show&quot;&gt;&lt;/a&gt;use / show&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;use databaseName;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show databases;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show tables;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show columns from tN;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;select-distinct&quot;&gt;&lt;a href=&quot;#select-distinct&quot; class=&quot;headerlink&quot; title=&quot;select / distinct&quot;&gt;&lt;/a&gt;select / distinct&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select cN,cN2 from tN;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from tN;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select distinct cN from tN;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;limit&quot;&gt;&lt;a href=&quot;#limit&quot; class=&quot;headerlink&quot; title=&quot;limit&quot;&gt;&lt;/a&gt;limit&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select cN from tN limit 3;&lt;/code&gt;    返回3行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select cN from tN limit 3,4;&lt;/code&gt;返回第3行后面的4行（第一个数为开始的位置，第二个为要检索的行数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;limit 3,4&lt;/code&gt; 等同于 &lt;code&gt;limit 4 offset 3&lt;/code&gt; 都是从第3行后面开始取4行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;order&quot;&gt;&lt;a href=&quot;#order&quot; class=&quot;headerlink&quot; title=&quot;order&quot;&gt;&lt;/a&gt;order&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select tNX.cN from databaseName.tNX;&lt;/code&gt;   完全限定列名、表名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select cN from tN order by cN;&lt;/code&gt;    按照指定列名排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select cN1,cN2,cN3 from tN order by cN2,cN3;&lt;/code&gt;   按指定多个列名的顺序排序（只有在指定的前面的列值相同情况下，再对后面的列值排序）
    
    </summary>
    
    
    
      <category term="MySQL" scheme="http://www.orekiyuta.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Head First Java / After reading</title>
    <link href="http://www.orekiyuta.cn/archives/HeadFirstJava/"/>
    <id>http://www.orekiyuta.cn/archives/HeadFirstJava/</id>
    <published>2020-06-06T16:08:00.000Z</published>
    <updated>2020-06-23T14:36:44.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dog-d-new-Dog"><a href="#Dog-d-new-Dog" class="headerlink" title="Dog d =new Dog();"></a><center>Dog d =new Dog();</center></h2><ul><li>在 d 中保存的是存取Dog()对象的方法，存储了指向Dog()对象的地址，存储了引用Dog对象的值。<br>对象并没有放进变量中。</li></ul><p><img src="/images/HeadFirstJava/01.png" alt><br><a id="more"></a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><center>继承</center></h2><ul><li><p>is a 单方向判断</p></li><li><p>可以用 子类 is a 父类，来判断是否符合继承关系</p></li><li><p>super.xx(); 调用父类的方法</p></li></ul><p><img src="/images/HeadFirstJava/06.png" alt> </p><ul><li>JVM从最后的子类开始读取方法，层层向上读取</li></ul><h2 id="存取权限"><a href="#存取权限" class="headerlink" title="存取权限"></a><center>存取权限</center></h2><ul><li><p>private &lt; default &lt; protected &lt; public</p></li><li><p>public 的成员会被继承；private 的成员不会被继承</p></li><li><p>继承下来的方法可以被覆盖，但是成员变量无法被覆盖</p></li></ul><h2 id="抽象与接口"><a href="#抽象与接口" class="headerlink" title="抽象与接口"></a><center>抽象与接口</center></h2><ul><li><p>抽象类必须要被继承，抽象方法必须要被覆盖</p></li><li><p>如果声明出抽象方法，那必须将类也标记为抽象</p></li><li><p>有抽象方法的类一定是抽象类</p></li><li><p>抽象方法必须被其中的子类，或最后的子类实现</p></li><li><p>ArrayList 用到的是 Object 类型 ，所以ArrayList通用</p></li><li><p>ArrayList<int> 是限制它的类型，这样 ArrayList只能保存int类型对象</int></p></li><li><p>没有直接继承过其他类的类是隐含的继承对象。所有类都继承于 Object 类</p></li></ul><p><img src="/images/HeadFirstJava/04.png" alt> </p><ul><li>Object 类主要目的：（1）作为多态让方法可以应对多种类型的机制 （2）提供Java在执行期的所有对象都有需要的基础方法</li></ul><p><img src="/images/HeadFirstJava/02.png" alt> </p><ul><li>编译器只管引用的类型，而不管对象的类型；Animal a =new Dog(); 只根据引用类型 Animal 来判断有哪些方法可以调用</li></ul><p><img src="/images/HeadFirstJava/03.png" alt> </p><p><img src="/images/HeadFirstJava/05.png" alt> </p><h2 id="堆栈与对象"><a href="#堆栈与对象" class="headerlink" title="堆栈与对象"></a><center>堆栈与对象</center></h2><ul><li><p>JVM启动，从底层操作系统取得一块内存；在此内存执行Java程序</p></li><li><p>在这内存中有两种区域：（1）对象的生存空间堆 （2）方法调用和变量的生存空间栈</p></li></ul><p><img src="/images/HeadFirstJava/07.png" alt> </p><ul><li>变量在哪个空间要看它属于哪种变量：（1）实例变量（2）局部变量[栈变量]</li></ul><p><img src="/images/HeadFirstJava/08.png" alt> </p><ul><li>调用方法压栈</li></ul><p><img src="/images/HeadFirstJava/09.png" alt> </p><ul><li>局部变量在所属的方法中，所以在栈上；对象始终都是在堆上的</li></ul><p><img src="/images/HeadFirstJava/10.png" alt> </p><ul><li>实例变量在所属的对象里面，所以在堆上</li></ul><p><img src="/images/HeadFirstJava/11.png" alt> </p><ul><li><p>如果实例变量是个对像的引用，则引用和对象也都是在堆上</p></li><li><p>实例变量默认值：0/0.0/false,引用默认值 null</p></li></ul><h2 id="构造函数链"><a href="#构造函数链" class="headerlink" title="构造函数链"></a><center>构造函数链</center></h2><p><img src="/images/HeadFirstJava/12.png" alt> </p><ul><li>创建子类对象时，父类对象的构造函数也会被层层执行</li></ul><p><img src="/images/HeadFirstJava/13.png" alt> </p><ul><li>执行方法，先压栈，压栈完毕后才逐个从栈顶开始执行</li></ul><p><img src="/images/HeadFirstJava/14.png" alt> </p><ul><li>调用父类构造函数的方法 super()</li></ul><p><img src="/images/HeadFirstJava/15.png" alt> </p><ul><li>对 super() 的调用必须是构造函数的第一个语句</li></ul><p><img src="/images/HeadFirstJava/16.png" alt> </p><ul><li>给父类构造函数传参 super(xxx)</li></ul><p><img src="/images/HeadFirstJava/17.png" alt> </p><ul><li>从一个构造函数中调用另外一个构造函数 this()</li></ul><p><img src="/images/HeadFirstJava/18.png" alt> </p><h2 id="对象与垃圾回收器"><a href="#对象与垃圾回收器" class="headerlink" title="对象与垃圾回收器"></a><center>对象与垃圾回收器</center></h2><ul><li>对象的生命周期取决于引用它的变量的生命周期</li></ul><p><img src="/images/HeadFirstJava/19.png" alt> </p><p><img src="/images/HeadFirstJava/20.png" alt> </p><ul><li><p>对象被垃圾收集器回收</p><p>  （1）对象所处的方法执行完毕，方法弹出栈，因此里面的对象引用也消亡，所以对象没了引用，等待回收</p><p>  <img src="/images/HeadFirstJava/21.png" alt> </p><p>  （2）对象引用被赋予新的对象，旧的对象失去了引用，等待回收</p><p>  <img src="/images/HeadFirstJava/22.png" alt> </p><p>  （3）对象引用被赋予null,旧的对象同样失去了引用，等待回收</p></li></ul><p><img src="/images/HeadFirstJava/23.png" alt> </p><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a><center>静态</center></h2><ul><li><p>静态方法内没有变量，不依靠变量做出行为；可以直接通过类型方法调用</p></li><li><p>非静态方法需要先实例化，再依靠引用变量来调用</p></li></ul><p><img src="/images/HeadFirstJava/24.png" alt> </p><p><img src="/images/HeadFirstJava/25.png" alt> </p><ul><li>静态方法内无法调用非静态变量</li></ul><p><img src="/images/HeadFirstJava/26.png" alt> </p><ul><li>静态方法内无法调用非静态方法</li></ul><p><img src="/images/HeadFirstJava/27.png" alt> </p><ul><li>静态变量只会再第一次载入时进行初始化，并被同一个类的所有实例共享</li></ul><p><img src="/images/HeadFirstJava/28.png" alt> </p><ul><li><p>实例变量：每个实例共享一个</p></li><li><p>静态变量：每个类共享一个</p></li><li><p>静态变量在所属的类的对象创建之前就完成初始化</p></li></ul><p><img src="/images/HeadFirstJava/29.png" alt> </p><ul><li>同时标记静态 static 和 final 的变量是常数，一般命名都是全大写字母</li></ul><p><img src="/images/HeadFirstJava/30.png" alt> </p><ul><li>final 可以用来固定值不变，方法不能被覆盖，类不能被继承</li></ul><p><img src="/images/HeadFirstJava/31.png" alt> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dog-d-new-Dog&quot;&gt;&lt;a href=&quot;#Dog-d-new-Dog&quot; class=&quot;headerlink&quot; title=&quot;Dog d =new Dog();&quot;&gt;&lt;/a&gt;&lt;center&gt;Dog d =new Dog();&lt;/center&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在 d 中保存的是存取Dog()对象的方法，存储了指向Dog()对象的地址，存储了引用Dog对象的值。&lt;br&gt;对象并没有放进变量中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/HeadFirstJava/01.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>How Program Works / After reading</title>
    <link href="http://www.orekiyuta.cn/archives/HowProgramWorks/"/>
    <id>http://www.orekiyuta.cn/archives/HowProgramWorks/</id>
    <published>2020-06-05T13:02:26.000Z</published>
    <updated>2020-06-23T14:35:34.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><center>CPU</center></h2><ul><li>CPU(Central Processing Unit)[寄存器、控制器、运算器、时钟]</li></ul><p><img src="/images/HowProgramWorks/01.png" alt> </p><ul><li><p>寄存器：暂存指令、数据</p></li><li><p>控制器：把内存上的指令、数据读入寄存器，并根据结果控制计算机</p></li><li><p>运算器：运算从内存读入寄存器的数据</p></li><li><p>时钟：发起计时</p></li><li><p>程序运行的过程:程序启动后,时钟开始计时,控制器从内存中读取指令和数据,运算器计算数据,控制器根据结果控制计算器</p><a id="more"></a><p><img src="/images/HowProgramWorks/02.png" alt> </p></li><li><p>程序把寄存器作为对象来描述</p></li><li>汇编：将汇编语言转成机器语言;反汇编则反之</li><li>数据分为“用于运算的数据”和“表示内存地址的数据”</li><li>累加寄存器存放“用于运算的数据”</li><li>基址寄存器、变址寄存器存放“表示内存地址的数据”</li></ul><p><img src="/images/HowProgramWorks/03.png" alt> </p><ul><li>程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他寄存器一般有多个</li><li>CPU是寄存器的集合体</li></ul><p><img src="/images/HowProgramWorks/04.png" alt> </p><ul><li>程序的流程由标志寄存器控制，标志寄存器保存当前流程执行的结果，然后选择路径（跳转指令）</li></ul><p><img src="/images/HowProgramWorks/05.png" alt> </p><p><img src="/images/HowProgramWorks/06.png" alt> </p><p><img src="/images/HowProgramWorks/07.png" alt> </p><ul><li>函数调用（call指令）；return指令讲先前保存到栈中的地址设定到程序计数器中（这样函数就能返回开始调用时的位置）</li></ul><p><img src="/images/HowProgramWorks/08.png" alt> </p><ul><li>通过基址寄存器和变址寄存器来划分内存上的特定区域</li></ul><p><img src="/images/HowProgramWorks/09.png" alt> </p><ul><li>机器语言指令主要类型:数据传送、运算、跳转、call/return</li></ul><h2 id="二进制表示数据"><a href="#二进制表示数据" class="headerlink" title="二进制表示数据"></a><center>二进制表示数据</center></h2><ul><li>8位=1字节</li><li>集成电路（IC）所有引脚，只有直流电压0V或5V两个状态；所以IC一个引脚只能表示两个状态，决定了计算机数据只能采用二进制01来处理。</li><li>最小单位（bit）相当于二进制中的一位；bit（binary digit）</li></ul><p><img src="/images/HowProgramWorks/10.png" alt> </p><ul><li>二进制的位数一般是8的倍数，8位二进制数=1个字节</li><li>字节是最基本的信息计量单位，位是最小单位，字节是基本单位</li><li>内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位</li><li>二进制 → 十进制</li></ul><p><img src="/images/HowProgramWorks/11.png" alt> </p><ul><li>移位运算：&lt;&lt; 左移低位补0 ；</li></ul><p><img src="/images/HowProgramWorks/12.png" alt> </p><ul><li>移位操作使最高位或最低位溢出的数字，直接丢弃</li></ul><p><img src="/images/HowProgramWorks/13.png" alt> </p><ul><li>移位运算：&gt;&gt; 右移（逻辑、算数）[右移要区分逻辑位移和算术位移]</li><li>二进制表示负数：最高位为符号位；0正1负</li><li>1 二进制为 00000001 ；-1 二进制为 1111111</li><li>表示负数要用“二进制的补数”，补数：用正数来表示负数[比如：1-1 可以换种形式 1+（-1）]</li><li>获得补数：将二进制数位的数值全部取反，再加1</li></ul><p><img src="/images/HowProgramWorks/14.png" alt> </p><ul><li>溢出的位，计算机直接忽略掉</li></ul><p><img src="/images/HowProgramWorks/15.png" alt> </p><p><img src="/images/HowProgramWorks/16.png" alt> </p><ul><li>0 划分为正数 ，所以负数要比正数多一个；各种数据类型都是负数多一个(比如 short -32768~32767)</li><li>逻辑右移：当二进制数的值表示图形模式的时候，移位后需要在最高位补0</li><li>算数右移：当二进制数作为带符号的数值进行运算的时候，移位后要在最高位填充移位前符号位的值（0或1）</li></ul><p><img src="/images/HowProgramWorks/17.png" alt></p><ul><li>符号扩充：保持值不变的前提下将其转换成 16 位和 32 位的二进制数</li></ul><p><img src="/images/HowProgramWorks/18.png" alt></p><ul><li>非：0变1，1变9，取反</li><li>与：两个都为1，结果为1，其他情况为0</li><li>或：只要有1，结果就为1</li><li>异或：两个数不同，结果为1，其他0</li><li>0 false ; 1 true</li></ul><h2 id="小数运算出错的原因"><a href="#小数运算出错的原因" class="headerlink" title="小数运算出错的原因"></a><center>小数运算出错的原因</center></h2><ul><li>0.1累加100次不等于10，结果为10.000002</li><li>原因是有一些十进制的小数无法转换成二进制数（和0.3333···的三倍无法得出1是一个道理）</li><li>原因：（1）采用浮点数来处理小数；（2）位溢出</li></ul><p><img src="/images/HowProgramWorks/19.png" alt></p><ul><li>计算机无法直接处理循环小数</li><li>双精度浮点数类型64位，单精度浮点数类型用32位</li></ul><p><img src="/images/HowProgramWorks/20.png" alt></p><ul><li>回避策略：（1）无视，微小误差可以忽略；（2）把小数转成整数计算 </li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a><center>内存</center></h2><ul><li>内存是 名为 内存集成电路 的电子元件</li></ul><p><img src="/images/HowProgramWorks/21.png" alt></p><ul><li>1K = 1024</li><li>+5V直流电压表示1，0V表示0</li><li>D0~D7共八个，表示一次可以输入输出8位（1字节）数据</li><li>A0~A9共十个，表示可以指定0000000000～1111111111（1024）地址</li><li>可以得出这个内存集成电路（IC）可以存储1024个1字节的数据，所以该内存IC的容量为1KB</li><li>现实中我们的内存IC会有更多的信号引脚，这样就能在一个内存IC中存储更多数据</li><li>内存IC的物理读写机制</li></ul><p><img src="/images/HowProgramWorks/22.png" alt></p><ul><li>内存逻辑模型</li></ul><p><img src="/images/HowProgramWorks/23.png" alt></p><ul><li>变量占用内存大小</li></ul><p><img src="/images/HowProgramWorks/24.png" alt></p><ul><li>指针</li></ul><p><img src="/images/HowProgramWorks/25.png" alt></p><ul><li>数组占用内存大小</li></ul><p><img src="/images/HowProgramWorks/26.png" alt></p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a><center>磁盘</center></h2><ul><li>存储程序方式：程序保存在存储设备（磁盘、内存）中，通过有序地被读取出来实现运行</li></ul><p><img src="/images/HowProgramWorks/27.png" alt></p><ul><li>磁盘缓存，把已经在磁盘读取过的数据保存到内存，下次读取同样的数据就会从内存读取</li></ul><p><img src="/images/HowProgramWorks/28.png" alt></p><ul><li>把低素设备的数据保存在高速设备中，需要时可以直接从告诉设备中读取</li><li>Web浏览器也用到了此缓存方式，把从网络获取的数据暂时保存在磁盘中，需要时再读取</li><li>磁盘缓存：把内存的一部分当作磁盘使用（实际用的是内存）</li><li>虚拟内存：把磁盘的一部分当作内存使用（实际用的是磁盘）</li><li>CPU只能执行加载到内存中的程序</li><li>虚拟内存虽说把磁盘当内存使用，但是实际正在运行的程序，这个时间点是必须存在于内存中的</li><li>所以为了实现虚拟内存，需要把 磁盘的虚拟内存里的内容 与 实际内存里的内容 进行置换</li><li>虚拟内存的方法：（1）分页式[Windows]（2）分段式</li><li>分页式，把运行的程序按照一定大小的页(windows一般情况为 4KB )进行分割；以页为单位再磁盘和内存中置换，从磁盘读入内存（Page In）,反之（Page Out）</li></ul><p><img src="/images/HowProgramWorks/29.png" alt></p><ul><li>虚拟内存可以避免因内存不足导致的应用无法启动问题，从根本上解决还是要增加内存容量</li><li>exe (executable)可执行，DLL （Dynamic Link Library）动态链接库</li></ul><h2 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a><center>压缩数据</center></h2><ul><li>文件是字节数据的集合，在任何情况下，文件的字节数据都是连续的</li></ul><p><img src="/images/HowProgramWorks/30.png" alt></p><ul><li>RLE算法（Run Length Encoding） [ 数据 X 重复次数 ]</li></ul><p><img src="/images/HowProgramWorks/31.png" alt></p><ul><li>哈夫曼算法 “出现频率高的字符用尽量少的位数编码来表示”</li><li>能够还原到压缩前状态的压缩成为可逆压缩，反之，非可逆压缩</li></ul><p><img src="/images/HowProgramWorks/32.png" alt></p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a><center>运行环境</center></h2><ul><li>运行环境 = 操作系统 + 硬件</li><li>CPU只能解释其自身固有的机器语言</li><li>不同的CPU能解释的机器语言的种类不同，例如：x86、MIPS、SPARC、PowerPC</li><li>转换成 机器语言的程序 称为 本地代码</li><li>文本文件（源代码）在任何环境都能显示和编辑</li><li>源代码 → 编译 → 本地代码（本机CPU可解释的机器语言）</li></ul><p><img src="/images/HowProgramWorks/33.png" alt></p><ul><li>MS-DOS（Microsoft Disk Operating System） → Windows</li><li>Windows 克服了大多数的硬件差异问题</li></ul><p><img src="/images/HowProgramWorks/34.png" alt></p><p><img src="/images/HowProgramWorks/35.png" alt></p><ul><li><p>应用软件必须根据操作系统类型来开发，因为操作系统类型不同，应用程序向操作系统传递指令的途径（API [Application Programming interface]）不同</p></li><li><p>移植：根据不同的运行环境来重新调整程序</p></li><li>Java → 编译 → 字节码 → 运行 → Java虚拟机 → 转换 → 本地代码</li></ul><p><img src="/images/HowProgramWorks/36.png" alt></p><ul><li>从操作系统方面来看，Java虚拟机是一个应用</li><li>从Java应用方面来看，Java虚拟机是运行环境</li><li>不同的Java虚拟机之间无法完整互换</li><li>Java程序运行速度慢，因为Java虚拟机每次运行都需要把字节码转换成本地代码</li><li>BIOS (Basic Input/Output System) , 启动 “引导程序”</li><li>引导程序 把在硬盘等记录的操作系统加载到内存中运行</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><center>编译过程</center></h2><p><img src="/images/HowProgramWorks/37.png" alt></p><ul><li>Windows中exe文件的程序内容，使用的就是本地代码</li></ul><p><img src="/images/HowProgramWorks/38.png" alt></p><ul><li>Dump：把文件的内容，每个字节用2位十六进制数来表示</li></ul><p><img src="/images/HowProgramWorks/39.png" alt></p><ul><li>编译器：将高级语言写的源代码转换成本地代码的程序</li><li>每个高级语言都有它专用的编译器，C语言 —— C编译器</li><li>CPU类型不同，本地代码的类型也不同；因此，编译器和 编程语言种类、CPU类型相关</li><li>例如：Pentium等x86系统CPU用的C编译器，和PowerPC的CPU用的C编译器是不同的</li></ul><p><img src="/images/HowProgramWorks/40.png" alt></p><ul><li>交叉编译器：生成和运行环境中的CPU不同的CPU所使用的本地代码；也就是说可以生成不同于本机CPU类型的本地代码</li></ul><p><img src="/images/HowProgramWorks/41.png" alt></p><ul><li>本地代码是无法直接运行的，需要得到可运行的exe文件，所以编译后还需要进行“链接”处理</li><li>把多个目标文件（.obj）结合，生成1个exe文件的处理就是链接</li><li>运行链接的程序 就称为 链接器</li><li>库文件:把多个目标文件集成到一个文件</li></ul><p><img src="/images/HowProgramWorks/42.png" alt></p><ul><li>内存泄漏：如果没有在程序中释放堆的内存空间，该内存空间会一直残留</li><li><p>内存泄漏如果一直存在，就有可能会造成内存不足从而导致宕机</p></li><li><p>编译器：在运行前对源代码进行解释处理</p></li><li>解释器：在运行时对源代码内容一行一行的进行解释处理</li><li>分割编译：将整个程序分成多个源代码来编写，然后分别进行编译，最后链接成一个exe文件</li></ul><h2 id="操作系统与应用"><a href="#操作系统与应用" class="headerlink" title="操作系统与应用"></a><center>操作系统与应用</center></h2><ul><li>仅具有加载和运行功能的监控程序，是操作系统的原型</li></ul><p><img src="/images/HowProgramWorks/43.png" alt></p><ul><li>随着时代发展，渐渐的把同样处理的程序集成到监控程序中</li></ul><p><img src="/images/HowProgramWorks/44.png" alt></p><ul><li>操作系统可以说是多个程序的集合体 </li></ul><p><img src="/images/HowProgramWorks/45.png" alt></p><ul><li>各种应用只是在利用操作系统的功能而已</li><li>在操作系统诞生后，就不需要再编写直接控制硬件的程序了</li><li>这样制作软件应用逐渐与硬件分离，也就解耦了；无需再考虑硬件问题，硬件问题交给操作系统去处理</li></ul><p><img src="/images/HowProgramWorks/46.png" alt></p><ul><li>高级语言不依赖特定的操作系统，使用独自的函数名，然后在编译时将其转换成相应操作系统的系统调用</li></ul><p><img src="/images/HowProgramWorks/47.png" alt></p><ul><li>操作系统和高级语言能够使硬件抽象化</li><li>文件是操作系统对磁盘媒介空间的抽象化</li></ul><p><img src="/images/HowProgramWorks/48.png" alt></p><ul><li>时钟分割：短时间间隔内，多个程序切换运行的方式；Windsows通过这种方式实现多任务功能</li></ul><p><img src="/images/HowProgramWorks/49.png" alt></p><ul><li>中间件：处于操作系统和应用的中间</li><li>系统软件：操作系统和中间件合合在一起</li></ul><p><img src="/images/HowProgramWorks/50.png" alt></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a><center>汇编</center></h2><ul><li>汇编语言的源文件 .asm （assembler）</li><li>汇编语言：使用助记符的编程语言</li><li>汇编语言源代码 → 用汇编器转换 → 本地代码</li><li>在将源代码转换成本地代码这个功能上，汇编器和编译器是同样的</li><li>汇编语言的编写的源代码，和本地代码一一对应</li></ul><p><img src="/images/HowProgramWorks/51.png" alt></p><ul><li>C语言源代码 → 编译 → 本地代码 → 反汇编 → 汇编源代码</li><li>可以通过以上反汇编的方式，分析其代码内容；一般的逆向工程</li><li>汇编语言的源代码：由 （1）转换成本地代码的指令（2）针对汇编器的伪指令 构成</li><li>伪指令负责把程序的构造和汇编的方法指示给汇编器；伪指令本身是无法汇编转换成本地代码的</li></ul><p><img src="/images/HowProgramWorks/52.png" alt></p><p><img src="/images/HowProgramWorks/53.png" alt></p><ul><li>由伪指令 segment 和 ends 围起来的部分，是给构成程序的命令和数据的集合体加上一个名字而得到的，称为 段定义</li><li>在程序中，段定义指的是命令和数据等程序的集合体的意思</li><li>段定义是一个连续的内存空间</li><li>一个程序由多个段定义构成</li><li>源代码的开始位置，定义了 3 个名称分别为 _TEXT、_DATA、_BSS的段定义</li><li>_TEXT 是指令的段定义</li><li>_DATA 是被初始化（有初始值）的数据的段定义</li><li>_BSS 是尚未初始化的数据的段定义</li><li>group这一伪指令，表示的是把_BSS 和 _DATA 这两个段定义汇总为名为 DGROUP 的组</li><li>group 指的是将源代码中不同的段定义在本地代码程序中整合为一个</li><li>围起 _AddNum 和 _MyFun 的 _TEXT segment 和 _TEXT ends，表示 _AddNum 和 _MyFunc 是属于 _TEXT 这一段定义的</li><li>_AddNum proc 和 _AddNum endp 围起来的部分，以及 _MyFunc proc 和 MyFunc endp 围 起来的部分，分别表示 AddNum 函数和 MyFunc 函数的范围</li><li>伪指令 proc 和 endp 围起来的部分，表示的是 过程（procedure）的范围；在汇编语言中，这种相当于 C 语言的函数的形式称为过程</li><li>末尾的 end 伪指令，表示的是源代码的结束</li><li>在汇编语言中，一行表示对CPU的一个指令</li><li>汇编语言指令的语法结构是操作码 + 操作数 （也存在只有操作码没有操作数的指令）</li><li>操作码表示的是指令动作，操作数表示的是指令对象</li><li>能够使用何种形式的操作码，是由 CPU 的种类决定的</li><li>32 位 x86 系列 CPU 用的操作码</li></ul><p><img src="/images/HowProgramWorks/54.png" alt></p><ul><li>本地代码加载到内存后才能运行；内存中存储着构成本地代码的指令和数据</li><li>CPU从内存中把指令和数据读出，然后由存储在CPU内部的寄存器来处理</li></ul><p><img src="/images/HowProgramWorks/55.png" alt></p><ul><li>寄存器不仅有存储指令和数据的功能，也有运算的功能</li></ul><p><img src="/images/HowProgramWorks/56.png" alt></p><ul><li>LIFO （Last In First Out）; push 入栈 ， pop 出栈</li></ul><p><img src="/images/HowProgramWorks/57.png" alt></p><h2 id="硬件控制"><a href="#硬件控制" class="headerlink" title="硬件控制"></a><center>硬件控制</center></h2><ul><li>应用通过系统调用间接控制硬件</li></ul><p><img src="/images/HowProgramWorks/58.png" alt></p><ul><li>计算机主机中附带了用来连接外部设备的连接器，各个连接器内部都有用来交换主机和外设之间电流特性的IC,这些IC（集成电路）统称为 I/O 控制器</li><li>由于电压不同，数字信号和模拟信号的电流特征不同，主机和外设无法直接连接，I/O 控制器就是用来解决此类问题的</li><li>I/O 控制器中有用于临时保存输入输出数据的内存，这个内存就是 端口 ，也称为 寄存器</li><li>I/O 寄存器主要是用来临时存储数据的，CPU内部的寄存器是用来进行运算处理的</li><li>各端口之间通过 端口号 区分，也称为 I/O 地址</li></ul><p><img src="/images/HowProgramWorks/59.png" alt></p><ul><li>IRQ(Interrupt Request) 中断请求</li><li>IRQ 是用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制，该机制称为中断处理</li></ul><p><img src="/images/HowProgramWorks/60.png" alt></p><p><img src="/images/HowProgramWorks/61.png" alt></p><ul><li>DMA(Direct Memory Access):在不通过CPU的情况下，外围设备直接和主内存进行数据传送</li></ul><p><img src="/images/HowProgramWorks/62.png" alt></p><ul><li>VRAM(Video RAM):显示器中呈现的内容信息一直存储在某内存中</li></ul><p><img src="/images/HowProgramWorks/63.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;&lt;center&gt;CPU&lt;/center&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU(Central Processing Unit)[寄存器、控制器、运算器、时钟]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/HowProgramWorks/01.png&quot; alt&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;寄存器：暂存指令、数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;控制器：把内存上的指令、数据读入寄存器，并根据结果控制计算机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运算器：运算从内存读入寄存器的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时钟：发起计时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;程序运行的过程:程序启动后,时钟开始计时,控制器从内存中读取指令和数据,运算器计算数据,控制器根据结果控制计算器&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OS" scheme="http://www.orekiyuta.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>さきざき</title>
    <link href="http://www.orekiyuta.cn/archives/Usakizaki/"/>
    <id>http://www.orekiyuta.cn/archives/Usakizaki/</id>
    <published>2020-05-21T06:04:24.000Z</published>
    <updated>2020-11-12T14:49:31.586Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>この長い長い旅のその意味を 希望をつなぐため</p></li><li><p>今隣に座るきみは 以前より少し大人に見えるよ</p></li><li><p>でも目覚めた朝 谁も居ないんだね</p></li></ul><a id="more"></a><ul><li><p>炎天下 愿った少年 「あの顷」に立っていたんだ</p></li><li><p>期待ハズレの世界の隙間 予報外れの雨が降ってきた</p></li><li><p>夢を見せたくせに 叶えれる力を与えてくれないなんて</p></li><li><p>宵街を行く人だかりは 嬉しそうだったり 寂しそうだったり</p></li><li><p>君はどんな颜だっけ　なぜだろう 思い出せないな</p></li><li><p>キミは泣いた後笑える はずだからって言ったんだ</p></li><li><p>あの日から 変わらず いつまでも変わらずに  いられなかったこと 悔しくて 指を离す</p></li><li><p>逃げ出したいと思うこの気持ちに 見つめられると呼吸もできない</p></li><li><p>振り返ってみても いないのは分かってる</p></li><li><p>空が変わり果て 星は巡ってゆく 目覚めたらすぐに 今日も歩きだそう</p></li><li><p>待っているよ 月が綺麗な夜に会おう ここにいるよ あの日のまま</p></li><li><p>いつも见ていた　近いようで远くて いつだって　届かない</p></li><li><p>言叶を知らないままならば この瞳を闭じることも 简単だったのに</p></li><li><p>少し前に进んでみよう まなざしを高く上げて</p></li><li><p>翼消えて 見えなくなっても あなたのいるところに 私がいる</p></li><li><p>飾った写真達が 笑ったまま 止めどない明日に変わらない僕たちを</p></li><li><p>と過ごせる今が このまま続けばなんて</p></li><li><p>この季節が迎えに来たら 君の姿もう探す事も 出来なくなっちゃうんだね</p></li><li><p>けど そんな出会いを 别れを 缲り返して 「今の私」よりも すてきになっていますか</p></li><li><p>君が描いた未来の世界は いつかの空に導かれて</p></li><li><p>君の描く未来に 私はいるのかな 同じ空を 同じ想いで 見上げていたいよ</p></li><li><p>见送った 手を振った ありがとう</p></li><li><p>恐いものなんかない 例え化け物になろうとも 成し遂げる</p></li><li><p>また嫌いなトコがふえた 解ってんだよ　言叶は自分自身だ</p></li><li><p>何もかも失くしても 捧げるものがあるの</p></li><li><p>いつも新しい 空を見せてあげよう</p></li><li><p>曖昧な世界を照らすような</p></li><li><p>人たちはこの空飛ぶことは叶わないけど その代わりいま流す涙は天に昇りまた 雨となり還る</p></li><li><p>この場所に ただいま言うからね</p></li><li><p>见せてやる  本当は強かった ときのこと</p></li><li><p>永遠なんて望みはしない たとえちっぽけでも構わない</p></li><li><p>でも僕は君じゃないから 伝えることしか出来なくて</p></li><li><p>そう 解っている答えなど 捨ててしまえ</p></li><li><p>孤独を捨てたって 君は君だから</p></li><li><p>目を閉じてたら気付けない事が 沢山あるんだ</p></li><li><p>小さく揺れた向日葵 サヨナラも言えないまま</p></li><li><p>離れてても 同じ空見上げて</p></li><li><p>通り過ぎていった時間の捉え方で 「現在」が変わっていく</p></li><li><p>あの瞬間 あの場面が キミにとって特別なら 過去は離れて 行くものなんかじゃなくて</p></li><li><p>振り返るともうない  僕らは何も何もまだ知らぬ</p></li><li><p>何も言はず泣けだらいいね 涙か涸れだら終わり もっと僕が强くなぃなきゃ 悲しみは自立への一步</p></li><li><p>何年前のことでしょう 二度と戻れないあの場所に 置いてきてしまったぼくの心さ</p></li><li><p>今も何度でもボクは夏の面影の中 繰り返すよ</p></li><li><p>鮮やかすぎる 君がいない夏 あの声 あの仕草が 広がってく</p></li><li><p>どしゃぶりでもかまわないと ずぶぬれでもかまわないと しぶきあげるきみが消えてく</p></li><li><p>涙がかわくまでは もう少し この雨に打たれていたくて</p></li><li><p>溢れ出したこの痛みは 全て一人で抱き締める</p></li><li><p>もういいか そんなこと 笑ってよ 終わるその日には</p></li><li><p>理想なんて もう 燃え尽きてしまったの 弱虫の耳鸣りはやまない</p></li><li><p>時の風に 流されて 落ちていく</p></li><li><p>泣いたままで あなたの頬を叩く</p></li><li><p>僕にはわかるんだ 嘘をついている君が 泣いていいよ ここにずっといるから</p></li><li><p>無邪気な時には戻れない もう二度と</p></li><li><p>心押し殺すこと それひとつだけ</p></li><li><p>アタシは弱い 弱い 弱い 涙の行方を貴方は知らない</p></li><li><p>君とあの日に残した 約束の果てに私は 透明になっていくのだろう 今更善意なんて 似合わないと思うけど</p></li><li><p>やっと見つけた　新しい朝は　月日が邪魔をする 向かう先は　次じゃなくて 過ばかり追いかけた</p></li><li><p>過去を知りたがらない瞳　洗い流してくれる指</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;この長い長い旅のその意味を 希望をつなぐため&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;今隣に座るきみは 以前より少し大人に見えるよ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;でも目覚めた朝 谁も居ないんだね&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Preliminary use Mongodb</title>
    <link href="http://www.orekiyuta.cn/archives/PreliminaryUseMongodb/"/>
    <id>http://www.orekiyuta.cn/archives/PreliminaryUseMongodb/</id>
    <published>2019-12-19T11:56:48.000Z</published>
    <updated>2020-01-01T16:07:05.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a><center>安装启动</center></h3><ul><li><code>docker pull mongo</code></li><li><code>docker run -d -p 127.0.0.1:27017:27017 --name mymongo mongo</code></li><li><code>docker exec -it mymongo mongo</code></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><center>数据库</center></h3><ul><li><code>show dbs</code></li><li><code>use elias</code> 建立数据库 elias</li><li><code>db</code> 当前所在数据库</li><li><code>db.dropDatabase()</code></li></ul><a id="more"></a><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a><center>集合</center></h3><ul><li><p><code>db.createCollection(&quot;post&quot;)</code> 建集合(表) post 👉<a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener">MongoDB 概念解析</a></p></li><li><p><code>show collections</code></p></li><li><code>db.[collectionsName].drop()</code></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a><center>文档</center></h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li><code>db.[collectionsName].insertOne()</code></li><li><code>db.[collectionsName].insert({key:&quot;value&quot;})</code></li><li>也可以把数据先赋给变量 , 再插入变量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document=(&#123;tiltle:&quot;20191220&quot;,by:&apos;elias&apos;,tag:&apos;note&apos;&#125;)</span><br><span class="line">db.[collectionsName].insert(document)</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li><p><code>db.[collectionName].updateOne({key:&quot;value&quot;} , {$set:{key:&quot;Newvalue&quot;} )</code> 符合 key=value 的文档的 key 的 value 修改为 Newvalue ; $set 如果该文档没有该域(字段) , 则会追加上去</p></li><li><p><code>db.[collectionName].updateOne({key:&quot;value&quot;} , {$set:{key:&quot;Newvalue&quot;} , {multi:true})</code> 修改多条符合条件的值</p></li><li><p><code>db.[collectionName].updateOne({key:&quot;value&quot;} , {$unset:{key:&quot;Newvalue&quot;} )</code>  删除符合 key=value 的文档的 key 域(字段)</p></li><li><p><code>db.[collectionName].updateMany()</code></p></li><li><p><code>db.[collectionName].update( {key:&quot;value&quot;},{$inc: {key2:2}} )</code> 符合 key=value 的文档的 key2 的 value 加 2</p></li><li><p><code>db.[collectionName].update( {key:&quot;value&quot;},{$mul: {key2:2}} )</code> 符合 key=value 的文档的 key2 的 value 乘 2</p></li><li><p><code>db.[collectionName].update( {key:&quot;value&quot;},{$rename: {key2:key3}} )</code> 符合 key=value 的文档的 key2 改名为 key3</p></li><li><p><code>db.[collectionName].updateOne({key:&quot;value&quot;} ,{key:&quot;value&quot;,key2:&quot;value2&quot;,...} , {upsert:true})</code> 有符合条件文档的就更新 , 没有则插入该文档</p></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><code>db.[collectionName].deleteOne()</code></li><li><code>db.[collectionName].deleteMany()</code></li></ul><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul><li><code>db.[collectionsName].find()</code> 查看文档</li><li><code>db.[collectionsName].find().pretty()</code> </li><li><code>db.[collectionsName].find()</code></li><li><code>db.[collectionsName].findOne()</code></li><li><code>db.[collectionsName].find({},{_id:0})</code> 0 查询结果不包含id , 1 反之</li><li><code>db.[collectionsName].find({key:&quot;value&quot;})</code></li><li><code>db.[collectionsName].find({key:{$gte:3}})</code> 大于等于3 <strong>$gte</strong></li><li><code>db.[collectionsName].find({key:{$gt:3}})</code> 大于 <strong>$gt</strong></li><li><code>db.[collectionsName].find({key:{$lte:3}})</code> 小于等于 <strong>$lte</strong></li><li><code>db.[collectionsName].find({key:{$lt:3}})</code> 小于 <strong>$lt</strong></li><li><code>db.[collectionsName].find({key:{$regex:&quot; &quot;}})</code> 正则表达式</li><li><code>db.[collectionsName].find({key:/ /})</code></li><li><p><code>db.[collectionsName].find({key:{$regex:&quot; &quot;},key2:{$gt:3},...,...})</code> 复合条件,筛选同时符合条件的数据</p></li><li><p><code>db.[collectionsName].find({ $or: [{key:/ /},{key2:{$gt:3}}] })</code>  筛选符合 key 或者 key2 的数据</p></li><li><p><code>db.[collectionsName].find({key:{$in : [..,..,..]}})</code> 和 select in 一样</p></li><li><code>db.[collectionsName].distinct(&quot;key&quot;)</code> 取出键所含的内容</li><li><code>db.[collectionsName].find({...}).sort({key:1})</code> 1 升序 , -1 降序</li><li><code>db.[collectionsName].find({...}).limit(3)</code> 提取前三条文档</li><li><code>db.[collectionsName].find({...}).skip(3)</code> 跳过三条文档</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a><center>索引</center></h3><ul><li><code>db.[collectionsName].getIndexes()</code> 默认索引</li><li><code>db.[collectionsName].createIndex({key:1})</code> 以 key 升序建立索引 ; -1 降序</li><li><code>db.[collectionsName].dropIndex({key:1})</code> 删除索引</li><li><code>db.[collectionsName].createIndex({key:1},{unique:true})</code> 升序唯一索引 , 之后新建文档的 key 的 value 不能与前面的重复</li></ul><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul><li><a href="https://hub.docker.com/_/mongo/?tab=description" target="_blank" rel="noopener">mongo - Docker Hub</a></li><li><a href="https://docs.mongodb.com/manual/reference/command/" target="_blank" rel="noopener">Database Commands - MongoDB Manual</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装启动&quot;&gt;&lt;a href=&quot;#安装启动&quot; class=&quot;headerlink&quot; title=&quot;安装启动&quot;&gt;&lt;/a&gt;&lt;center&gt;安装启动&lt;/center&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker pull mongo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run -d -p 127.0.0.1:27017:27017 --name mymongo mongo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec -it mymongo mongo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;&lt;center&gt;数据库&lt;/center&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show dbs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use elias&lt;/code&gt; 建立数据库 elias&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db&lt;/code&gt; 当前所在数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.dropDatabase()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mongodb" scheme="http://www.orekiyuta.cn/tags/Mongodb/"/>
    
  </entry>
  
</feed>
