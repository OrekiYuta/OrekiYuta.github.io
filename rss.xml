<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Canoe</title>
  
  <subtitle>「ろくでなし」</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://www.orekiyuta.cn/"/>
  <updated>2020-12-05T18:18:53.260Z</updated>
  <id>http://www.orekiyuta.cn/</id>
  
  <author>
    <name>Orekiyuta</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript get/set</title>
    <link href="http://www.orekiyuta.cn/archives/JSgetter-setter/"/>
    <id>http://www.orekiyuta.cn/archives/JSgetter-setter/</id>
    <published>2020-12-05T14:03:45.000Z</published>
    <updated>2020-12-05T18:18:53.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用原生-JavaScript-实现数据-单向绑定"><a href="#用原生-JavaScript-实现数据-单向绑定" class="headerlink" title="用原生 JavaScript 实现数据-单向绑定"></a>用原生 JavaScript 实现数据-单向绑定</h2><ul><li>首先得知道,在 JavaScript 中为一个对象赋值会触发对象的 set 属性方法,而获取对象则会触发 get 属性方法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">"inputurl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">"inputpost"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">"inputparam"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span> =<span class="string">"texturi"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>实现单向绑定只需要设置 get 属性方法即可</li><li>通过监听元素的 keyup 动作,然后执行方法,在方法中获取对象即可触发 get 属性方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = &#123;</span><br><span class="line">    <span class="keyword">get</span> inputValue() &#123; </span><br><span class="line">        xurl = <span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).value;</span><br><span class="line">        <span class="keyword">return</span> xurl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> post = &#123;</span><br><span class="line">    <span class="keyword">get</span> inputValue() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">    <span class="keyword">get</span> inputValue() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uri = url.inputValue + post.inputValue + param.inputValue</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = uri</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uri = url.inputValue + post.inputValue + param.inputValue</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = uri</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uri = url.inputValue + post.inputValue + param.inputValue</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = uri</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><img src="/images/JSgetter-setter/1.png" alt></li><li><img src="/images/JSgetter-setter/2.png" alt></li><li><img src="/images/JSgetter-setter/3.png" alt></li></ul><h2 id="实现数据-双向绑定-“-三绑一！？-”"><a href="#实现数据-双向绑定-“-三绑一！？-”" class="headerlink" title="实现数据-双向绑定 / “ 三绑一！？ ”"></a>实现数据-双向绑定 / “ 三绑一！？ ”</h2><ul><li>实现双向绑定就再设置 set 属性方法即可</li></ul><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = &#123;</span><br><span class="line">    <span class="keyword">get</span> inputValue() &#123; </span><br><span class="line">        xurl = <span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).value;</span><br><span class="line">        <span class="keyword">return</span> xurl;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> inputValue(newVal)&#123;     </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).value = newVal;</span><br><span class="line">        xpost = <span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).value</span><br><span class="line">        xparam = <span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).value</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = newVal + xpost + xparam;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> post = &#123;</span><br><span class="line">    <span class="keyword">get</span> inputValue() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> inputValue(newVal)&#123;     </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).value = newVal;</span><br><span class="line">        xurl = <span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).value</span><br><span class="line">        xparam = <span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).value</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = xurl + newVal + xparam;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">    <span class="keyword">get</span> inputValue() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> inputValue(newVal)&#123;     </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).value = newVal;</span><br><span class="line">        xurl = <span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).value</span><br><span class="line">        xpost = <span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).value</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = xurl + xpost + newVal;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputurl'</span>).addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uri = url.inputValue + post.inputValue + param.inputValue</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = uri</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputpost'</span>).addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uri = url.inputValue + post.inputValue + param.inputValue</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = uri</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputparam'</span>).addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uri = url.inputValue + post.inputValue + param.inputValue</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'texturi'</span>).innerHTML = uri</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>双向绑定在这里指的是 input 输入框内的值改变, p 标签的值同时也在变,并且 p 标签的值更改, input 输入框内的值也会更改</p></li><li><p>在这里直接在 console 操作 DOM 的话,并不会触发 input 的监听方法,所以数据没有同步</p></li><li><img src="/images/JSgetter-setter/4.png" alt></li><li>我们可以直接调用对象的 set 属性方法,让数据同步 </li><li><p><img src="/images/JSgetter-setter/5.png" alt></p></li><li><p>在这里值得注意的是 url 对象的名称和它 get 方法里的变量名 xurl 最好不要同名</p></li><li><img src="/images/JSgetter-setter/6.png" alt></li><li>因为从 input 输入值后,执行 url 对象的 get 方法,然后里面的变量就被初始化出来了</li><li>如果 get 方法里面的变量名和对象名一样的话,就会定位不到变量 undefined</li></ul><ul><li><p>同名的话就会出现以下问题:</p><ul><li><img src="/images/JSgetter-setter/7.png" alt></li><li>上图是未在 input 输入之前先在 console 获取了 url , 是一个对象 ,正常</li><li><img src="/images/JSgetter-setter/8.png" alt></li><li><p>然后 input 输入内容后, 再次获取 url 就是一个 undefined </p><ul><li>在此我目前猜测可能是:</li><li>(1)触发 set 属性方法后, url 对象实例化之后 变量 url 也初始化成功了,因为同时存在两个 url 名称,一个为 url 对象,一个为 url 变量,所以 DOM 操作无法分辨出应该赋值给哪个 url ,造成异常抛出,结果 url 就为初始值 undefined</li></ul></li><li><p><img src="/images/JSgetter-setter/9.png" alt></p></li><li>紧接着,上图是先在 input 输入内容后 ,再获取的 url <ul><li>结合这两张图的操作,再次猜测:</li><li>这两图的区别在于是否先在 console 里获取了 url 对象 , 可能获取 url 对象的过程是一个实例化的过程</li><li>(1)的猜想就改变了,可能在触发 set 前已经实例化了一个 url 对象,后面触发的时候 url 对象由于已有同名对象,后者 url 对象就被未实例化,因此里面的 url 就没初始化成功</li><li>(2) 上图的 url 获取到了输入内容的首个字符,多次测试后,发现获取字符也是不确定的,这里猜测在这里实例化了 url 对象,之后 url 变量把 url 对象给覆盖了</li><li>这里可能要对浏览器执行过程,加载 DOM 和操作系统有更深的理解才能有结果</li></ul></li></ul></li></ul><h3 id="对象调用"><a href="#对象调用" class="headerlink" title="对象调用"></a>对象调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> inputurl = <span class="built_in">document</span>.getElementById(<span class="string">"inputurl"</span>);</span><br><span class="line"><span class="keyword">var</span> inputpost = <span class="built_in">document</span>.getElementById(<span class="string">"inputpost"</span>);</span><br><span class="line"><span class="keyword">var</span> inputparam = <span class="built_in">document</span>.getElementById(<span class="string">"inputparam"</span>);</span><br><span class="line"><span class="keyword">var</span> texturi = <span class="built_in">document</span>.getElementById(<span class="string">"texturi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">"inputurl"</span>:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function(newVal)&#123;</span><br><span class="line">            inputurl.value = newVal;</span><br><span class="line">            texturi.innerHTML = newVal;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newVal)&#123;</span><br><span class="line"></span><br><span class="line">            inputurl.value = newVal.url;</span><br><span class="line">            texturi.innerHTML = newVal.uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"inputpost"</span>:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function(newVal)&#123;</span><br><span class="line">            inputpost.value = newVal;</span><br><span class="line">            texturi.innerHTML = newVal;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newVal)&#123;</span><br><span class="line"></span><br><span class="line">            inputpost.value = newVal.post;</span><br><span class="line">            texturi.innerHTML = newVal.uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"inputparam"</span>:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function(newVal)&#123;</span><br><span class="line">            inputparam.value = newVal;</span><br><span class="line">            texturi.innerHTML = newVal;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newVal)&#123;</span><br><span class="line">            inputparam.value = newVal.param;</span><br><span class="line">            texturi.innerHTML = newVal.uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">inputurl.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    inputuri = e.target.value + inputpost.value + inputparam.value;</span><br><span class="line">    obj.inputurl = &#123;<span class="attr">uri</span>:inputuri , <span class="attr">url</span>:e.target.value&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">inputpost.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    inputuri = inputurl.value + e.target.value + inputparam.value;</span><br><span class="line">    obj.inputpost = &#123;<span class="attr">uri</span>:inputuri , <span class="attr">post</span>:e.target.value&#125;</span><br><span class="line">&#125;);</span><br><span class="line">inputparam.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    inputuri = inputurl.value + inputpost.value + e.target.value;</span><br><span class="line">    obj.inputparam = &#123;<span class="attr">uri</span>:inputuri , <span class="attr">param</span>:e.target.value&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>在这里的话,问题就在于 set 属性方法只能传递一个值,因此可以通过传对象去传多个值</li><li><img src="/images/JSgetter-setter/10.png" alt></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://segmentfault.com/a/1190000003882976" target="_blank" rel="noopener">浅谈 JS 对象添加 getter与 setter 的5种方法以及如何让对象属性不可配置或枚举</a></li><li><a href="https://www.imooc.com/qadetail/125923" target="_blank" rel="noopener">set方法只能接受一个参数吗？</a></li><li><a href="https://www.codenong.com/5815757/" target="_blank" rel="noopener">关于javascript：为什么这个函数用括号括起来，后面跟着括号？</a></li><li><a href="https://www.codenong.com/8228281/" target="_blank" rel="noopener">关于iife：javascript中的 (function() { } )() 构造是什么？</a></li><li><a href="https://stackoverflow.com/questions/39718122/javascript-addeventlistener-input-versus-keyup" target="_blank" rel="noopener">JavaScript addEventListener : ‘input’ versus ‘keyup’ [duplicate]</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用原生-JavaScript-实现数据-单向绑定&quot;&gt;&lt;a href=&quot;#用原生-JavaScript-实现数据-单向绑定&quot; class=&quot;headerlink&quot; title=&quot;用原生 JavaScript 实现数据-单向绑定&quot;&gt;&lt;/a&gt;用原生 JavaScript 实现数据-单向绑定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先得知道,在 JavaScript 中为一个对象赋值会触发对象的 set 属性方法,而获取对象则会触发 get 属性方法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;inputurl&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;inputpost&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;inputparam&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt; =&lt;span class=&quot;string&quot;&gt;&quot;texturi&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;实现单向绑定只需要设置 get 属性方法即可&lt;/li&gt;
&lt;li&gt;通过监听元素的 keyup 动作,然后执行方法,在方法中获取对象即可触发 get 属性方法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; inputValue() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xurl = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;inputurl&#39;&lt;/span&gt;).value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; xurl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; post = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; inputValue() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;inputpost&#39;&lt;/span&gt;).value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; param = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; inputValue() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;inputparam&#39;&lt;/span&gt;).value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;inputurl&#39;&lt;/span&gt;).addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;keyup&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uri = url.inputValue + post.inputValue + param.inputValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;texturi&#39;&lt;/span&gt;).innerHTML = uri&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;inputpost&#39;&lt;/span&gt;).addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;keyup&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uri = url.inputValue + post.inputValue + param.inputValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;texturi&#39;&lt;/span&gt;).innerHTML = uri&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;inputparam&#39;&lt;/span&gt;).addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;keyup&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uri = url.inputValue + post.inputValue + param.inputValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;texturi&#39;&lt;/span&gt;).innerHTML = uri&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://www.orekiyuta.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>One Line</title>
    <link href="http://www.orekiyuta.cn/archives/OneLine/"/>
    <id>http://www.orekiyuta.cn/archives/OneLine/</id>
    <published>2020-12-02T13:04:30.000Z</published>
    <updated>2020-12-02T16:31:20.118Z</updated>
    
    <content type="html"><![CDATA[<ul><li>We’ve always fooled around together since we were kids.<ul><li>We’ve shared the most exciting moments, but every story has an end.</li><li>No one can stay a kid forever.</li><li>Time moves on, and people grow up.</li><li>We must go our separate ways.</li><li>You keep going even after Im gone.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;We’ve always fooled around together since we were kids.&lt;ul&gt;
&lt;li&gt;We’ve shared the most exciting moments, but every story has an end.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java:Thread.Start() / run()</title>
    <link href="http://www.orekiyuta.cn/archives/javastartrun/"/>
    <id>http://www.orekiyuta.cn/archives/javastartrun/</id>
    <published>2020-11-30T15:19:22.000Z</published>
    <updated>2020-11-30T16:43:00.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的启动顺序"><a href="#线程的启动顺序" class="headerlink" title="线程的启动顺序"></a>线程的启动顺序</h2><ul><li><img src="/images/JavaStartRun/1.png" alt></li><li>testThread 线程实例创建之后,调用 start(),表明这个线程处于就绪状态,等待得到 CPU 的时间片之后才会执行</li><li>因为 main 方法也是一个线程,所以 testThread 会等待 main() 执行完毕</li><li>main() 执行完毕后，testThread 线程得到 CPU 的时间片,开始执行<a id="more"></a></li><li><img src="/images/JavaStartRun/2.png" alt></li><li>当 testThread 启动时，它的状态 threadStatus 被设置为 0 ,然后加入线程组 group</li><li><img src="/images/JavaStartRun/3.png" alt></li><li>最后调用 start0()，而 start0() 是私有的 native 方法（Native Method 是一个 java 调用非 java 代码的接口）</li><li>调用完毕后，testThread 线程就处于就绪状态,获得 CPU 时间之后就会调用 thread 的 run()</li><li><img src="/images/JavaStartRun/5.png" alt></li><li><img src="/images/JavaStartRun/4.png" alt></li><li><img src="/images/JavaStartRun/6.png" alt></li></ul><h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><ul><li><img src="/images/JavaStartRun/7.png" alt></li><li>thread.run() 会等待 thread 里面的 run() 执行完毕后才会执行;直接调用 run() 这样的用法就和调用普通方法一样,其实并没有创建新的线程</li><li><img src="/images/JavaStartRun/8.png" alt></li><li>thread.start() 就会创建新的线程,然后处于就绪状态;让主线程先执行完毕,再轮到自己</li></ul><h3 id="run-的好处"><a href="#run-的好处" class="headerlink" title="run() 的好处"></a>run() 的好处</h3><ul><li>实现了 Runnable 接口的方法 run() ,之后就可以让多个线程调用 run() 共享同一个资源</li><li>实现 Runnable 接口相对于继承 Thread 类来说,可以避免 Java 单继承的局限性</li><li>start()被多次调用也还是一个线程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程的启动顺序&quot;&gt;&lt;a href=&quot;#线程的启动顺序&quot; class=&quot;headerlink&quot; title=&quot;线程的启动顺序&quot;&gt;&lt;/a&gt;线程的启动顺序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/images/JavaStartRun/1.png&quot; alt&gt;&lt;/li&gt;
&lt;li&gt;testThread 线程实例创建之后,调用 start(),表明这个线程处于就绪状态,等待得到 CPU 的时间片之后才会执行&lt;/li&gt;
&lt;li&gt;因为 main 方法也是一个线程,所以 testThread 会等待 main() 执行完毕&lt;/li&gt;
&lt;li&gt;main() 执行完毕后，testThread 线程得到 CPU 的时间片,开始执行
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSS margin:auto;How it Works</title>
    <link href="http://www.orekiyuta.cn/archives/css-margin-auto/"/>
    <id>http://www.orekiyuta.cn/archives/css-margin-auto/</id>
    <published>2020-11-30T02:53:25.000Z</published>
    <updated>2020-11-30T13:33:29.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Auto"><a href="#Auto" class="headerlink" title="Auto"></a>Auto</h2><ul><li>margin:auto 通常用作元素水平居中</li><li>首先得知道，在定义中 auto 可以随着元素、元素类型和上下文而变化<ul><li>在 margins 中，auto 可以占用可用空间或者占用 0 px</li></ul></li></ul><h2 id="margin-水平空间"><a href="#margin-水平空间" class="headerlink" title="margin 水平空间"></a>margin 水平空间</h2><ul><li>对于 margins , auto 作为 left 和 right 的值的时候，它们会在水平上均分可用空间，因此它们使得元素在中心</li><li><p>但是它们也仅仅适用于水平 margins , 并不能和带有 float、inline 的元素共用；也不适用在 absolute 和 fixed position 的元素中</p></li><li><p>当只给 margin 其中一边设置为 auto 时，该元素会向另一边倾向</p><ul><li>当 margin-left:auto 时，元素的左边会空出一定的空间，而右边空间被元素占完<a id="more"></a></li></ul></li><li><p>正如前面所说， auto 无法使用在 floated ,inline 和 absolute的元素中，因为它们的布局已经被决定了，所以无法用 margin:auto 使元素居中</p><ul><li>如果设置 margin:auto 的话，结果就为 margin:0px</li></ul></li><li><p>auto 对于没有宽度的 block 元素也不起作用</p></li></ul><h2 id="margin-垂直空间"><a href="#margin-垂直空间" class="headerlink" title="margin 垂直空间"></a>margin 垂直空间</h2><ul><li>auto 在 margin 的 top 和 bottom 上始终计算为 0px (除了 absolute 元素)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W3C spec says it like this:</span><br><span class="line"></span><br><span class="line">“If “margin-top” or “margin-bottom” is “auto”, their used value is 0″</span><br></pre></td></tr></table></figure><ul><li><p>👉<a href="https://www.w3.org/TR/CSS21/visudet.html#Computing_heights_and_margins" target="_blank" rel="noopener">10 Visual formatting model details</a></p></li><li><p>也可能是垂直页面流的原因，使得元素在页面垂直方向上不居中，因为页面大小会随着高度方向增加</p></li><li>但是 absolute 元素可以使得该元素沿着整个页面的高度垂直居中</li></ul><h2 id="绝对元素居中定位"><a href="#绝对元素居中定位" class="headerlink" title="绝对元素居中定位"></a>绝对元素居中定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is where another W3C spec comes in:</span><br><span class="line"></span><br><span class="line">&quot;If all three of “left”, “width”, and “right” are “auto”: First set any “auto” values for “margin-left” and “margin-right” to 0… &quot;</span><br><span class="line"></span><br><span class="line">&quot;If none of the three is “auto”: If both “margin-left” and “margin-right” are “auto”, solve the equation under the extra constraint that the two margins get equal values&quot;</span><br></pre></td></tr></table></figure><ul><li>说明水平 auto margins 要占用一样的空间，它们的left,width和right都不应该是 auto</li><li>因此我们要在一个绝对定位的元素中给它们一些值，使得水平居中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The spec also mentions something similar for vertical margins.</span><br><span class="line"></span><br><span class="line">“If all three of “top”, “height”, and “bottom” are auto, set “top” to the static position…”</span><br><span class="line"></span><br><span class="line">“If none of the three are “auto”: If both “margin-top” and “margin-bottom” are “auto”, solve the equation under the extra constraint that the two margins get equal values…”</span><br></pre></td></tr></table></figure><ul><li>要使得绝对元素垂直居中，它的 top,height,bottom的值都不能为 auto</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>如果想要某个元素向左或者向右靠，可以设置另一边的 margin:auto</li><li><p>可以将某个元素转为绝对定位使其垂直居中，但是这不是个好方法</p><ul><li>用 flexbox 和 CSS transform 可能更适合</li></ul></li><li><p>👉<a href="https://www.hongkiat.com/blog/css-margin-auto/" target="_blank" rel="noopener">https://www.hongkiat.com/blog/css-margin-auto/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Auto&quot;&gt;&lt;a href=&quot;#Auto&quot; class=&quot;headerlink&quot; title=&quot;Auto&quot;&gt;&lt;/a&gt;Auto&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;margin:auto 通常用作元素水平居中&lt;/li&gt;
&lt;li&gt;首先得知道，在定义中 auto 可以随着元素、元素类型和上下文而变化&lt;ul&gt;
&lt;li&gt;在 margins 中，auto 可以占用可用空间或者占用 0 px&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;margin-水平空间&quot;&gt;&lt;a href=&quot;#margin-水平空间&quot; class=&quot;headerlink&quot; title=&quot;margin 水平空间&quot;&gt;&lt;/a&gt;margin 水平空间&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于 margins , auto 作为 left 和 right 的值的时候，它们会在水平上均分可用空间，因此它们使得元素在中心&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是它们也仅仅适用于水平 margins , 并不能和带有 float、inline 的元素共用；也不适用在 absolute 和 fixed position 的元素中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当只给 margin 其中一边设置为 auto 时，该元素会向另一边倾向&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 margin-left:auto 时，元素的左边会空出一定的空间，而右边空间被元素占完
    
    </summary>
    
    
    
      <category term="CSS" scheme="http://www.orekiyuta.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Java Notes</title>
    <link href="http://www.orekiyuta.cn/archives/JavaNotes/"/>
    <id>http://www.orekiyuta.cn/archives/JavaNotes/</id>
    <published>2020-11-27T13:01:21.000Z</published>
    <updated>2020-12-01T17:26:43.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组内存分配和引用"><a href="#数组内存分配和引用" class="headerlink" title="数组内存分配和引用"></a>数组内存分配和引用</h3><ul><li><img src="/images/JavaNotes/1.png" alt><a id="more"></a></li><li><img src="/images/JavaNotes/2.png" alt></li><li><img src="/images/JavaNotes/3.png" alt></li><li><img src="/images/JavaNotes/4.png" alt></li><li><img src="/images/JavaNotes/5.png" alt></li><li><img src="/images/JavaNotes/6.png" alt></li><li><img src="/images/JavaNotes/7.png" alt></li><li><img src="/images/JavaNotes/8.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组内存分配和引用&quot;&gt;&lt;a href=&quot;#数组内存分配和引用&quot; class=&quot;headerlink&quot; title=&quot;数组内存分配和引用&quot;&gt;&lt;/a&gt;数组内存分配和引用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/images/JavaNotes/1.png&quot; alt&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Windows Setting</title>
    <link href="http://www.orekiyuta.cn/archives/WindowsSetting/"/>
    <id>http://www.orekiyuta.cn/archives/WindowsSetting/</id>
    <published>2020-11-14T08:49:01.000Z</published>
    <updated>2020-12-09T15:08:34.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Win10-LTSB-Add-MicrosoftStore"><a href="#Win10-LTSB-Add-MicrosoftStore" class="headerlink" title="Win10 LTSB Add MicrosoftStore"></a>Win10 LTSB Add MicrosoftStore</h3><ul><li>To : <a href="https://github.com/kkkgo/LTSB-Add-MicrosoftStore" target="_blank" rel="noopener">LTSB-Add-MicrosoftStore</a></li><li>Run: Add-Store.cmd<a id="more"></a><img src="/images/Windows/Win10LTSBAddMicrosoftStore/Snipaste_2020-11-14_16-53-39.png" alt></li></ul><h3 id="Windows-show-Windows-File"><a href="#Windows-show-Windows-File" class="headerlink" title="Windows show Windows/File"></a>Windows show Windows/File</h3><ul><li><code>explorer .</code></li><li><code>explorer ..</code></li><li><code>explorer [dirName]</code></li><li><code>start .</code><br><img src="/images/Windows/Explorer/Snipaste_2020-11-14_17-06-31.png" alt></li></ul><h3 id="Desktop-Context-Menu"><a href="#Desktop-Context-Menu" class="headerlink" title="Desktop Context Menu"></a>Desktop Context Menu</h3><ul><li><code>计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</code></li><li><img src="/images/Windows/DesktopContextMenu/Snipaste_2020-11-24_22-36-36.png" alt></li><li><img src="/images/Windows/DesktopContextMenu/Snipaste_2020-11-24_22-35-15.png" alt></li><li><img src="/images/Windows/DesktopContextMenu/Snipaste_2020-11-24_22-40-14.png" alt></li></ul><h3 id="DOS-Clean"><a href="#DOS-Clean" class="headerlink" title="DOS Clean"></a>DOS Clean</h3><ul><li><code>cls</code></li></ul><h3 id="Netstat-Find-Kill"><a href="#Netstat-Find-Kill" class="headerlink" title="Netstat Find/Kill"></a>Netstat Find/Kill</h3><ul><li><p><code>netstat -ano|findstr 8000</code>  查看占用8000端口的进程</p></li><li><p><code>tasklist | findstr 8608</code> 查看进程的信息</p></li><li><p><code>taskkill /pid 8608 /f</code>  关闭进程</p></li></ul><p><img src="/images/Windows/Netstat/Snipaste_2020-05-23_13-23-00.png" alt></p><h3 id="Install-Chocolatey"><a href="#Install-Chocolatey" class="headerlink" title="Install Chocolatey"></a>Install Chocolatey</h3><ul><li>At PowerShell<ul><li><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))</code></li></ul></li><li><a href="https://chocolatey.org/install" target="_blank" rel="noopener">https://chocolatey.org/install</a></li><li>At CMD<ul><li><code>@powershell Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))</code></li></ul></li></ul><h3 id="bat-Get-admin"><a href="#bat-Get-admin" class="headerlink" title=".bat Get admin"></a>.bat Get admin</h3><ul><li><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">NUL</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> REG.exe query "HKU\S-<span class="number">1</span>-<span class="number">5</span>-<span class="number">19</span>" || (</span><br><span class="line">    <span class="built_in">ECHO</span> <span class="built_in">SET</span> UAC = CreateObject^("Shell.Application"^) &gt; "<span class="variable">%TEMP%</span>\Getadmin.vbs"</span><br><span class="line">    <span class="built_in">ECHO</span> UAC.ShellExecute "%~f0", "%<span class="number">1</span>", "", "runas", <span class="number">1</span> &gt;&gt; "<span class="variable">%TEMP%</span>\Getadmin.vbs"</span><br><span class="line">    "<span class="variable">%TEMP%</span>\Getadmin.vbs"</span><br><span class="line">    <span class="built_in">DEL</span> /f /q "<span class="variable">%TEMP%</span>\Getadmin.vbs" <span class="number">2</span>&gt;<span class="built_in">NUL</span></span><br><span class="line">    <span class="keyword">Exit</span> /b</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> "<span class="variable">%SYSTEMROOT%</span>\system32\<span class="built_in">cacls</span>.exe" "<span class="variable">%SYSTEMROOT%</span>\system32\config\system"</span><br><span class="line"><span class="keyword">if</span> '<span class="variable">%errorlevel%</span>' <span class="keyword">NEQ</span> '<span class="number">0</span>' (</span><br><span class="line"><span class="keyword">goto</span> UACPrompt</span><br><span class="line">) <span class="keyword">else</span> ( <span class="keyword">goto</span> gotAdmin )</span><br><span class="line">:UACPrompt</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> UAC = CreateObject^("Shell.Application"^) &gt; "<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line"><span class="built_in">echo</span> UAC.ShellExecute "%~s0", "", "", "runas", <span class="number">1</span> &gt;&gt; "<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line">"<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line"><span class="keyword">exit</span> /B</span><br><span class="line">:gotAdmin</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> "<span class="variable">%temp%</span>\getadmin.vbs" ( <span class="built_in">del</span> "<span class="variable">%temp%</span>\getadmin.vbs" )</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nslookup"><a href="#Nslookup" class="headerlink" title="Nslookup"></a>Nslookup</h2><ul><li><code>nslookup www.baidu.com</code> 查看域名当前 IP<h2 id="Net-user"><a href="#Net-user" class="headerlink" title="Net user"></a>Net user</h2></li><li><code>net user</code> 查看当前计算机用户名<h2 id="Arp-a"><a href="#Arp-a" class="headerlink" title="Arp -a"></a>Arp -a</h2></li><li><code>arp -a</code> 查看当前局域网内的所有 IP<h2 id="Net-share"><a href="#Net-share" class="headerlink" title="Net share"></a>Net share</h2></li><li><code>net share</code> 查看本机上的共享资源</li><li><code>net share [name]/delete</code> 删除共享资源</li></ul><h2 id="Netsh-wlan"><a href="#Netsh-wlan" class="headerlink" title="Netsh wlan"></a>Netsh wlan</h2><ul><li><code>netsh wlan show profile [wlanName] key=clear</code> 查看已连接 Wi-Fi 的详细信息，包含密码</li></ul><h2 id><a href="#" class="headerlink" title="|"></a>|</h2><ul><li><code>ipconfig | clip</code> 将结果输出到剪贴板</li></ul><h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><ul><li><code>ipconfig &amp;&amp; arp -a</code> 连接多个命令，只有前面一个执行成功，后面的才执行</li><li>&amp; 一个一个执行</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Win10-LTSB-Add-MicrosoftStore&quot;&gt;&lt;a href=&quot;#Win10-LTSB-Add-MicrosoftStore&quot; class=&quot;headerlink&quot; title=&quot;Win10 LTSB Add MicrosoftStore&quot;&gt;&lt;/a&gt;Win10 LTSB Add MicrosoftStore&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;To : &lt;a href=&quot;https://github.com/kkkgo/LTSB-Add-MicrosoftStore&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LTSB-Add-MicrosoftStore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Run: Add-Store.cmd
    
    </summary>
    
    
    
      <category term="Windows" scheme="http://www.orekiyuta.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Java GenericTypes</title>
    <link href="http://www.orekiyuta.cn/archives/JavaGenericTypes/"/>
    <id>http://www.orekiyuta.cn/archives/JavaGenericTypes/</id>
    <published>2020-11-10T11:53:11.000Z</published>
    <updated>2020-11-11T15:41:09.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类,是在实例化类的时候, 指明 泛型的具体类型</p><h3 id="泛型的类型参数不支持基本类型-只能是类对象类型"><a href="#泛型的类型参数不支持基本类型-只能是类对象类型" class="headerlink" title="泛型的类型参数不支持基本类型,只能是类对象类型"></a>泛型的类型参数不支持基本类型,只能是类对象类型</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;<span class="keyword">int</span>&gt; genericl = <span class="keyword">new</span> Generic&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);          <span class="comment">// ❌</span></span><br><span class="line">Generic&lt;Integer&gt; genericl = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">100</span>);  <span class="comment">// ✔</span></span><br></pre></td></tr></table></figure></li></ul><p>👉<a href="https://qastack.cn/programming/2721546/why-dont-java-generics-support-primitive-types" target="_blank" rel="noopener">为什么Java泛型不支持基本类型？</a></p><ul><li>主要是为了向后兼容<a id="more"></a></li></ul><h3 id="泛型类在创建对象的时候-没有指定类型的话-将默认指定为-Object-类型"><a href="#泛型类在创建对象的时候-没有指定类型的话-将默认指定为-Object-类型" class="headerlink" title="泛型类在创建对象的时候,没有指定类型的话,将默认指定为 Object 类型"></a>泛型类在创建对象的时候,没有指定类型的话,将默认指定为 Object 类型</h3><p><img src="/images/JavaGenericTypes/1.png" alt></p><ul><li>由于 基本数据类型 不继承自 Object 因此, 泛型参数不支持基本类型</li><li>除了8种基本数据类型(byte,short,int,long,float,double,char,boolean)以外都是 Object 的子类</li></ul><h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p><img src="/images/JavaGenericTypes/2.png" alt></p><ul><li><code>Object object = 1;</code> 没有编译问题,因为在赋值过程种自动装箱;</li><li>8种基本类型都有对应的包装数据类型</li><li>上图运行结果可见,经过了自动装箱</li></ul><h3 id="由同一泛型类-创建的不同数据类型的对象-本质上是同一类型"><a href="#由同一泛型类-创建的不同数据类型的对象-本质上是同一类型" class="headerlink" title="由同一泛型类,创建的不同数据类型的对象,本质上是同一类型"></a>由同一泛型类,创建的不同数据类型的对象,本质上是同一类型</h3><p><img src="/images/JavaGenericTypes/3.png" alt></p><ul><li><code>stringGeneric.getClass() == integerGeneric.getClass()</code>结果为 true , 说明内存地址相同</li></ul><h3 id="子类是泛型类的话-子类要和父类的泛型类型保持一致"><a href="#子类是泛型类的话-子类要和父类的泛型类型保持一致" class="headerlink" title="子类是泛型类的话,子类要和父类的泛型类型保持一致"></a>子类是泛型类的话,子类要和父类的泛型类型保持一致</h3><ul><li><code>class ChildGeneric&lt;T&gt; extends Generic&lt;T&gt;</code></li><li>由子类来决定具体类型,就是调用的时候来指定的</li></ul><p><img src="/images/JavaGenericTypes/4.png" alt></p><ul><li><code>class ChildGeneric&lt;T,E,k&gt; extends Generic&lt;T&gt;</code> 可以多个类型,但是至少保证一个类型和父类一致</li></ul><h3 id="子类不是泛型类-父类要明确泛型的数据类型"><a href="#子类不是泛型类-父类要明确泛型的数据类型" class="headerlink" title="子类不是泛型类,父类要明确泛型的数据类型"></a>子类不是泛型类,父类要明确泛型的数据类型</h3><ul><li><code>class ChildGeneric extends Generic&lt;Integer&gt;</code></li></ul><p><img src="/images/JavaGenericTypes/5.png" alt></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h3 id="泛型接口的实现类是泛型类-实现类和接口的泛型类型要保持一致"><a href="#泛型接口的实现类是泛型类-实现类和接口的泛型类型要保持一致" class="headerlink" title="泛型接口的实现类是泛型类,实现类和接口的泛型类型要保持一致"></a>泛型接口的实现类是泛型类,实现类和接口的泛型类型要保持一致</h3><p><img src="/images/JavaGenericTypes/7.png" alt></p><h3 id="泛型接口的实现类不是泛型类-接口要明确数据类型"><a href="#泛型接口的实现类不是泛型类-接口要明确数据类型" class="headerlink" title="泛型接口的实现类不是泛型类,接口要明确数据类型"></a>泛型接口的实现类不是泛型类,接口要明确数据类型</h3><p><img src="/images/JavaGenericTypes/6.png" alt></p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法,是在调用方法的时候, 指明 泛型的具体类型</p><ul><li>前面的例子中 那些诸如 <code>public E getValue() {}</code> 只是普通的成员方法,并不是泛型方法</li><li>只有声明了 <code>&lt;T&gt;</code> 的方法才是泛型方法 , T 可以是其他符号（E,K…）</li></ul><p><img src="/images/JavaGenericTypes/8.png" alt></p><ul><li>泛型方法独立于类存在</li><li>即使 泛型方法的标识符和类标识符一致,泛型方法的类型取决于调用时候的类型</li><li>下图可以和上图做比较,可得出结论</li></ul><p><img src="/images/JavaGenericTypes/9.png" alt></p><ul><li>泛型方法 和 泛型类里面的成员方法 的区别在于:泛型方法的类型取决于调用时的类型;泛型类里面的成员方法在使用的时候,必须遵从泛型类的类型</li></ul><h3 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h3><ul><li>泛型类里面的成员方法 不能声明为静态 </li><li>泛型方法独立于类的存在,可以声明为静态</li></ul><p><img src="/images/JavaGenericTypes/10.png" alt></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><img src="/images/JavaGenericTypes/11.png" alt></p><h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p><img src="/images/JavaGenericTypes/12.png" alt></p><ul><li>按照多态思想, Integer 继承于 Number , 但是对泛型类型来说不适用</li></ul><p><img src="/images/JavaGenericTypes/13.png" alt></p><ul><li>顺着思路,尝试重载,但是依然不行;同理 <code>Box&lt;Object&gt;</code> 同样不行</li><li>因为,前面说过了; <code>Box&lt;Number&gt; box</code>和<code>Box&lt;Integer&gt; box</code> 本质上都是 <code>Box&lt;E&gt;</code>;所以这两个是同一个方法</li></ul><p><img src="/images/JavaGenericTypes/14.png" alt></p><ul><li>因此为了解决这个问题,引入了通配符<code>?</code></li></ul><p><img src="/images/JavaGenericTypes/15.png" alt></p><h3 id="上限"><a href="#上限" class="headerlink" title="上限"></a>上限</h3><ul><li><code>Box&lt;? extends Number&gt;</code> 指可以传 继承于 Number 的所有子类,最高上限传 Number</li></ul><p><img src="/images/JavaGenericTypes/16.png" alt></p><p><img src="/images/JavaGenericTypes/17.png" alt></p><ul><li>这里不允许添加元素,因为确定不了类型</li></ul><p><img src="/images/JavaGenericTypes/18.png" alt></p><ul><li>ArrayList 里面的 addAll() 就用了 上限通配符</li></ul><p><img src="/images/JavaGenericTypes/19.png" alt></p><p><img src="/images/JavaGenericTypes/20.png" alt></p><h3 id="下限"><a href="#下限" class="headerlink" title="下限"></a>下限</h3><ul><li>类/接口&lt;? super 实参类型&gt;</li><li>要求该泛型的类型，只能是实参类型，或实参类型的 父类类型</li></ul><p><img src="/images/JavaGenericTypes/21.png" alt></p><ul><li><p>遍历元素下限通配符元素的时候,拿 0bject 类型,因为无论是 Cat 还是所有的父类,都来自于 Object</p></li><li><p>这里可以添加元素,但是不保证元素数据类型的约束要求<br><img src="/images/JavaGenericTypes/22.png" alt></p></li></ul><p><img src="/images/JavaGenericTypes/23.png" alt></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cat.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MiniCat.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiniCat</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MiniCat&#123;"</span> +</span><br><span class="line">                <span class="string">"level="</span> + level +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mian.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Cat&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator2());</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Ami"</span>,<span class="number">13</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Bie"</span>,<span class="number">25</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Cna"</span>,<span class="number">34</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Dji"</span>,<span class="number">52</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Cat(<span class="string">"Ewa"</span>,<span class="number">11</span>));</span><br><span class="line">        <span class="keyword">for</span> (Cat cat : treeSet) &#123;</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator1</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Animal o1, Animal o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator2</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Cat</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cat o1, Cat o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator3</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">MiniCat</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MiniCat o1, MiniCat o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.level - o2.level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/JavaGenericTypes/24.png" alt></p><ul><li><code>TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator2());</code> 根据年龄比较排序</li><li><p><code>TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator1());</code> 根据名字比较排序</p></li><li><p><code>TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator3());</code> 在下限 Cat 以下, MiniCat 达不到下限</p></li></ul><p><img src="/images/JavaGenericTypes/25.png" alt></p><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是泛型代码能够很好地和之前版本的代码兼容。</p><p>那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为–类型擦除。</p><ul><li>在前面的例子中，判断过泛型是否相等<ul><li>由同一泛型类,创建的不同数据类型的对象,本质上是同一类型 </li><li><code>stringGeneric.getClass() == integerGeneric.getClass()</code>结果为 true ,其实说明了这点</li><li>在进入JVM之前，与泛型相关的信息会被擦除掉</li><li><img src="/images/JavaGenericTypes/26.png" alt></li><li>在运行结果出来的时候,两者是相等的,说明了编译期间会把泛型的类型给移除掉</li></ul></li></ul><h3 id="无限制类型擦除"><a href="#无限制类型擦除" class="headerlink" title="无限制类型擦除"></a>无限制类型擦除</h3><p>泛型 T 在运行的时候,会被解释成 Object;就相当于用 Object 来代替</p><p><img src="/images/JavaGenericTypes/27.png" alt></p><p><img src="/images/JavaGenericTypes/28.png" alt></p><h3 id="有限制类型擦除"><a href="#有限制类型擦除" class="headerlink" title="有限制类型擦除"></a>有限制类型擦除</h3><p>将 泛型 T 转换成 上限类型 Number<br><img src="/images/JavaGenericTypes/29.png" alt></p><p><img src="/images/JavaGenericTypes/30.png" alt></p><h3 id="擦除-方法中类型定义的参数"><a href="#擦除-方法中类型定义的参数" class="headerlink" title="擦除 方法中类型定义的参数"></a>擦除 方法中类型定义的参数</h3><p>前面的是擦除 泛型类 的类型;这里是擦除 泛型方法 的类型</p><p><img src="/images/JavaGenericTypes/31.png" alt></p><p><img src="/images/JavaGenericTypes/32.png" alt></p><h3 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h3><p>接口定义 T 转成 Object ; 实现类 Integer 还是 Integer</p><p>只是多个了桥接; 为了保持编译后的接口和实现关系</p><p><img src="/images/JavaGenericTypes/33.png" alt></p><p><img src="/images/JavaGenericTypes/34.png" alt></p><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><h3 id="可以创建带泛型的数组引用，但是不能-直接-创建带泛型的-数组对象"><a href="#可以创建带泛型的数组引用，但是不能-直接-创建带泛型的-数组对象" class="headerlink" title="可以创建带泛型的数组引用，但是不能 直接 创建带泛型的 数组对象"></a>可以创建带泛型的数组引用，但是不能 直接 创建带泛型的 数组对象</h3><p><img src="/images/JavaGenericTypes/35.png" alt></p><p><img src="/images/JavaGenericTypes/36.png" alt></p><p>跳过原生 ArrayList 对象引用; 直接将 原生ArrayList 数组 赋给 泛型ArrayList; 后面就有类型检查</p><p><img src="/images/JavaGenericTypes/37.png" alt></p><p><img src="/images/JavaGenericTypes/38.png" alt></p><p>主要是因为泛型在编译的时候会做类型擦除，而数组会一直保持它的初始类型</p><h3 id="可以通过-java-lang-reflect-Array-的-newInstance-Class-int-创建-T-数组"><a href="#可以通过-java-lang-reflect-Array-的-newInstance-Class-int-创建-T-数组" class="headerlink" title="可以通过 java.lang.reflect.Array 的 newInstance(Class,int) 创建 T[] 数组"></a>可以通过 java.lang.reflect.Array 的 newInstance(Class,int) 创建 T[] 数组</h3><p><img src="/images/JavaGenericTypes/39.png" alt></p><h2 id="反射常用的泛型类"><a href="#反射常用的泛型类" class="headerlink" title="反射常用的泛型类"></a>反射常用的泛型类</h2><ul><li><code>Class&lt;T&gt;</code></li><li><code>Constructor&lt;T&gt;</code></li></ul><p><img src="/images/JavaGenericTypes/40.png" alt></p><p><img src="/images/JavaGenericTypes/41.png" alt></p><p>class.var IDEA的快捷方式生成引用 和 Ctrl+Alt+V 一个效果</p><p><img src="/images/JavaGenericTypes/42.png" alt></p><p><img src="/images/JavaGenericTypes/43.png" alt></p><p><img src="/images/JavaGenericTypes/44.png" alt></p><p><img src="/images/JavaGenericTypes/45.png" alt></p><p><img src="/images/JavaGenericTypes/46.png" alt></p><h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><ul><li>类型安全</li><li>减少强制类型转换</li></ul><h2 id="类型参数标识符"><a href="#类型参数标识符" class="headerlink" title="类型参数标识符"></a>类型参数标识符</h2><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（表示Java 类，包括基本的类和我们自定义的类）</li><li>K - Key（表示键，比如Map中的key）</li><li>V - Value（表示值）</li><li>N - Number（表示数值类型）</li><li>？ - （表示不确定的java类型）</li><li>S、U、V - 2nd、3rd、4th types</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型类&quot;&gt;&lt;a href=&quot;#泛型类&quot; class=&quot;headerlink&quot; title=&quot;泛型类&quot;&gt;&lt;/a&gt;泛型类&lt;/h2&gt;&lt;p&gt;泛型类,是在实例化类的时候, 指明 泛型的具体类型&lt;/p&gt;
&lt;h3 id=&quot;泛型的类型参数不支持基本类型-只能是类对象类型&quot;&gt;&lt;a href=&quot;#泛型的类型参数不支持基本类型-只能是类对象类型&quot; class=&quot;headerlink&quot; title=&quot;泛型的类型参数不支持基本类型,只能是类对象类型&quot;&gt;&lt;/a&gt;泛型的类型参数不支持基本类型,只能是类对象类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Generic&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; genericl = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Generic&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;// ❌&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Generic&amp;lt;Integer&amp;gt; genericl = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Generic&amp;lt;Integer&amp;gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// ✔&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👉&lt;a href=&quot;https://qastack.cn/programming/2721546/why-dont-java-generics-support-primitive-types&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么Java泛型不支持基本类型？&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是为了向后兼容
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSS Five Classic Layouts</title>
    <link href="http://www.orekiyuta.cn/archives/CSSFiveClassicLayouts/"/>
    <id>http://www.orekiyuta.cn/archives/CSSFiveClassicLayouts/</id>
    <published>2020-11-09T13:34:06.000Z</published>
    <updated>2020-11-09T14:44:29.766Z</updated>
    
    <content type="html"><![CDATA[<p>CSS的五种经典布局<br><a id="more"></a></p><h2 id="空间居中"><a href="#空间居中" class="headerlink" title="空间居中"></a>空间居中</h2><p><img src="/images/CSSFiveClassicLayouts/1.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span> <span class="attr">contenteditable</span>&gt;</span>:)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">place-items</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: lightblue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">resize</span>: both;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">background</span>: lightpink;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: system-ui, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定 Gird 布局,并且 <code>place-items:center;</code></li><li><code>place-items:center;</code> 是简写</li><li>全写为  <code>place-items:center center;</code> // <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code> 垂直 水平</li><li><code>place-items:start;</code>左上角  <code>place-items:end</code>右下角</li></ul><h2 id="并列式"><a href="#并列式" class="headerlink" title="并列式"></a>并列式</h2><p><img src="/images/CSSFiveClassicLayouts/2.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/3.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/4.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">  flex-wrap: wrap;//可换行</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">flex</span>: 0 1 300<span class="selector-tag">px</span>; <span class="comment">/*初始宽度300px,不可以扩大,宽度不足300px时可缩小*/</span></span></span><br><span class="line"><span class="css"> <span class="comment">/*flex: 1 1 300px;可扩大可缩小,就是始终占满*/</span></span></span><br><span class="line"><span class="undefined">  border: 1px solid red;</span></span><br><span class="line"><span class="undefined">  background: lightpink;</span></span><br><span class="line"><span class="undefined">  font-size: 2rem;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">  font-family: system-ui, serif;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>指定 flex 布局, <code>felx-wrap:wrap;</code>设置可换行</li><li><code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;</code></li><li>flex: &lt;初始宽度&gt;  &lt;足够宽时是否扩大&gt;  &lt;宽度不够时是否缩小&gt; </li></ul><h2 id="两栏式"><a href="#两栏式" class="headerlink" title="两栏式"></a>两栏式</h2><p>一边保持,另一边伸缩</p><p><img src="/images/CSSFiveClassicLayouts/5.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/6.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">  display: grid;</span></span><br><span class="line"><span class="undefined">  grid-template-columns: minmax(150px, 25%) 1fr;</span></span><br><span class="line"><span class="undefined">  padding: 0;</span></span><br><span class="line"><span class="undefined">  margin: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.sidebar</span> &#123;</span></span><br><span class="line"><span class="undefined">  height: 100vh;</span></span><br><span class="line"><span class="undefined">  background: lightpink;</span></span><br><span class="line"><span class="undefined">  font-size: 2rem;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="undefined">  padding: 2rem;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">  font-family: system-ui, serif;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">  Min: 150px</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  Max: 25%</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetur adipisicing elit. Omnis nulla architecto maxime modi nisi. Quas saepe dolorum, architecto quia fugit nulla! Natus, iure eveniet ex iusto tempora animi quibusdam porro?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>grid-template-columns: minmax(150px, 25%) 1fr;</code></li><li>minmax(150px, 25%) 左边最小150px,最大为总宽度25%</li><li>1fr 右边为剩余宽度</li></ul><h2 id="三明治"><a href="#三明治" class="headerlink" title="三明治"></a>三明治</h2><p>垂直分为三部分：页眉,内容,页脚;基本上只是内容区在变化</p><p><img src="/images/CSSFiveClassicLayouts/7.png" alt></p><p><img src="/images/CSSFiveClassicLayouts/8.png" alt></p><ul><li><code>grid-template-rows: auto 1fr auto;</code> 上中下</li></ul><h2 id="圣杯"><a href="#圣杯" class="headerlink" title="圣杯"></a>圣杯</h2><p>页面分为五个部分：页眉,页脚,内容区划分为左边栏,主栏,右边栏</p><p><img src="/images/CSSFiveClassicLayouts/9.png" alt></p><ul><li>指定 Grid 布局</li><li><code>grid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;</code></li><li><code>grid-template: auto 1fr auto / auto 1fr auto</code> 上中下都分成三部分</li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://1linelayouts.glitch.me/" target="_blank" rel="noopener">1linelayouts (https://1linelayouts.glitch.me/)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS的五种经典布局&lt;br&gt;
    
    </summary>
    
    
    
      <category term="CSS" scheme="http://www.orekiyuta.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Java Review</title>
    <link href="http://www.orekiyuta.cn/archives/JavaReview/"/>
    <id>http://www.orekiyuta.cn/archives/JavaReview/</id>
    <published>2020-11-05T12:20:57.000Z</published>
    <updated>2020-11-09T14:46:22.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ul><li><code>Car carKey</code> 创建了引用实例</li><li><code>new Car()</code> 创建了对象</li><li><code>Car carKey = new Car();</code> 把对象赋给引用它的实例</li></ul><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><ul><li>静态属性 &gt; 静态方法 &gt; 普通属性 &gt; 普通方法 &gt; 构造函数 </li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>this 指向当前的对象</li><li>this 可以调用方法、调用属性、和指向对象本身</li><li><img src="/images/JavaReview/1.png" alt><a id="more"></a><h2 id="封装-访问控制权限"><a href="#封装-访问控制权限" class="headerlink" title="封装(访问控制权限)"></a>封装(访问控制权限)</h2></li><li><img src="/images/JavaReview/2.png" alt></li></ul><h2 id="多态实现"><a href="#多态实现" class="headerlink" title="多态实现"></a>多态实现</h2><ul><li>继承</li><li>重写父类方法</li><li>父类引用指向子类对象 <code>Fruit fruit = new Apple();</code></li></ul><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>就是将对象应用放在新的类中就可以了</p><ul><li>多用组合，少用继承</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoccerPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Soccer soccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soccer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String soccerName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><img src="/images/JavaReview/3.png" alt></p></li></ul><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ul><li>抽象等级: 接口 &gt; 抽象类</li><li>接口定义了方法，抽象类定义了稍微具体点的方法</li><li>接口的实现必须实现全部方法，否则就该使用抽象类定义</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>编译期异常、运行期异常</li><li>Throwable 类是 Java 语言中所有 errors 和 exceptions 的父类</li><li>除了 RuntimeException 和它的子类，以及 error 和它的子类，其他所有异常都是 checkedException</li><li><img src="/images/JavaReview/4.png" alt></li><li><img src="/images/JavaReview/5.png" alt></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>就是将一个类的定义放在另一个类的内部</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            name = <span class="string">"elias"</span>;</span><br><span class="line">            age = <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个内部类都能独立地继承一个（接口）的实现，无论外部类是否已经继承了某个（接口的）实现，隐藏了内部实现的细节</p></li><li>内部类拥有外部类的访问权限</li><li>内部类还可以定义在方法和作用域内部，称为 局部内部类</li><li>内部类可以实现 Java 中的多重继承</li><li><img src="/images/JavaReview/6.png" alt></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><img src="/images/JavaReview/7.png" alt></li><li><img src="/images/JavaReview/8.png" alt></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是一种参数化的集合，限制了你添加进集合的类型</p><ul><li><img src="/images/JavaReview/9.png" alt></li></ul><h3 id="用泛型表示类"><a href="#用泛型表示类" class="headerlink" title="用泛型表示类"></a>用泛型表示类</h3><ul><li>泛型可以加到类上面，来表示这个类的类型</li><li><img src="/images/JavaReview/10.png" alt></li></ul><h3 id="用泛型表示接口"><a href="#用泛型表示接口" class="headerlink" title="用泛型表示接口"></a>用泛型表示接口</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般泛型接口常用于 生成器（generator），生成器相当于对象工厂，是一种专门用来创建对象的类</p></li></ul><h3 id="用泛型来表示方法"><a href="#用泛型来表示方法" class="headerlink" title="用泛型来表示方法"></a>用泛型来表示方法</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>List 是泛型类，为了表示各种泛型 List 的父类，可以使用通配符（?）表示，它的元素类型可以匹配任何类型</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();     </span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();     </span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();     </span><br><span class="line">        name.add(<span class="string">"elias"</span>);</span><br><span class="line">        age.add(<span class="number">22</span>);</span><br><span class="line">        number.add(<span class="number">824</span>);</span><br><span class="line">        generic(name);</span><br><span class="line">        generic(age);</span><br><span class="line">        generic(number);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generic</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test cxuan :"</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  ```        </span><br><span class="line">- 上界通配符：&lt;? extends ClassType&gt; 该通配符为 ClassType 的所有子类型。他表示的是任何类型都是 ClassType 类型的子类</span><br><span class="line">- 下界通配符：&lt;? <span class="keyword">super</span> ClassType&gt; 该通配符为 ClassType 的所有超类型。他表示的是任何类型的父类都是 ClassType</span><br><span class="line"></span><br><span class="line">## 反射</span><br><span class="line">反射主要提供了以下几个功能</span><br><span class="line">- 在运行时，判断任意一个对象所属的类</span><br><span class="line">- 在运行时，构造任意一个类的对象 </span><br><span class="line">- 在运行时，判断任意一个类所有的成员变量和方法</span><br><span class="line">- 在运行时，调用任意一个对象的方法</span><br><span class="line">- `java.lang.reflect`所涉及的类</span><br><span class="line">- ![](/images/JavaReview/<span class="number">11</span>.png)</span><br><span class="line">以下实例验证了一下</span><br><span class="line">- ![](/images/JavaReview/<span class="number">12</span>.png)</span><br><span class="line">- ![](/images/JavaReview/<span class="number">13</span>.png)</span><br><span class="line"></span><br><span class="line">## 枚举</span><br><span class="line">- 编辑器会为创建好的枚举自动添加 toString(),ordinal(),values()</span><br><span class="line">- ordinal()表示Enum常量的声明顺序</span><br><span class="line">- values(）显示顺序的值</span><br><span class="line">- ![](/images/JavaReview/<span class="number">14</span>.png)</span><br><span class="line">- `Family father = Family.FATHER;` 枚举可以直接调用 </span><br><span class="line"></span><br><span class="line">一般 <span class="keyword">switch</span> 可以和 <span class="keyword">enum</span>  一起连用，来构造一个小型的状态转换机</span><br><span class="line">- ```java </span><br><span class="line">    <span class="keyword">enum</span> Signal&#123;</span><br><span class="line">        GREEN,YELLOW,RED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trafficlight</span></span>&#123;</span><br><span class="line">        Signal color = Signal.GREEN;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (color)&#123;</span><br><span class="line">                <span class="keyword">case</span> GREEN:</span><br><span class="line">                    color = Signal.YELLOW;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YELLOW:</span><br><span class="line">                    color = Signal.RED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RED:</span><br><span class="line">                    color = Signal.GREEN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><ul><li><img src="/images/JavaReview/15.png" alt></li><li><p><img src="/images/JavaReview/16.png" alt></p></li><li><p>路径分隔符（Window 是 ; linux 是 :）</p></li><li>路径名称分隔符（Window 是 \ linux 是 /）</li><li><img src="/images/JavaReview/17.png" alt></li></ul><p>对文件操作</p><ul><li><img src="/images/JavaReview/18.png" alt></li></ul><p>对文件夹操作</p><ul><li><img src="/images/JavaReview/19.png" alt></li><li>三种创建方式</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String directoryPath);</span><br><span class="line">File(String directoryPath, String filename); </span><br><span class="line">File(File dirObj, String filename);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"D:\\java\\file1.txt"</span>); </span><br><span class="line">System.out.println(file);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\java"</span>,<span class="string">"file2.txt"</span>);</span><br><span class="line">File parent = <span class="keyword">new</span> File(<span class="string">"D:\\java"</span>);</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent,<span class="string">"file3.txt"</span>);</span><br><span class="line">System.out.println(file3);</span><br></pre></td></tr></table></figure></li><li><p><img src="/images/JavaReview/20.png" alt></p></li></ul><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><ul><li><img src="/images/JavaReview/21.png" alt><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3></li><li><img src="/images/JavaReview/22.png" alt><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3></li><li><img src="/images/JavaReview/23.png" alt><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3></li><li><img src="/images/JavaReview/24.png" alt></li></ul><h2 id="java-io-lang-math-net"><a href="#java-io-lang-math-net" class="headerlink" title="java.io/lang/math/net"></a>java.io/lang/math/net</h2><ul><li><img src="/images/JavaReview/25.png" alt></li><li><img src="/images/JavaReview/26.png" alt></li><li><img src="/images/JavaReview/27.png" alt></li><li><img src="/images/JavaReview/28.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象创建&quot;&gt;&lt;a href=&quot;#对象创建&quot; class=&quot;headerlink&quot; title=&quot;对象创建&quot;&gt;&lt;/a&gt;对象创建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Car carKey&lt;/code&gt; 创建了引用实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new Car()&lt;/code&gt; 创建了对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Car carKey = new Car();&lt;/code&gt; 把对象赋给引用它的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;初始化顺序&quot;&gt;&lt;a href=&quot;#初始化顺序&quot; class=&quot;headerlink&quot; title=&quot;初始化顺序&quot;&gt;&lt;/a&gt;初始化顺序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;静态属性 &amp;gt; 静态方法 &amp;gt; 普通属性 &amp;gt; 普通方法 &amp;gt; 构造函数 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;this 指向当前的对象&lt;/li&gt;
&lt;li&gt;this 可以调用方法、调用属性、和指向对象本身&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;/images/JavaReview/1.png&quot; alt&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.orekiyuta.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>How Networks Works / After reading</title>
    <link href="http://www.orekiyuta.cn/archives/HowNetworksWorks/"/>
    <id>http://www.orekiyuta.cn/archives/HowNetworksWorks/</id>
    <published>2020-06-27T13:29:16.000Z</published>
    <updated>2020-12-01T17:39:00.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器生成消息—浏览器内部"><a href="#浏览器生成消息—浏览器内部" class="headerlink" title="浏览器生成消息—浏览器内部"></a>浏览器生成消息—浏览器内部</h2><p><img src="/images/HowNetworksWorks/1.png" alt><br><a id="more"></a></p><h3 id="生成-HTTP-请求消息"><a href="#生成-HTTP-请求消息" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h3><h4 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h4><ul><li>URL:Uniform Resource Locator</li><li>FTP:File Transfer Protocol</li></ul><p><img src="/images/HowNetworksWorks/2.png" alt></p><ul><li>协议:通信操作的规则</li><li>URL 开头部分,表示浏览器应当使用的方法;比如:http,ftp,file,mailto</li><li>Web浏览器解析 URL 过程<ul><li><img src="/images/HowNetworksWorks/3.png" alt></li><li><img src="/images/HowNetworksWorks/4.png" alt></li></ul></li></ul><h4 id="URL-省略"><a href="#URL-省略" class="headerlink" title="URL 省略"></a>URL 省略</h4><ul><li><p><code>http://www.lab.glasscom.com/dir/</code></p><ul><li>像这个 URL 其实背后省略了具体文件</li><li>一般服务器上会事先设置好文件名省略时要访问的默认文件名</li><li>根据不同的服务器而不同,大多数情况是 index.html 之类</li><li>完整的访问地址为 <code>http://www.lab.glasscom.com/dir/index.html</code></li></ul></li><li><p><code>http:/www.lab.glasscom.com/</code> </p><ul><li>这种也是省略了的; 一般情况完整为 <code>http:?/www.lab.glasscom.com/index.html</code></li><li>其实以 “/” 结尾,表示它访问了名为 “/” 的目录; “/” 顶级目录,根目录</li><li>前面的 dir/ 就是访问 dir目录下的内容</li></ul></li><li><p><code>http:/www.lab.glasscom.com</code> </p><ul><li>这个连根目录 “/” 也省略了</li><li>连目录都不知道的情况下,也就是没有路径名的情况下;一般代表访问根目录下事先设置的默认文件</li></ul></li><li><p><code>http:/www.lab.glasscom.com/whatisthis</code></p><ul><li>这种情况,可能是末尾 “/” 省略了,可也能没省略 ;事实上是很多人没有正确理解省略文件名的规则,经常把目录结尾的 “/” 省略了</li><li>这种情况应该按照以下处理</li><li>如果 Web 服务器上存在名为 whatisthis 的文件,则将它作为文件名处理</li><li>如果存在名为 whatisthis 的目录,则当作目录名来处理</li><li>Linux 下无法创建两个名字相同的文件和目录;因此不可能既有一个名为 whatisthis 的文件,同时又有一个名为 whatisthis 的目录</li></ul></li></ul><h4 id="HTTP-基本思路"><a href="#HTTP-基本思路" class="headerlink" title="HTTP 基本思路"></a>HTTP 基本思路</h4><p><img src="/images/HowNetworksWorks/5.png" alt></p><ul><li>URI:Uniform Resource Identifier</li><li>一般来说,URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名,例如“/dir1/file1.html”“/dir1/program1.cgi”等</li><li>不过,URI 不仅限于此,也可以直接使用“http:”开头的 URL来作为 URI。换句话说就是,这里可以写各种访问目标,而这些访问目标统称为 URI</li><li><p>CGI 程序:对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI,而按照 CGI 规范来工作的程序就称为 CGI 程序</p></li><li><p>HTTP 的主要方法<br><img src="/images/HowNetworksWorks/6.png" alt></p></li><li><p>请求/响应<br><img src="/images/HowNetworksWorks/7.png" alt></p></li></ul><p><img src="/images/HowNetworksWorks/8.png" alt></p><p><img src="/images/HowNetworksWorks/9.png" alt></p><p><img src="/images/HowNetworksWorks/10.png" alt></p><p><img src="/images/HowNetworksWorks/11.png" alt></p><ul><li>一次请求响应过程<br><img src="/images/HowNetworksWorks/12.png" alt></li></ul><p><img src="/images/HowNetworksWorks/13.png" alt></p><p><img src="/images/HowNetworksWorks/14.png" alt></p><h3 id="向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="向 DNS 服务器查询 Web 服务器的 IP 地址"></a>向 DNS 服务器查询 Web 服务器的 IP 地址</h3><h4 id="TCP-IP-结构思路"><a href="#TCP-IP-结构思路" class="headerlink" title="TCP/IP 结构思路"></a>TCP/IP 结构思路</h4><p><img src="/images/HowNetworksWorks/15.png" alt></p><ul><li>目前大部分路由器已经内置了集线器功能</li><li><p>数据是以包的形式传送的</p></li><li><p>IP地址:一串 32 bit 的数字,按照 8 bit 为一组分成4组,分别用十进制表示</p></li><li>但单凭这串数字还是无法区分哪部分是网络号,哪部分是主机号</li></ul><p><img src="/images/HowNetworksWorks/16.png" alt></p><ul><li>在IP地址的规则里,网络号加主机号总共是32bit,但是这两部分具体结构是不固定的</li><li>因此还要附加信息（子网掩码）来表示IP地址的内部结构</li></ul><p><img src="/images/HowNetworksWorks/17.png" alt></p><p><img src="/images/HowNetworksWorks/18.png" alt></p><h4 id="DNS-由来"><a href="#DNS-由来" class="headerlink" title="DNS 由来"></a>DNS 由来</h4><ul><li>确定通信对象需要知道它的IP地址</li><li>如果不知道通信对象的IP地址,就无法进行通信,需要事先查询记好</li><li>使用IP地址可以代替使用服务器名称（域名）去访问</li><li>但是如果通信对象的Web服务器使用了虚拟主机,有可能用IP地址访问不了</li><li>网络中存在无数的路由器,相互配合,根据IP地址来转发数据</li><li>用域名去访问对象比用IP去访问效率要低</li><li>因为IP地址长度32bit,4字节;而域名要几十字节;增加了路由器的负担,自然消耗的时间要更长</li><li>域名并不仅是长,而且其长度是不固定的。处理长度不固定的数据比处理长度固定的数据要复杂,这也是造成效率低下的重要原因之一</li><li>（1）由于IP难以记住（2）使用域名效率低下</li><li>因此,使用了折中的方案:让人使用域名,路由器使用IP</li><li>为了达成这个目的,把域名和IP做关联的机制就诞生了,称为DNS:Domain Name System</li><li>Domain Name System :将服务器名称和 IP 地址进行关联是 DNS 最常见的用法,但 DNS 的功能并不仅限于此,它还可以将邮件地址和邮件服务器进行关联,以及为各种信息关联相应的名称</li></ul><h4 id="DNS-解析器"><a href="#DNS-解析器" class="headerlink" title="DNS 解析器"></a>DNS 解析器</h4><ul><li>相对于DNS服务器,我们的计算机上一定有相应的DNS客户端（解析器）,存在于操作系统的 Socket 库中</li></ul><p><img src="/images/HowNetworksWorks/19.png" alt></p><ul><li>大概流程是<ul><li>（1）使用DNS解析器把域名解析写入内存,接着交给操作系统向DNS服务器发送查询消息</li><li>（2）然后DNS服务器响应消息,解析器取出IP地址,存入浏览器指定的内存地址</li><li>（3）浏览器在向Web服务器发送请求的时候,从该内存地址取出IP地址,将它和HTTP请求一起提交给操作系统</li></ul></li></ul><p><img src="/images/HowNetworksWorks/20.png" alt></p><ul><li>HTTP消息是用文本编写的,但DNS消息是使用二进制数据编写的</li><li><p>浏览器本身不具备使用网络收发数据的功能,都是由操作系统内部的协议栈（操作系统内部的网络控制软件,也叫协议驱动,TCP/IP驱动,等等）来执行的</p></li><li><p>向DNS服务器发送消息的时候,也是要知道DNS服务器的IP地址的,只不过这个IP地址作为TCP/IP的一个设置项目事先设置好了</p></li></ul><p><img src="/images/HowNetworksWorks/21.png" alt></p><h3 id="全世界-DNS-服务器的大接力"><a href="#全世界-DNS-服务器的大接力" class="headerlink" title="全世界 DNS 服务器的大接力"></a>全世界 DNS 服务器的大接力</h3><h4 id="DNS-基本工作"><a href="#DNS-基本工作" class="headerlink" title="DNS 基本工作"></a>DNS 基本工作</h4><ul><li>来自客户端解析器的查询信息<ul><li>域名</li><li>Class:以前设计的时候,还需要标识网络信息,不过现在除了互联网以外没有其他网络了</li><li>记录类型:标识域名对应何种记录类型;比如 A(Address) 标识了域名对应的是IP地址、MX(Mail eXchange) 标识了对应邮件服务器</li></ul></li></ul><p><img src="/images/HowNetworksWorks/22.png" alt></p><p><img src="/images/HowNetworksWorks/23.png" alt></p><h4 id="域名层次结构"><a href="#域名层次结构" class="headerlink" title="域名层次结构"></a>域名层次结构</h4><ul><li>互联网中存在无数的服务器,将这些服务器信息存在一台DNS服务器是不可能的</li><li>因此,将信息分布保存在多台DNS服务器中,层层追溯</li><li><p><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener">www.lab.glasscom.com</a></p><ul><li>越靠右边,层级越高</li><li><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener">www.lab.glasscom.com</a> &lt; lab.glasscom.com &lt; glasscom.com &lt; com</li><li>每个层级可以称为域,每个域作为一个整体存放在DNS服务器中（但是,DNS服务器和域也并不总是一对一的）</li></ul></li><li><p>互联网中那么多台DNS服务器,肯定不能挨个去找</p></li><li>因此,将下级域的IP地址注册到它们的上级域的DNS服务器中,就和链表,区块链一个意思</li><li>也就是说,负责管理 lab.glasscom.com 域的DNS服务器的IP地址注册到 glasscom.com 域的DNS服务器中,而 glasscom.com 域的DNS服务器的IP地址又注册到了 com 域的DNS服务器中</li><li>这样就可以从顶级开始层层追溯了<ul><li>目前来说,一般 com,jp 称为顶级域</li><li>但是事实上它们上面还有一级域,称为根域</li><li>根域并没有名字,因此常常被省略</li><li><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener">www.lab.glasscom.com</a>.  最后一个点就代表根域（和根目录一个思路）</li></ul></li></ul><p><img src="/images/HowNetworksWorks/24.png" alt></p><ul><li>根域的DNS服务器信息保存在全互联网所有DNS服务器中,这样一来就完成了<ul><li>分配给根域DNS服务器的IP地址在全世界只有13个,这些地址几乎不变化,所以就可以保存在所有DNS服务器中了</li><li>根域 DNS 服务器在运营上使用多台服务器来对应一个 IP 地址,因此尽管 IP 地址只有 13 个,但其实服务器的数量是很多的</li></ul></li></ul><p><img src="/images/HowNetworksWorks/25.png" alt></p><ul><li>客户端计算机第一次访问的DNS服务器也就是我们在TCP/IP中设置的DNS服务器（所以改DNS也是有讲究的）</li><li><p>第一次访问的DNS服务器作为所有访问查询的中继点,如图所示</p></li><li><p>上图追溯只是基本原理,真实互联网一台DNS服务器可以管理多个域的信息,因此并不是每个域都有一台自己的DNS服务器</p><ul><li>现实中上下级域有可能共享同一台DNS服务器</li><li>此外,有时候并不需要从最上级的根域开始查找,因为DNS服务器有个缓存功能</li><li>缓存可以记住之前查询过的域名;<ul><li>如果要查询的域名和相关信息已经在缓存中,就可以直接从缓存的位置开始向下查询;减少查询时间</li><li>并且,当要查询的域名信息不存在时,“不存在”这个响应结果也会被缓存;当下次查询这个不存在的域名时,也可以快速响应</li><li>需要注意的是,信息被缓存后,原本的注册信息可能会发生改变,这时缓存的信息就有可能是不正确的</li><li>因此,DNS服务器中保存的信息都会设置一个有效期;而且在查询响应时,DNS服务器也会告知客户端这个响应结果是来自缓存还是来自负责管理该域名的DNS服务器</li></ul></li></ul></li></ul><h3 id="委托协议栈发送信息"><a href="#委托协议栈发送信息" class="headerlink" title="委托协议栈发送信息"></a>委托协议栈发送信息</h3><h4 id="数据收发操作概览"><a href="#数据收发操作概览" class="headerlink" title="数据收发操作概览"></a>数据收发操作概览</h4><ul><li><p>知道IP地址后,就可以委托操作系统内部的协议栈像这个目标IP地址,发送HTTP消息（数字消息）了</p></li><li><p>收发数字消息这个操作不局限于浏览器,对于各种使用网络的应用程序都是共通的</p></li></ul><p><img src="/images/HowNetworksWorks/26.png" alt></p><p><img src="/images/HowNetworksWorks/27.png" alt></p><ul><li><p>在收发数据操作之前,双方需要先建立连接（建立如图的假设出来的管道）</p><ul><li>建立管道的关键在于管道两端的数据出入口,这些出入口称为套接字</li><li>我们需要先创建套接字,然后再将套接字连接起来形成管道</li></ul></li><li><p>实际上过程如下</p><ul><li>服务器一方先创建套接字,等待客户端向该套接字连接管道</li><li>当服务器进入等待状态,客户端就可以连接管道了</li><li>客户端也会先创建套接字,然后从该套接字延伸出管道,</li><li>最后连接到服务器端的套接字上</li><li>之后就可以收发数据了</li><li>数据发送完毕后,断开时可以由任意一方发起</li></ul></li><li><p>综上所述,可以总结为4个阶段</p><ul><li>创建套接字（创建套接字阶段）</li><li>将管道连接到服务器段的套接字上（连接阶段）</li><li>收发数据（通信阶段）</li><li>断开管道并删除套接字（断开阶段）</li></ul></li><li><p>以上的操作都是由操作系统内部的协议栈来执行的,浏览器和应用程序并不会自己去做这些工作,而是“委托”协议栈来做</p></li><li>这些“委托”都是通过调用 Socket库中的程序组件来执行的,这些数据通信用的组件充当了桥梁的角色</li></ul><h4 id="创建套接字阶段"><a href="#创建套接字阶段" class="headerlink" title="创建套接字阶段"></a>创建套接字阶段</h4><p><img src="/images/HowNetworksWorks/28.png" alt></p><ul><li>套接字创建完毕后,协议栈会返回一个描述符</li><li>应用程序会将收到的描述符存在内存中</li><li>描述符用来识别不同的套接字,因为实际上会有多个数据同时通信</li></ul><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><ul><li>连接的时候还需要给出IP地址的具体端口号（表示具体哪个应用程序）</li><li>然后再从那个应用程序中找按照标识符找到对应的套接字</li></ul><p><img src="/images/HowNetworksWorks/29.png" alt></p><h4 id="通信阶段"><a href="#通信阶段" class="headerlink" title="通信阶段"></a>通信阶段</h4><ul><li>连接完毕之后,接下来就通过 Sokcet库委托协议栈来将 应用程序在内存中准备好的数据 送入套接字</li><li>接着协议栈再将数据发送到服务器</li><li>服务器接收到数据后,执行相应的操作,再返回消息给客户端</li></ul><h4 id="断开阶段"><a href="#断开阶段" class="headerlink" title="断开阶段"></a>断开阶段</h4><ul><li>Web 使用的HTTP协议规定,当Web服务器发送完响应消息后,应该主动断开操作</li><li>HTTP协议将HTML文档和图片都作为单独对象处理,因此要执行很多次连接断开操作</li><li>所以后来HTTP 1.1 就可以在一次连接中收发多个请求响应</li></ul><h2 id="用电信号传输-TCP-IP-数据—协议栈、网卡"><a href="#用电信号传输-TCP-IP-数据—协议栈、网卡" class="headerlink" title="用电信号传输 TCP/IP 数据—协议栈、网卡"></a>用电信号传输 TCP/IP 数据—协议栈、网卡</h2><p><img src="/images/HowNetworksWorks/30.png" alt></p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><ul><li>协议栈内部结构</li></ul><p><img src="/images/HowNetworksWorks/31.png" alt></p><p><img src="/images/HowNetworksWorks/32.png" alt></p><ul><li>ICMP用于告知网络包传送过程中产生的错误以及各种控制消息</li><li>ARP用于根据IP地址查询相应的以太网MAC地址</li><li>在协议栈内部有一块用于存放控制信息的内存空间,这里记录了用于控制通信操作的控制信息,例如通信对象的 IP 地址、端口号、通信操作的进行状态等<ul><li>套接字只是一个概念而已,可以说这些控制信息就是套接字</li><li>协议栈根据套接字的信息进行活动,这就是套接字的作用</li></ul></li><li>下图的每一行相当于一个套接字</li><li><p>PID:Process ID<br><img src="/images/HowNetworksWorks/33.png" alt></p></li><li><p>下图是浏览器委托协议栈使用TCP协议来收发数据</p></li></ul><p><img src="/images/HowNetworksWorks/34.png" alt></p><ul><li>协议栈首先会分配用于存放一个套接字所需的内存空间</li><li>然后向套接字的内存空间里写入表示这一初始状态的控制信息</li><li>这样一来套接字就创建完毕了</li><li>然后将这个套接字的描述符告诉应用程序;之后应用程序在向协议栈进行收发数据委托的时候就带着这个描述符,就能确定了相应的套接字,协议栈就能获取在相应套接字内相关的控制信息了</li></ul><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><ul><li><p>“连接”是什么意思</p><ul><li>网线一直是连着的,随时都有信号从中流过,如果通信过程只是将数据转换为电信号,那么这个操作随时都可以进行</li><li>套接字创建完成的时候,里面还没有任何存放任何控制信息,这种状态下即使应用程序要求发送数据,协议栈也不知道发送给谁</li><li>协议栈需要等待我们在套接字中存入控制信息</li><li>服务器程序一般会在系统启动的时候就创建套接字并等待客户端连接</li><li>和客户端不同,服务器根本不知道想来通信的对象是谁<ul><li>就和打电话一样,对方在没接到电话之前,根本不可能知道打电话的人是谁</li></ul></li><li>连接实际上是通信双方交换控制信息,在套接字中记录这些必要信息并准备数据收发的一连串操作</li><li>连接操作中所交换的控制信息是根据通信规则来确定的,只要根据规则执行连接操作,双方就可以得到必要的信息从而完成数据收发的准备</li></ul></li><li><p>通信操作中使用的控制信息可以分为两大类</p><ul><li>（1）客户端和服务器相互联络交换的控制信息<ul><li>这些信息不仅连接时需要,包括数据收发和断开连接操作在内,整个通信过程都需要</li><li>这些内容在TCP协议中进行了定义</li><li><img src="/images/HowNetworksWorks/35.png" alt></li><li>这些信息会添加在客户端和服务器之间传递的网络包头部（这里是TCP的控制信息,简称TCP头部）<ul><li>其他协议也有自己的控制信息,以太网头部（MAC头部）,IP头部</li></ul></li><li><img src="/images/HowNetworksWorks/36.png" alt></li></ul></li><li>（2）保存在套接字中,用来控制协议操作的信息<ul><li>应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里,还有收发数据操作的执行状态等信息也会保存在这里,协议栈会根据这些信息来执行每一步的操作</li><li>我们可以说,套接字的控制信息和协议栈的程序本身其实是一体的</li><li>“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同,但无论协议栈的实现如何不同,IP地址和端口号这些重要的信息都是共通的</li><li>虽然协议栈的实现不同,但是并不影响通讯;因为协议栈中的控制信息通信对方是看不见的,只要在通信时按照规则将必要的信息写入头部,客户端和服务器之间的通信就能够得以成立</li><li>Windows 和Linux 操作系统的内部结构不同,协议栈的实现方式不同,必要的控制信息也就不同</li></ul></li></ul></li></ul><p><img src="/images/HowNetworksWorks/34.png" alt></p><ul><li><p>连接过程</p><ul><li>连接操作的第一步是在TCP模块出创建表示连接控制信息的头部（TCP头部）;通过TCP头部中的发送方和接受方端口号可以找到要连接的套接字</li><li>当TCP头部创建好之后,接下来TCP模块会将信息传递给IP模块并委托它进行发送  </li><li>IP 模块执行网络包发送操作后,网络包就会通过网络到达服务器</li><li>然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块</li><li>服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字</li><li>当找到对应的套接字之后,套接字中会写入相应的信息,并将状态改为正在连接</li><li><p>然后 TCP 模块会返回响应到客户端,重复和客户端一样的过程</p><ul><li>服务器在返回响应的时候还需要再TCP头部设置发送方和接受方的端口号以及SYN比特,此外还要将ACK控制位设为1<ul><li>ACK 设为1表示以及接收到相应的网络包,ACK比特就是用来确认网络包是否送达的</li></ul></li></ul></li><li><p>客户端接收到响应信息并确认TCP头部信息的SYN为1,表示连接成功</p></li><li>接着就会向套接字中写入服务器的IP地址、端口号等信息;同时将状态改为连接完毕,</li><li>并将客户端的TCP头部ACK比特设置为1,发送给服务器,表明刚才的响应包已收到</li><li>这样连接就全部完成</li></ul></li></ul><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><h4 id="将-HTTP-请求信息交给协议栈"><a href="#将-HTTP-请求信息交给协议栈" class="headerlink" title="将 HTTP 请求信息交给协议栈"></a>将 HTTP 请求信息交给协议栈</h4><ul><li>协议栈收到应用程序传来的数据会先存放到发送缓冲区,等到应用程序继续传送数据,避免发送大量小网络包,导致网络效率下降</li><li><p>协议栈发送数据要根据以下几个要素来判断</p><ul><li><p>(1)每个网络包能容纳的数据长度,协议栈会根据一个叫作MTU（Maximum Transmission Unit）的参数来判断</p><ul><li>MTU表示每个网络包的最大长度,在以太网中一般是1500字节</li><li>MTU 是包含头部的总长度,因此需要从MTU 减去头部的长度,然后得到的长度就是一个网络包中所能容纳的最大数据长度,这一长度叫作 MSS</li><li>当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去</li></ul><p><img src="/images/HowNetworksWorks/37.png" alt></p></li><li><p>(2)时间</p><ul><li>当应用程序发送数据的频率不高的时候,如果每次都等到长度接近 MSS 时再发送,可能会因为等待时间太长而造成发送延迟,这种情况下,即便缓冲区中的数据长度没有达到 MSS,也应该果断发送出去</li><li>为此,协议栈的内部有一个计时器,当经过一定时间之后,就会把网络包发送出去</li></ul></li><li>两者其实是有矛盾的,具体如何达到平衡得看协议栈开发者</li></ul></li><li>如果仅靠协议栈来判断发送的时机可能会带来一些问题,因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项,比如如果指定“不等待填满缓冲区直接发送”,则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时,等待填满缓冲区导致延迟会产生很大影响,因此一般会使用直接发送的选项</li></ul><h4 id="拆分较大的数据"><a href="#拆分较大的数据" class="headerlink" title="拆分较大的数据"></a>拆分较大的数据</h4><ul><li>如果数据很大,比如长篇文章,这样发送缓冲区中数据长度就会超过MSS的长度</li><li>这样时候就不需要继续等待后面的数据了,直接以MSS长度为单位拆分</li><li>拆分出来的数据放进单独的网络包,在数据前面加上TCP头部,IP头部,MAC头部,然后发送</li></ul><p><img src="/images/HowNetworksWorks/38.png" alt></p><h4 id="使用-ACK-号确认网络包已收到"><a href="#使用-ACK-号确认网络包已收到" class="headerlink" title="使用 ACK 号确认网络包已收到"></a>使用 ACK 号确认网络包已收到</h4><p><img src="/images/HowNetworksWorks/39.png" alt></p><ul><li>TCP 具备确认对方是否成功收到网络包,以及当对方没收到时进行重发的功能</li><li>TCP 模块在拆分数据的时候,会对数据做好标识,让服务器能够知道数据包有没有遗漏</li><li>返回 ACK 号时,除了要设置 ACK 号的值以外,还需要将控制位中的 ACK 比特设为 1,这代表 ACK 号字段有效,接收方也就可以知道这个网络包是用来告知 ACK 号的</li><li><p>实际的通信序号是随机的一个初始值,固定的序号容易被预测攻击</p><ul><li>因此在收发数据之前就将初始值告诉通信对象</li><li>在连接过程中将 SYN（Synchronize） 控制位设为 1 的时候,就在这一步同时设置了初始值</li></ul></li><li><p>上面的只是单项的数据传输,实际上客户端向服务器发送数据的同时,服务器也在向客户端发送数据</p></li></ul><p><img src="/images/HowNetworksWorks/40.png" alt></p><ul><li>实际的初始值序号和ACK确认流程如下</li></ul><p><img src="/images/HowNetworksWorks/41.png" alt></p><ul><li>因为有了 TCP 这个机制,我们可以确认接受方有没有收到某个包,如果没有收发则重新发送</li><li>这样一来,无论网络中发送任何错误,我们都可以发现并重传网络包</li><li>因此,网卡、集线器、路由器都不需要错误补偿机制了,一旦检测到错误,直接丢弃相应的包</li><li>在网络中断,服务器宕机,TCP 重传不起效,TCP会在尝试几次重传无效后强制结束通信,并向应用程序报错</li></ul><h4 id="根据网络包平均往返时间调整-ACK-号等待时间"><a href="#根据网络包平均往返时间调整-ACK-号等待时间" class="headerlink" title="根据网络包平均往返时间调整 ACK 号等待时间"></a>根据网络包平均往返时间调整 ACK 号等待时间</h4><ul><li><p>前面的只是基本原理,实际上网络的错误检测和补偿机制非常复杂</p></li><li><p>设置一个合理的返回 ACK 号的等待时间</p><ul><li>当网络拥塞的时候,ACK 号返回速度变慢,需要将等待时间设置长点,否则就会已经重传了包之后,前面的 ACK 号才姗姗来迟</li><li>重传了多余的包,数量多了之后会给本来就拥塞的网络雪上加霜</li><li>设置等待时间也不是越长越好,时间过长,包的重传就会出现很大的延迟,也会导致网络速度变慢</li><li>设置一个合理的值十分困难<ul><li>服务器的物理距离,拥塞情况,等都要考虑</li></ul></li><li>因此,TCP采用了动态调整等待时间的方法<ul><li>TCP 会在发送数据的过程中持续测量 ACK 号的返回时间,如果 ACK 号返回变慢,则相应延长等待时间;相对地,如果 ACK 号马上就能返回,则相应缩短等待时间 </li></ul></li></ul></li></ul><h4 id="使用窗口有效管理-ACK-号"><a href="#使用窗口有效管理-ACK-号" class="headerlink" title="使用窗口有效管理 ACK 号"></a>使用窗口有效管理 ACK 号</h4><p><img src="/images/HowNetworksWorks/42.png" alt></p><ul><li>使用滑动窗口的方式,时间是充分利用了,但是可能会出现发送包的频率超过接受方处理能力的情况<ul><li>接受方收到包后,会先将数据存放到接受缓冲区,然后计算ACK号,将数据块组装起来还原成数据并传递给应用程序</li><li>如果前面的操作没有完成,后面下一个包到了,会被暂存在接收缓冲区等待处理</li><li>如果数据到达的速率比处理这些数据并传递给应用程序的速率还要块,那么接受缓冲区中的数据越来越多,最终就会溢出</li><li>后面的数据包就收不到了,也就是超出了接受方的处理能力</li></ul></li><li>为了避免这种情况,首先接受方需要告诉发送方字节最多能接收多少数据,然后发送方根据这个值对数据发送操作进行控制</li></ul><p><img src="/images/HowNetworksWorks/43.png" alt></p><ul><li>这个能够接收的最大数据量称为 窗口大小 ,它是 TCP 调优参数中非常有名的一个</li></ul><h4 id="ACK-与-窗口的合并"><a href="#ACK-与-窗口的合并" class="headerlink" title="ACK 与 窗口的合并"></a>ACK 与 窗口的合并</h4><ul><li>要提高收发数据的效率,就要考虑返回ACK号和更新窗口的时机</li><li>更新窗口一般在接受方缓冲区剩余容量增加时,告知对方</li><li>ACK 号在接受到后就告知对方</li><li>如果这两个是单独的包,就会导致接受方给发送方的包太多,从而导致网络效率下降</li><li>因此,接受方会等待一段时,把两种通知的包合并在一个包发送</li></ul><h4 id="接收-HTTP-响应消息"><a href="#接收-HTTP-响应消息" class="headerlink" title="接收 HTTP 响应消息"></a>接收 HTTP 响应消息</h4><ul><li>首先,协议栈会检查收到的数据块和 TCP 头部的内容,判断是否有数据丢失,如果没有问题则返回 ACK 号</li><li>然后,协议栈将数据块暂存到接收缓冲区中,并将数据块按顺序连接起来还原出原始的数据,最后将数据交给应用程序</li><li>具体来说,协议栈会将接收到的数据复制到应用程序指定的内存地址中,然后将控制流程交回应用程序</li><li>将数据交给应用程序之后,协议栈还需要找到合适的时机向发送方发送窗口更新 </li></ul><h3 id="断开服务器并删除套接字"><a href="#断开服务器并删除套接字" class="headerlink" title="断开服务器并删除套接字"></a>断开服务器并删除套接字</h3><h4 id="数据发送完毕后断开连接"><a href="#数据发送完毕后断开连接" class="headerlink" title="数据发送完毕后断开连接"></a>数据发送完毕后断开连接</h4><ul><li>服务器的协议栈会生成包含断开信息的TCP头部,将控制位中的 FIN 比特设为 1</li><li>接下来,协议栈会委托IP模块向客户端发送数据</li><li>同时,服务器的套接字中也会记录下来断开操作的相关信息</li></ul><p><img src="/images/HowNetworksWorks/44.png" alt></p><ul><li>然后客户端接受到后,客户端的协议栈会将自己的套接字标记为进入断开操作状态</li><li><p>为了告诉服务器已经收到 FIN 为 1 的包,客户端会向服务器返回一个 ACK 号</p></li><li><p>应用程序有可能在收到 FIN 为 1 的包之前就来读取数据,这时读取数据的操作会被挂起,等到 FIN 包到达再继续执行</p></li></ul><h4 id="删除套接字"><a href="#删除套接字" class="headerlink" title="删除套接字"></a>删除套接字</h4><ul><li>和服务器通信结束后,用来通信的套接字也不会再使用了</li><li>套接字并不会立刻被删除,而是等待一段时间之后再被删除<ul><li>为了防止误操作</li><li>假设,客户端先发起断开,则断开的操作顺序如下<ul><li>（1）客户端发送 FIN </li><li>（2）服务器返回 ACK 号</li><li>（3）服务器发送 FIN </li><li>（4）客户端返回 ACK 号</li></ul></li><li>如果最后客户端返回的 ACK 号丢失了,结果会如何呢？这时,服务器没有接收到 ACK 号,可能会重发一次 FIN。如果这时客户端的套接字已经删除了,会发生什么事呢？套接字被删除,那么套接字中保存的控制信息也就跟着消失了,套接字对应的端口号就会被释放出来。这时,如果别的应用程序要创建套接字,新套接字碰巧又被分配了同一个端口号 B,而服务器重发的 FIN 正好到达,会怎么样呢？本来这个 FIN 是要发给刚刚删除的那个套接字的,但新套接字具有相同的端口号,于是这个 FIN 就会错误地跑到新套接字里面,新套接字就开始执行断开操作了。之所以不马上删除套接字,就是为了防止这样的误操作</li></ul></li></ul><h4 id="TCP-整体流程"><a href="#TCP-整体流程" class="headerlink" title="TCP 整体流程"></a>TCP 整体流程</h4><p><img src="/images/HowNetworksWorks/45.png" alt></p><h3 id="IP-与以太网的包收发操作"><a href="#IP-与以太网的包收发操作" class="headerlink" title="IP 与以太网的包收发操作"></a>IP 与以太网的包收发操作</h3><h4 id="包的基本结构"><a href="#包的基本结构" class="headerlink" title="包的基本结构"></a>包的基本结构</h4><ul><li>网络包由头部和数据两部分构成<ul><li>头部包含了目的地址等控制信息,就和快递的地址电话一样</li><li>数据就相当于快递物件</li></ul></li></ul><p><img src="/images/HowNetworksWorks/46.png" alt></p><ul><li>发送网络包的时候,发送方的网络设备会负责创建包,创建包的过程就是生成含有正确控制信息的头部,然后再附上要发送的数据</li></ul><p><img src="/images/HowNetworksWorks/47.png" alt></p><p><img src="/images/HowNetworksWorks/48.png" alt></p><ul><li>首先会发往最近的网络转发设备,再发往其他网络设备,层层转发,最终达到接受方的网络设备<ul><li>路由器根据目标地址判断下一个路由器的位置</li><li>集线器在子网中将网络包传输到下一个路由</li></ul></li><li><p>集线器是按照 以太网 规则传输包的设备;而路由器是按照 IP 规则传输包的设备</p><ul><li>IP协议根据目标地址判断下一个IP转发设备的位置</li><li>子网中的以太网协议将包传输到下一个转发设备</li></ul></li><li><p>TCP/IP包含有两个头部:MAC头部（用于以太网协议）;IP头部（用于IP协议）</p></li></ul><h4 id="包的收发操作"><a href="#包的收发操作" class="headerlink" title="包的收发操作"></a>包的收发操作</h4><ul><li>在整个传输流程中,是由各种网络设备合力完成的;IP模块仅仅只是整个包的传输流程的入口</li></ul><p><img src="/images/HowNetworksWorks/49.png" alt></p><ul><li>包收发操作的起点是TCP模块委托IP模块发送网络包,这个过程中TCP模块在数据块前面加上TCP头部和指定通信对象的IP地址,然后传递给IP模块</li><li>收到委托后,IP模块将 前面的TCP头部和数据块 当作一个整体（二进制数据）,然后在头部添加IP头部和MAC头部</li></ul><p><img src="/images/HowNetworksWorks/50.png" alt></p><ul><li>然后封装好的包会发送给网络设备,最近的就计算机的网卡;传递给网卡的网络包是二进制的</li><li>接着网卡将二进制的数字信息转换为电信号/光信号,通过网线/光纤发送出去</li><li>然后接受方收到后,逆向操作</li></ul><h4 id="生成包含接受方-IP-地址的-IP-头部"><a href="#生成包含接受方-IP-地址的-IP-头部" class="headerlink" title="生成包含接受方 IP 地址的 IP 头部"></a>生成包含接受方 IP 地址的 IP 头部</h4><p><img src="/images/HowNetworksWorks/51.png" alt></p><ul><li><p>IP头部最重要的内容就是接受方的IP地址,这个地址是由TCP模块告知的,而TCP模块又是在执行连接操作时从应用程序那里获得这个地址的</p></li><li><p>IP头部还需要有发送方的IP地址,这个IP地址一般大家认为是发送方的计算机IP地址</p><ul><li>实际上,IP地址不是分配给计算机的,而是分配给网卡的,当计算机有多块网卡的时候就有多个IP地址（服务器就有很多块网卡）</li></ul></li></ul><p><img src="/images/HowNetworksWorks/52.png" alt></p><ul><li>如何判断把包给那块网卡呢<ul><li>其实和路由器使用 IP 表判断下一个路由器位置的操作是一样的</li><li>因为协议栈的 IP模块与路由器中负责包收发的部分都是根据 IP 协议规则来进行包收发操作的,所以它们也都用相同的方法来判断把包发送给谁</li><li>IP 表又可以叫做 路由表</li></ul></li></ul><p><img src="/images/HowNetworksWorks/53.png" alt></p><ul><li>我们对套接字中记录的目的地 IP 地址与路由表左侧的 Network Destination 栏进行比较,找到对应的一行<ul><li>例如,TCP 模块告知的目标 IP 地址为 192.168.1.21,那么就对应图中的第 6 行,因为它和 192.168.1 的部分相匹配</li><li>如果目标 IP 地址为 10.10.1.166,那么就和 10.10.1 的部分相匹配,所以对应第 3 行</li></ul></li><li>Interface 列,表示网卡等网络接口,这些网络接口可以将包发送给通信对象</li><li>Gateway 列表示下一个路由器的 IP 地址,将包发给这个 IP 地址,该地址对应的路由器就会将包转发到目标地址 </li><li><p>路由表的第 1 行中,目标地址和子网掩码 A 都是 0.0.0.0,这表示默认网关,如果其他所有条目都无法匹配,就会自动匹配这一行</p></li><li><p>最后还需要填写协议号,它标识包的内容来自哪个模块</p><ul><li>TCP模块,06（十六进制）</li><li>UDP模块,17（十六进制）</li></ul></li></ul><h4 id="生成以太网用的-MAC-头部"><a href="#生成以太网用的-MAC-头部" class="headerlink" title="生成以太网用的 MAC 头部"></a>生成以太网用的 MAC 头部</h4><p><img src="/images/HowNetworksWorks/54.png" alt></p><ul><li>生成了 IP 头部之后,接下来 IP 模块还需要在 IP 头部的前面加上MAC 头部</li><li>IP 头部中的接收方 IP 地址表示网络包的目的地,通过这个地址我们就可以判断要将包发到哪里</li><li>但在以太网的世界中,TCP/IP 的这个思路是行不通的</li><li><p>以太网在判断网络包目的地时和 TCP/IP 的方式不同,因此必须采用相匹配的方式才能在以太网中将包发往目的地,而MAC 头部就是干这个用的</p></li><li><p>MAC 头部是以太网使用的头部,它包含了接受方和发送方的 MAC 地址信息等</p></li><li>IP 地址长度 32bit ; MAC 地址长度 48 bit</li><li><p>以太类型和协议号类似</p><ul><li>在IP中,协议号标识IP头部后面的包内容的类型</li><li>在以太网中,可以认为以太网类类型后面就是以太网包的内容<ul><li>而以太类型就表示后面内容的类型</li></ul></li><li>以太网包的内容可以是IP、ARP等协议的包</li></ul></li><li><p>以太类型,这里可以填写表示IP协议的值 0800（十六进制）</p></li><li><p>然后填写网卡本身的MAC地址,MAC地址是网卡生产时写入ROM里的,只要读取出来写入MAC头部就可以了</p></li><li><p>最后就和IP地址一样判断从那块网卡发送网络包,把这块网卡的MAC地址填进去<br><img src="/images/HowNetworksWorks/55.png" alt></p></li><li>但是,接受方的MAC地址根本不知道,所以我们还需要根据IP地址查询MAC地址的操作</li></ul><h4 id="通过-ARP-查询目标路由器的-MAC-地址"><a href="#通过-ARP-查询目标路由器的-MAC-地址" class="headerlink" title="通过 ARP 查询目标路由器的 MAC 地址"></a>通过 ARP 查询目标路由器的 MAC 地址</h4><ul><li><p>ARP:Address Resolution Protocol 地址解析协议</p></li><li><p>ARP 利用广播对连接在同一以太网中的所有设备查询 MAC 地址</p></li></ul><p><img src="/images/HowNetworksWorks/56.png" alt></p><ul><li>如果每次发送包都要这样查询一次,网络中就会增加很多 ARP包,因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用</li><li>也就是说,在发送包时,先查询一下 ARP 缓存,如果其中已经保存了对方的 MAC 地址,就不需要发送 ARP 查询,直接使用 ARP 缓存中的地址,而当 ARP 缓存中不存在对方 MAC 地址时,则发送 ARP 查询</li></ul><p><img src="/images/HowNetworksWorks/57.png" alt></p><p><img src="/images/HowNetworksWorks/58.png" alt></p><ul><li><p>ARP缓存中的地址会在一定时间后被删除,避免读取到IP地址发生变化后造成的差异</p></li><li><p>将 MAC 头部加在 IP 头部前面,整个包就完成了</p></li><li>到此为止,整个打包工作是由 IP 模块完成的<ul><li>这样的好处是,在把数据包交给网卡之前就打包好</li><li>这样一来,网卡就可以支持各种类型的包,网卡专注于收发</li></ul></li></ul><h4 id="以太网的结构"><a href="#以太网的结构" class="headerlink" title="以太网的结构"></a>以太网的结构</h4><ul><li>IP 模块的工作完成后,就轮到网卡开始工作了</li></ul><p><img src="/images/HowNetworksWorks/59.png" alt></p><ul><li>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术</li><li>收发器:将不同网线之间的信号连接起来</li><li>尽管以太网经历了数次变迁,但其基本的 3 个性质至今仍未改变<ul><li>即将包发送到 MAC 头部的接收方 MAC 地址代表的目的地</li><li>用发送方 MAC地址识别发送方</li><li>用以太类型识别包的内容</li></ul></li><li>因此,可以认为具备这3 个性质的网络就是以太网</li></ul><h4 id="将-IP-包转换成电或光信号发送出去"><a href="#将-IP-包转换成电或光信号发送出去" class="headerlink" title="将 IP 包转换成电或光信号发送出去"></a>将 IP 包转换成电或光信号发送出去</h4><ul><li>IP 生成的网络包只是存放在内存中的一串数字信息</li><li>因此,需要将数字信号转换成电信号或者光信号,才能在网线上传输</li><li>负责执行这个操作的就是网卡,但是网卡也无法单独工作,需要控制网卡就需要网卡驱动程序</li></ul><p><img src="/images/HowNetworksWorks/60.png" alt></p><ul><li>MAC:Media Access Control</li></ul><p><img src="/images/HowNetworksWorks/61.png" alt></p><ul><li>可以从网卡 ROM 中读出 MAC 值 设置给 MAC 模块</li><li>也可以从命令或配置中读取 MAC 值<ul><li>这种情况下,网卡会忽略ROM 中的 MAC 地址</li></ul></li><li>有人认为在网卡通电之后,ROM 中的 MAC 地址就自动生效了,其实不然,真正生效的是网卡驱动进行初始化时在 MAC模块中设置的那个 MAC 地址</li></ul><h4 id="给网络包再加3个控制数据"><a href="#给网络包再加3个控制数据" class="headerlink" title="给网络包再加3个控制数据"></a>给网络包再加3个控制数据</h4><p><img src="/images/HowNetworksWorks/62.png" alt></p><ul><li>网卡驱动从IP模块获取到包之后,将其复制到网卡内的缓冲区中,然后向 MAC 模块发送 “发送包” 的指令</li><li><p>MAC 模块将包从缓冲区中取出,并在开头添加 报头、起始帧分节符,在末尾添加用于检测错误的帧校验序列 （历史原因,帧和包是一个意思）</p></li><li><p>报头是一串像 10101010…这样 1 和 0 交替出现的比特序列,长度为 56比特,它的作用是确定包的读取时机</p></li><li>当这些 1010 的比特序列被转换成电信号后,会形成如下图这样的波形</li><li>接收方在收到信号时,遇到这样的波形就可以判断读取数据的时机</li></ul><p><img src="/images/HowNetworksWorks/63.png" alt></p><ul><li>用电信号来表达数字信息是,需要让0和1两种比特分别对应特定的电压和电流</li></ul><p><img src="/images/HowNetworksWorks/64.png" alt></p><ul><li>在测量电压和电流的时候,必须先判断出每个比特的界限在哪,要不连续同种比特出现的时候就很难切分（连续1111或00000）</li><li>为了解决这个问题,引入一组用来区分比特间隔的时钟信号<ul><li>当时钟信号变化时,读取电压和电流值,和0或1对应</li><li>但是距离较远时,网线较长时,数据信号和时钟信号的传输会产生时间差,时钟就会发生偏移</li></ul></li><li>为了解决偏差,采用将数据信号和时钟信号叠加在一起的方法</li></ul><h4 id="向集线器发送网络包"><a href="#向集线器发送网络包" class="headerlink" title="向集线器发送网络包"></a>向集线器发送网络包</h4><ul><li>发送信号的操作分为两种<ul><li>一种是使用集线器的半双工模式</li><li>另一种是使用交换机的全双工模式</li></ul></li><li>在半双工模式中,为了避免信号碰撞,需要先判断网线中是否存在其他信号设备发送信号<ul><li>有则等待,没有即可发送</li></ul></li><li>首先,MAC 模块从报头开始将数字信号按每个比特转成电信号,然后由PHY或叫MAU的信号收发模块发送出去<ul><li>MAU:Medium Attachment Unit 介质连接单元</li><li>PHY:Physical Layer Device 物理层装置</li><li>根据以太网的信号方式的不同,叫法不同,速度在100Mbit/s以上的以太网中都叫PHY</li><li>在这里,将数字信号转换成电信号的速率就是网络传输速率<br><img src="/images/HowNetworksWorks/65.png" alt></li></ul></li><li>接下来,PHY模块会将信号转换为可以在网线上传输的格式,并通过网线发送出去<ul><li>以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定</li><li>但 MAC 模块并不关心这些区别,而是将可转换为任意格式的通用信号发送给 PHY（MAU）模块</li><li>然后 PHY（MAU）模块再将其转换为可在网线上传输的格式</li></ul></li></ul><p><img src="/images/HowNetworksWorks/66.png" alt></p><ul><li>PHY不仅仅只是转换信号,还需要监控接收线路有无信号进来,避免信号碰撞</li><li><p>如果发生了信号碰撞,还会发送一段阻塞信号,通知所有发送操作停止</p><ul><li>并且根据 MAC 地址生成随机数,错开重新发送信号时间</li><li>当网络拥塞的时候,发送碰撞的可能性提高</li><li>多次拥塞等待后,就报告通信错误</li></ul></li><li><p>另一种全双工模式,可以同时接收和发送,不会发生碰撞</p></li></ul><h4 id="接收网络包"><a href="#接收网络包" class="headerlink" title="接收网络包"></a>接收网络包</h4><ul><li>PHY （MAU）模块会将信号转换成通用格式并发送给 MAC 模块</li><li>MAC 模块再从头开始将信号转换为数字信息,并存放到缓冲区中</li><li>当到达信号的末尾时,还需要检查 FCS</li><li>检查 MAC 头部中接收方MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致</li><li><p>无误后,网卡通知计算机收到了一个网络包</p></li><li><p>计算机并不是一直监控着网卡,需要网卡去打断计算机正在执行的任务,注意到自己,这种机制就是中断</p></li></ul><h4 id="将服务器的响应包从-IP-传递给-TCP"><a href="#将服务器的响应包从-IP-传递给-TCP" class="headerlink" title="将服务器的响应包从 IP 传递给 TCP"></a>将服务器的响应包从 IP 传递给 TCP</h4><ul><li>首先收到包,肯定是先检查以太类型,确定是什么协议;0800就是TCP/IP</li><li>接着检查IP头部、查看接受方IP地址<ul><li>如果IP格式无误,接受方IP地址和客户端网卡地址一致,就可以接收这个包了</li></ul></li><li>如果接受方的IP不是自己的,发生了这样的错误时,IP模块会通过ICMP消息将错误告诉发送方</li></ul><p><img src="/images/HowNetworksWorks/67.png" alt></p><h3 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h3><h4 id="不需要重发的数据用-UDP-发送更高效"><a href="#不需要重发的数据用-UDP-发送更高效" class="headerlink" title="不需要重发的数据用 UDP 发送更高效"></a>不需要重发的数据用 UDP 发送更高效</h4><ul><li>TCP 设计得如此完善,就是要确保它的数据可靠性</li><li>如果数据很短,不用分包,一个包就足够的情况下,就不需要考虑漏包等问题了<ul><li>一旦丢失或未送达就重发,就就一个包,根本不影响效率</li><li>这样就不需要 TCP 这么复杂的机制了</li></ul></li><li>发送了数据,对方给出回复就可以</li></ul><h4 id="控制用的短数据"><a href="#控制用的短数据" class="headerlink" title="控制用的短数据"></a>控制用的短数据</h4><ul><li>像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围就可以解决,这种场景就可以用 UDP 来代替 TCP<ul><li>UDP 没有 TCP 的接收确认、窗口等机制,因此在收发数据之前也不需要交换控制信息,也就是说不需要建立建立和断开连接的步骤</li><li>只需要从应用程序获取的数据前面加上 UDP 头部,然后交给 IP 模块发送就可以了</li></ul></li></ul><p><img src="/images/HowNetworksWorks/68.png" alt></p><ul><li>在线播放音频和视频数据的时候,也会使用 UDP ,因为这些数据必须在规定时间内达到,否则会错过时机,导致卡顿<ul><li>一旦错过时间,重发数据也没有用;</li><li>在这些无需重发,或者重发也没意义的场景,用 UDP 效率更高</li></ul></li></ul><h2 id="从网线到网络设备—集线器、交换机、路由器"><a href="#从网线到网络设备—集线器、交换机、路由器" class="headerlink" title="从网线到网络设备—集线器、交换机、路由器"></a>从网线到网络设备—集线器、交换机、路由器</h2><p><img src="/images/HowNetworksWorks/69.png" alt></p><h3 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h3><ul><li>每个包都是独立传输的<ul><li>每个阶段的都不会关心上个阶段的包内部内容</li><li>每个后面的阶段只会根据上阶段传输过来的包头部中的控制信息,进行操作</li></ul></li></ul><p><img src="/images/HowNetworksWorks/70.png" alt></p><ul><li>电信号会在传输过程中逐渐衰弱<ul><li>电信号频率越高,能量损失率越大,因此传输过程就会失真</li><li>如果再加上噪音,失真就更厉害,进一步影响0,1的判断,这就是产生通信错误的原因<br><img src="/images/HowNetworksWorks/71.png" alt></li></ul></li><li>局域网使用的网线就是双绞线,双绞就是把两根信号线为一组缠绕在一起,这样就是为了抑制噪音<ul><li>产生噪音的原因就是网线周围的电磁波,电磁波接触到导体时会在其中产生电流,干扰原有的电流<br><img src="/images/HowNetworksWorks/72.png" alt></li></ul></li><li><p>影响网线的电磁波分为两种</p><ul><li>一种是电机、荧光灯、CRT显示器等设备泄露出来的电磁波,这类电磁波来自网线外部</li><li>另一种是是从网线相邻的信号线泄露出来的,这类内部产生的噪音称为串扰<br><img src="/images/HowNetworksWorks/73.png" alt></li></ul></li><li><p>除了用“双绞”的方式外,在信号线之间加入隔板距离以及在外面包裹可阻挡电磁波的金属屏蔽网等也可以抑制信号干扰</p></li><li>网线的性能是以“类”来区分的<br><img src="/images/HowNetworksWorks/74.png" alt></li></ul><ul><li>当信号到达集线器后,会被广播到整个网络中<ul><li>以太网的基本架构就是将包发到所有的设备</li><li>然后由设备根据接收方 MAC 地址来判断应该接收哪些包,</li><li>而集线器就是这一架构的忠实体现,它就是负责按照以太网的基本架构将信号广播出去<br><img src="/images/HowNetworksWorks/75.png" alt></li></ul></li></ul><h3 id="交换机的包转发操作"><a href="#交换机的包转发操作" class="headerlink" title="交换机的包转发操作"></a>交换机的包转发操作</h3><h4 id="交换机根据地址表进行转发"><a href="#交换机根据地址表进行转发" class="headerlink" title="交换机根据地址表进行转发"></a>交换机根据地址表进行转发</h4><p><img src="/images/HowNetworksWorks/76.png" alt></p><ul><li>信号到网线接口,由PHY模块接收,转换成数字信号,校验包末尾的FCS,无误则存放到缓冲区</li><li>交换机一个端口可以当作一个网卡,但是交换机端口不具有MAC地址</li><li>存到缓冲区之后,就会查询这个包的接受方地址是否在MAC地址表中<ul><li>该MAC地址表与端口一一对应,就能判断出包该转发到哪个端口</li></ul></li></ul><h4 id="MAC-地址表的维护"><a href="#MAC-地址表的维护" class="headerlink" title="MAC 地址表的维护"></a>MAC 地址表的维护</h4><ul><li>交换机在转发包的过程中,还需要对MAC地址表内容进行维护</li><li>维护分两种<ul><li>一种是记住每个发送方的MAC地址以及输出端口的号码,这样以后每次有一样的情况就可以重复执行</li><li>另一种是删除地址表中的某条记录,防止发送端的设备移动了,地址表信息造成错误,因此地址表也会在一段时间不使用后删除</li><li>重启交换机可立刻清空并更新地址表的记录<ul><li>在地址表错误的情况下又发送包,造成通信错误的情况下可重启交换机<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4></li></ul></li></ul></li></ul><p><img src="/images/HowNetworksWorks/77.png" alt></p><ul><li>交换机查询地址表之后发现记录中的目标端口和这个包的源端口是同一个端口<ul><li>当像上图这样用集线器和交换机连接在一起时就会遇到这样的情况</li><li>首先,计算机 A 发送的包到达集线器后会被集线器转发到所有端口上,也就是会到达交换机和计算机 B</li><li>这时,交换机转发这个包之后,这个包会原路返回集线器</li><li>然后,集线器又把包转发到所有端口,于是这个包又到达了计算机 A 和计算机 B</li><li>所以计算机 B 就会收到两个相同的包,这会导致无法正常通信</li><li>因此,当交换机发现一个包要发回到原端口时,就会直接丢弃这个包</li></ul></li><li>地址表中找不到指定的MAC地址<ul><li>这可能是因为具有该地址的设备还没有向交换机发送过包,或者这个设备一段时间没有工作导致地址被从地址表中删除了</li><li>这种情况下,交换机无法判断应该把包转发到哪个端口,只能将包转发到除了源端口之外的所有端口上</li><li>无论该设备连接在哪个端口上都能收到这个包</li><li>这样做不会产生什么问题,因为以太网的设计本来就是将包发送到整个网络的,然后只有相应的接收者才接收包,而其他设备则会忽略这个包</li></ul></li></ul><h4 id="全双工模式可以同时进行发送和接收"><a href="#全双工模式可以同时进行发送和接收" class="headerlink" title="全双工模式可以同时进行发送和接收"></a>全双工模式可以同时进行发送和接收</h4><ul><li>全双工模式是交换机特有的工作模式,它可以同时进行发送和接收操作,集线器不具备这样的特性</li><li>使用集线器时,如果多台计算机同时发送信号,信号就会在集线器内部混杂在一起,进而无法使用<ul><li>这种现象称为碰撞,是以太网的一个重要特征</li><li>不过,只要不用集线器,就不会发生碰撞</li></ul></li><li>使用双绞线时,发送和接收的信号线是各自独立的<ul><li>如果不存在碰撞,也就不需要半双工模式中的碰撞处理机制了</li><li>也就是说,发送和接收可以同时进行</li><li>然而,以太网规范中规定了在网络中有信号时要等该信号结束后再发送信号,因此发送和接收还是无法同时进行</li><li>于是,人们对以太网规范进行了修订,增加了一个无论网络中有没有信号都可以发送信号的工作模式,同时规定在这一工作模式下停用碰撞检测,这种工作模式就是全双工模式</li><li>在全双工模式下,无需等待其他信号结束就可以发送信号,因此它比半双工模式速度要快</li><li>由于双方可以同时发送数据,所以可同时传输的数据量也更大,性能也就更高</li></ul></li></ul><h4 id="自动协商-确定最优传输速率"><a href="#自动协商-确定最优传输速率" class="headerlink" title="自动协商:确定最优传输速率"></a>自动协商:确定最优传输速率</h4><ul><li>随着全双工模式的出现,如何在全双工和半双工模式之间进行切换的问题也产生了</li></ul><p><img src="/images/HowNetworksWorks/78.png" alt></p><ul><li>在全双工模式出现的时候,需要手动切换模式</li><li>后来出现了自动切换模式的模式,可以由相互连接双方检测对方是否支持全双工模式,并自动切换成对应的工作模式<ul><li>此外,还能探测对方的传输速率进行自动切换,这种自动切换称为自动协商</li></ul></li><li><p>在以太网中,当没有数据在传输时,就会填充一种叫做连接脉冲的脉冲信号</p><ul><li>使得网络中一致保持一定的信号流过,从而能够检测对方是否在正常工作,或者说网线有没有正常连接</li><li>以太网设备的网线接口周围有个绿色指示灯,表示是否检测到正常的脉冲信号<ul><li>灯亮,说明PHY模块以及网线正常<br><img src="/images/HowNetworksWorks/79.png" alt></li></ul></li></ul></li><li><p>后来,人们又设计出了上图具有特定排列的脉冲信号,通过这种信号可以将自身的状态告知对方</p><ul><li>自动协商就利用了这样的脉冲信号,将自己能够支持的工作模式和传输速率相互告知对方,并从中选择一个最优的组合</li></ul></li></ul><p><img src="/images/HowNetworksWorks/80.png" alt></p><ul><li>假设现在连接双方的情况如上表所示<ul><li>网卡一方支持所有的速率和工作模式,而交换机只支持到 100 Mbit/s 全双工模式</li><li>当两台设备通电并完成硬件初始化之后,就会开始用脉冲信号发送自己支持的速率和工作模式</li><li>当对方收到信号之后,会通过读取脉冲信号的排列来判断对方支持的模式,然后看看双方都支持的模式有哪些</li><li>表是按照优先级排序的,因此双方都支持的模式就是第 3 行及以下的部分</li><li>越往上优先级越高,因此在本例中 100 Mbit/s 全双工模式就是最优组合</li><li>于是双方就会以这个模式开始工作</li></ul></li></ul><h4 id="交换机可以同时执行多个转发操作"><a href="#交换机可以同时执行多个转发操作" class="headerlink" title="交换机可以同时执行多个转发操作"></a>交换机可以同时执行多个转发操作</h4><p><img src="/images/HowNetworksWorks/76.png" alt></p><ul><li>交换机只将包转发到具有特定 MAC 地址的设备连接的端口,其他端口都是空闲的<ul><li>如图,当包从最上面的端口发送到最下面的端口时,其他端口都处于空闲状态,这些端口可以传输其他的包,</li><li>因此交换机可以同时转发多个包</li></ul></li><li>相对地,集线器会将输入的信号广播到所有的端口<ul><li>如果同时输入多个信号就会发生碰撞,无法同时传输多路信号</li><li>因此从设备整体的转发能力来看,交换机要高于集线器</li></ul></li></ul><h3 id="路由器的包转发操作"><a href="#路由器的包转发操作" class="headerlink" title="路由器的包转发操作"></a>路由器的包转发操作</h3><h4 id="路由器的基本结构"><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h4><ul><li>路由器也是通过查表判断包转发的目标的,工作原理和交换机类似</li><li>不过路由器是基于IP设计的,交换机是基于以太网设计的</li></ul><p><img src="/images/HowNetworksWorks/81.png" alt></p><ul><li><p>转发模块负责判断包的转发目的地,端口模块负责包的收发操作</p><ul><li>换句话说,路由器转发模块和端口模块的关系,就相当于协议栈的 IP 模块和网卡之间的关系</li><li>因此,可以将路由器的转发模块想象成 IP 模块,将端口模块想象成网卡</li><li>通过更换网卡,计算机不仅可以支持以太网,也可以支持无线局域网,路由器也是一样</li><li>如果路由器的端口模块安装了支持无线局域网的硬件,就可以支持无线局域网了</li><li>此外,计算机的网卡除了以太网和无线局域网之外很少见到支持其他通信技术的品种</li><li>而路由器的端口模块则支持除局域网之外的多种通信技术,如ADSL、FTTH,以及各种宽带专线等,只要端口模块安装了支持这些技术的硬件即可</li></ul></li><li><p>端口模块是以实际的发送方或接受方的身份来执行包收发操作的</p><ul><li>意味着路由器的各个端口都具有MAC地址和IP地址</li><li>而交换机只是将进来的包转发出去而已,它自己并不会称为发送方或者接受方</li></ul></li></ul><h4 id="路由表中的信息"><a href="#路由表中的信息" class="headerlink" title="路由表中的信息"></a>路由表中的信息</h4><ul><li>交换机是通过MAC头部中的接受方MAC地址来判断转发目标的,而路由器是根据IP头部中的IP地址来判断的</li></ul><p><img src="/images/HowNetworksWorks/82.png" alt></p><ul><li>路由器会忽略主机号,只匹配网络号</li></ul><p><img src="/images/HowNetworksWorks/83.png" alt></p><h4 id="路由器的包收发操作"><a href="#路由器的包收发操作" class="headerlink" title="路由器的包收发操作"></a>路由器的包收发操作</h4><ul><li>首先,信号到达网线接口部分,其中的 PHY（MAU）模块和 MAC 模块将信号转换为数字信息</li><li>然后通过包末尾的 FCS 进行错误校验,</li><li>如果没问题则检查 MAC 头部中的接收方 MAC 地址,</li><li>看看是不是发给自己的包,如果是就放到接收缓冲区中,否则就丢弃这个包</li><li>如果包的接收方 MAC地址不是自己,说明这个包是发给其他设备的,如果接收这个包就违反了以太网的规则</li></ul><p><img src="/images/HowNetworksWorks/84.png" alt></p><h4 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h4><ul><li>路由器接收到包之后,就会丢弃包开头的MAC头部<ul><li>因为这个包的MAC头部就是为了将包送达路由器,之后就没作用了,自然被丢弃<br><img src="/images/HowNetworksWorks/85.png" alt></li></ul></li><li>然后就根据MAC头部后方的IP头部中的内容判断转发操作</li><li>查询路由表判断转发目标,根据包的接受方IP查询路由表中的目标栏,找到相匹配的记录</li><li>如果路由表中无法找到匹配的记录,则会丢弃这个包,通过ICMP消息告知发送方<ul><li>这里和交换机不一样,交换机连接的的网络最多也就几千台设备的规模,交换机找不到匹配的记录的时候,会发送到所有端口</li><li>但是路由器的工作设备都在互联网上,规模还在持续扩大,因此为了不造成网络拥塞,只能将匹配不到对应记录的包丢弃</li></ul></li></ul><h4 id="找不到匹配路由时选择默认路由"><a href="#找不到匹配路由时选择默认路由" class="headerlink" title="找不到匹配路由时选择默认路由"></a>找不到匹配路由时选择默认路由</h4><ul><li><p>互联网中那么多转发目标,不可能都配置在路由器中</p><ul><li>关键就在于把子网掩码设置为 0.0.0.0 <ul><li>这样无论任何地址都能匹配到这条记录,就不会发生匹配不到的记录了</li></ul></li><li>这个配置的网关地址被称为默认网关,和在计算机里面设置TCP.IP填的默认网关一样<br><img src="/images/HowNetworksWorks/86.png" alt></li></ul></li><li><p>这样一来就可以层层追溯查找出转发目标</p></li></ul><h4 id="包的有效期"><a href="#包的有效期" class="headerlink" title="包的有效期"></a>包的有效期</h4><ul><li>找到转发目标后,还会更新IP头部中的TTL(Time to live)</li><li>TTL表示了包的有效期,包每经过一个路由器的时候,这个值就会减1,当这个值为0的时候,就会被丢弃</li><li>这个机制是为了包在一个地方进入死循环<ul><li>发生死循环的情况在于路由表配置信息有误,或者网络故障</li></ul></li><li>发送方在发送包时会将 TTL 设为 64 或 128,也就是说包经过这么多路由器后就会“寿终正寝”</li><li>现在的互联网即便访问一台位于地球另一侧的服务器,最多也只需要经过几十个路由器,因此只要包被正确转发,就可以在过期之前到达目的地</li></ul><h4 id="通过分片功能拆分大网络包"><a href="#通过分片功能拆分大网络包" class="headerlink" title="通过分片功能拆分大网络包"></a>通过分片功能拆分大网络包</h4><ul><li>路由器的端口并不只有以太网一种,也可以支持其他局域网或专线通信技术</li><li><p>由于不同线路的输出输入端口的最大包长度不同,所以为了避免数据包受影响,而采用IP协议中的分片功能对包进行拆分</p><ul><li>这里和TCP拆分的机制不同<ul><li>TCP是将拆好的数据块正好装进一个包里</li><li>从IP角度来看,这个包还是一个未拆分的整体</li></ul></li><li>IP分辨是对一个完整的包再拆分的过程<br><img src="/images/HowNetworksWorks/87.png" alt></li></ul></li><li><p>MTU:包能传输的最大数据长度</p></li><li>首先查看IP头部的标志字段,确认是否可以分片（一般都是可以的,除非发送方设置了不允许,或者这个包已经被分片过了）</li><li><p>如果不能分片,只能丢弃,并通过ICMP消息通知发送方</p></li><li><p>在分片中,TCP以及后面的数据都是可以分片的,从IP角度来看,TCP的请求数据也是网络包数据的一部分</p></li><li>然后就会在每个分片加上IP头部,MAC头部</li></ul><h4 id="路由器的发送操作和计算机相同"><a href="#路由器的发送操作和计算机相同" class="headerlink" title="路由器的发送操作和计算机相同"></a>路由器的发送操作和计算机相同</h4><ul><li>准备工作完成就会进入包的发送操作<ul><li>将包转换成什么信号,取决于输出端口的类型,以太网则是电信号<br><img src="/images/HowNetworksWorks/88.png" alt></li></ul></li></ul><h4 id="路由器和交换机的关系"><a href="#路由器和交换机的关系" class="headerlink" title="路由器和交换机的关系"></a>路由器和交换机的关系</h4><p><img src="/images/HowNetworksWorks/89.png" alt></p><ul><li>路由器在转发网络包的时候,都要在包的头部加上MAC头部<ul><li>准确说,应该是将IP网络包装进以太网包的数据部分</li><li>委托以太网去传输这些数据</li></ul></li><li>IP协议本身没有传输包的功能,包的实际传输要委托以太网来执行</li><li>路由器是基于IP设计的,交换机是基于以太网设计的<ul><li>IP与以太网的关系,也就是路由器与交换机的关系</li></ul></li><li>当然上面的基本理论只适用于“纯粹”的路由器和交换机</li><li><p>目前的路由器都内置有交换机功能了,但是底层本质还是不变</p></li><li><p>从包的转发目标也可以看出路由器和交换机之间的委托关系。IP 并不是委托以太网将包传输到最终目的地,而是传输到下一个路由器。在创建MAC 头部时,也是从 IP 的路由表中查找出下一个路由器的 IP 地址,并通过 ARP 查询出 MAC 地址,然后将 MAC 地址写入 MAC 头部中的,这表示 IP 对以太网的委托只是将包传输到下一个路由器就行了。当包到达下一个路由器后,下一个路由器又会重新委托以太网将包传输到再下一个路由器。随着这一过程反复执行,包就会最终到达 IP 的目的地,也就是通信的对象</p></li></ul><p><img src="/images/HowNetworksWorks/90.png" alt></p><h3 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h3><ul><li>地址转换、包过滤</li><li>最初的互联网没有内外网区分,所有客户端都是直接连接到互联网的,并每台设备都能够分配到属于自己的IP地址</li><li>后来设备越来越多,为了解决这个问题才有了内外网的概念</li></ul><p><img src="/images/HowNetworksWorks/91.png" alt></p><ul><li>内网地址-私有地址;外网地址-公有地址</li><li>内网可用的私有地址<ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul></li><li>为什么上面这些地址用作私有地址,其实在制定私有地址的时候,上面那些地址属于公有地址中还没被分配的范围而已</li><li>这样就解决了内外网分配不足的问题,但是两个内网想要通过互联网通信并且私有地址又相同怎么办<ul><li>这样的情况就需要用到了路由器的地址转换功能</li></ul></li></ul><h4 id="地址转换的原理"><a href="#地址转换的原理" class="headerlink" title="地址转换的原理"></a>地址转换的原理</h4><ul><li>地址转换的基本原理是在转发网络包时对IP头部中的IP地址和端口号进行改写</li><li>具备地址转换功能的设备不仅有路由器,有些防火墙也有地址转换功能</li></ul><p><img src="/images/HowNetworksWorks/92.png" alt></p><h4 id="改写端口号的原因"><a href="#改写端口号的原因" class="headerlink" title="改写端口号的原因"></a>改写端口号的原因</h4><ul><li>现在的地址转换机制是同时改写地址和端口号,但是早期的地址转换只是改写地址<ul><li>但是这种方法的前提是私有地址和公有地址一一对应</li><li>需求数量多起来共有地址就不够用了,因此也要改写端口号</li><li>端口号是一个16bit的数值,可用分配出几万个端口,就完全够用了</li></ul></li></ul><h4 id="从互联网访问公司内网"><a href="#从互联网访问公司内网" class="headerlink" title="从互联网访问公司内网"></a>从互联网访问公司内网</h4><ul><li>没有在访问互联网的内网设备,是无法从互联网想起发起网络包的</li><li>因为从内网去访问外网的时候,用来改写的公有地址就是地址转换设备自身的地址,端口号随便选个空闲的就行</li><li>从外网去访问内网的话,因为在地址表中没有记录,意味着地址转换设备无法判断公网地址和内网地址的对应关系<br><img src="/images/HowNetworksWorks/93.png" alt></li><li>但是如果想要从外网去访问内网的话,需要手动添加对应的关系记录</li></ul><h4 id="路由器的包过滤功能"><a href="#路由器的包过滤功能" class="headerlink" title="路由器的包过滤功能"></a>路由器的包过滤功能</h4><ul><li>包过滤就是在对包进行转发时,根据MAC头部、IP头部、TCP头部的内容,按照事先设置好的规则决定是转发这个包,还是丢弃这个包<ul><li>防火墙等软件,大多数就利用这个机制来防止非法入侵的</li></ul></li></ul><h2 id="通过接入网进入互联网内部—接入网、网络运营商"><a href="#通过接入网进入互联网内部—接入网、网络运营商" class="headerlink" title="通过接入网进入互联网内部—接入网、网络运营商"></a>通过接入网进入互联网内部—接入网、网络运营商</h2><h3 id="ADSL-接入网的结构和工作方式"><a href="#ADSL-接入网的结构和工作方式" class="headerlink" title="ADSL 接入网的结构和工作方式"></a>ADSL 接入网的结构和工作方式</h3><p><img src="/images/HowNetworksWorks/94.png" alt></p><ul><li><p>接入网,是之连接互联网与家庭、公司网络的通信线路</p><ul><li>接入网这个词表示的是通信线路的用法,而不是表示通信线路的结构<ul><li>公司里使用的专线,当它用来连接互联网的时候叫做接入网;而用来连接总公司和分公司的时候就不叫接入网</li><li>这个词不局限于互联网,运营商提高通信服务时,将用户和运营商之间的线路叫做接入网</li></ul></li></ul></li><li><p>互联网接入路由器是按照入网规则来发送网络包的</p></li><li><p>一般加用接入网方式:ADSL、FFTH、电话线、ISDN等</p><ul><li>ADSL:Asymmetric Digital Subscriber Line 不对称数字用户线<ul><li>它是一种利用架设在电线杆上的金属电话线来通信的技术、上行与下行的通信速率不对称</li><li>上行:用户到互联网（上传）;下行:互联网到用户（下载）</li></ul></li><li>FTTH:Fiber TO The Home 光纤入户</li></ul></li></ul><h4 id="ADSL-Modem-工作方式"><a href="#ADSL-Modem-工作方式" class="headerlink" title="ADSL Modem 工作方式"></a>ADSL Modem 工作方式</h4><p><img src="/images/HowNetworksWorks/95.png" alt></p><ul><li>上图中的网络包是从右向左传输的</li></ul><p><img src="/images/HowNetworksWorks/96.png" alt></p><ul><li><p>网络包从用户传输到运营商的过程中,会变换几种不同的形态:</p></li><li><p>客户端生成的网络包 1、2,先经过集线器和交换机到达互联网接入路由器 3</p></li><li>互联网接入路由器从以太网包中取出IP包并判断转发目标 4</li><li>然后根据互联网接入路由器和ADSL Modem之间的以太网规则添加头部信息 5</li></ul><p><img src="/images/HowNetworksWorks/97.png" alt></p><ul><li>ADSL Modem 接收到网络包 6 ,然后拆分成信元 7 <ul><li>信元是一个非常小的数据库,开头是有5个字节的头部,后面是48字节的数据,用于一种叫做ATM的通信技术（Asynchronous Transfer Mode 异步传输）</li></ul></li><li><p>将信元转换成电信号 8 （将数字信号转换成模拟信号）</p><ul><li>以太网采用的是方波信号表示0和1的方式,而ADSL采用圆滑波形（正弦波）来表示0和1的技术,称为 调制</li><li><p>调制有很多方式,ADSL 采用的调制方式是振幅调制（ASK）和相位调制（PSK）相结合的正交振幅调制（QAM）方式</p><p>  <img src="/images/HowNetworksWorks/98.png" alt></p><ul><li>振幅调制是用信号的强弱,也就是信号振幅的大小来对应 0 和 1 的方式</li><li>如图,振幅小的信号为 0,振幅大的信号为 1,这是一种最简单的对应关系。在这个例子中,振幅大小只有两个级别,如果增加振幅变化的级别,就可以对应更多的比特</li><li>例如,如果将振幅增加到 4 个级别,则振幅从小到大可分别对应 00、01、10 和 11,这样就可以表示两个比特了</li><li>这样做可以将单位时间内传输的数据量加倍,也就能够提高速率。以此类推,如果振幅有 8 个级别,就可以表示 3 个比特,16 个级别就可以表示 4 个比特,速率也就越来越高</li><li>不过,信号会在传输过程中发生衰减,也会受到噪声影响而失真,如果振幅级别太多,接收方对信号的识别就容易出错,因此振幅级别也不能太多<br><img src="/images/HowNetworksWorks/99.png" alt></li><li>组成要素是相位调制,这是一种根据信号的相位来对应 0 和 1的方式</li><li>Modem 产生的信号是以一定周期振动的波,如图所示,振动的起始位置不同,波的形状也就不同</li><li>如果将波的一个振动周期理解为一个圆,则起始位置就可以用 0 度到 360 度的角度来表示,这个角度就是相位,用角度来对应 0 和 1 的方式就叫作相位调制</li><li>例如,从 0 度开始的波为 0,从 180 度开始的波为 1,这是一种最简单的对应关系,如图所示</li><li>和振幅调制一样,相位调制也可以通过将角度划分为更细的级别来增加对应的比特数量,从而提高速率</li><li>但是,角度太接近的时候也容易产生误判,因此这样提升速率还是有限度的</li></ul></li><li>ADSL 使用的正交振幅调制就是将前面这两种方式组合起来实现的<ul><li>正交振幅调制中,通过增加振幅和相位的级别,就可以增加能表示的比特数</li><li>例如,如果振幅和相位各自都有 4 个级别,那么组合起来就有 16个级别,也就可以表示 4 个比特的值</li><li>当然,和单独使用振幅调制或相位调制的情况一样,级别过多就容易发生误判,因此这种方法提升的速率是有限度的    </li></ul></li><li>实际上信号不一定要限制在一个频率<ul><li>不同频率的波可以合成,也可以用滤波器从合成的波中分离出某个特定频率的波</li><li>因此,我们可以使用多个频率合成的波来传输信号,这样一来,能够表示的比特数就可以成倍提高了</li></ul></li><li>ADSL 就是利用了这一性质,通过多个波增加能表示的比特数来提高速率的<br>  <img src="/images/HowNetworksWorks/100.png" alt></li><li><p>ADSL 技术中,上行方向（用户到互联网）和下行方向（互联网到用户）的传输速率是不同的,原因也在这里</p><ul><li>如果上行使用 26 个频段,下行则可以使用 95 个或者 223 个频段,波的数量不同,导致了上下行速率不同</li></ul></li><li><p>ADSL Modem 将信元转换为电信号之后,信号会进入一个叫作分离器的设备,然后 ADSL 信号会和电话的语音信号混合起来一起从电话线传输出去</p><ul><li>在信号从用户端发送出去时,电话和 ADSL 信号只是同时流到一条线路上而已,分离器实际上并没有做什么事</li></ul></li><li>分离器的作用其实在相反的方向,也就是信号从电话线传入的时候;这时,分离器需要负责将电话和 ADSL 的信号进行分离<ul><li>电话线传入的信号是电话的语音信号和 ADSL 信号混合在一起的,如果这个混合信号直接进入电话机,ADSL 信号就会变成噪音,导致电话难以听清</li><li>为了避免这样的问题,就需要通过分离器将传入的信号分离,以确保 ADSL信号不会传入电话机</li><li>具体来说,分离器的功能是将一定频率以上的信号过滤掉,也就是过滤掉了 ADSL 使用的高频信号,这样一来,只有电话信号才会传入电话机,但对于另一头的 ADSL Modem,则是传输原本的混合信号给它</li><li>ADSL Modem 内部已经具备将 ADSL 频率外的信号过滤掉的功能,因此不需要在分离器进行过滤<br><img src="/images/HowNetworksWorks/101.png" alt></li></ul></li><li>从分离器出来后,就是电话线的接口,通过室内电话线到达大楼的中间配线盘和主配线盘<ul><li>这里将外面的电话线和室内的电话线连接起来</li></ul></li><li>通过配线盘后,信号达到保安器;保安器是为了防止雷电</li><li>然后信号进入电线杆上架设的电话电缆<br><img src="/images/HowNetworksWorks/102.png" alt></li><li>然后沿着电线杆侧面的金属管进入地下,电话局附近的地下都是电缆<br><img src="/images/HowNetworksWorks/103.png" alt></li></ul></li><li>信号要通过电话线到达电话局之后,会经过配线盘、分离器到达 DSLAM 9 （DSL Access Multiplexer 数字用户接入复用设备）<ul><li>DSLAM 它是一种电话局用的多路ADSL Modem ,可用理解为多个ADSL Modem整合在一个外壳里的设备</li></ul></li></ul><p><img src="/images/HowNetworksWorks/96.png" alt></p><ul><li>然后电信号会被还原成数字信息——信元 10</li><li>接着到达 BAS 的包转发设备 11 ,在这里将 ATM 信元还原成原始的包 12</li><li>然后 BAS 取出数据 13 ;MAC 头部和 PPPoE 头部的作用是将包送达到 BAS ,完成任务后被丢弃</li><li>紧接着,在包前面加上隧道专用头部 14,并发送到隧道的出口 </li><li>网络包达到隧道出口的隧道专用路由器 15,在这里丢弃掉隧道专用头部并取出 IP 包 16</li><li>最后转发到互联网内部 17</li></ul><h3 id="光纤接入网（FTTH）"><a href="#光纤接入网（FTTH）" class="headerlink" title="光纤接入网（FTTH）"></a>光纤接入网（FTTH）</h3><h4 id="光纤的基本结构"><a href="#光纤的基本结构" class="headerlink" title="光纤的基本结构"></a>光纤的基本结构</h4><p><img src="/images/HowNetworksWorks/104.png" alt></p><ul><li>它由一种双层结构的纤维状透明材质（玻璃和塑料）构成,通过在里面的纤芯中传导光信号来传输数字信息,亮表示1,暗表示0</li></ul><p><img src="/images/HowNetworksWorks/105.png" alt></p><ul><li>先将数字信息转换成电信号,再将电信号转换成光信号<ul><li>电信号,1用高电压表示,0用低电压表示</li><li>这些光源就会根据信号电压的变化发光,高电压发光亮,低电压发光暗</li><li>这样的光信号在光纤中传导之后,就可以通过光纤到达接收端</li><li>接收端有可以感应光线的光敏元件,光敏元件可以根据光的亮度产生不同的电压</li><li>当光信号照射到上面时,光亮的时候就产生高电压,光暗的时候就产生低电压,这样就将光信号转换成了电信号</li><li>最后再将电信号转换成数字信息,我们就接收到数据了</li></ul></li></ul><h4 id="单模和多模"><a href="#单模和多模" class="headerlink" title="单模和多模"></a>单模和多模</h4><ul><li><p>光纤通信的关键技术就是能够传导光信号的光纤<br><img src="/images/HowNetworksWorks/106.png" alt></p></li><li><p>光源在所有方向上都会发光,因此会有各种角度的光线进入纤芯,但入射角度太大的光线会在纤芯和包层（纤芯外沿部分）的边界上折射出去,只有入射角较小的光线会被包层全反射,从而在纤芯中前进</p></li><li><p>也不是所有入射角小的光线都会在纤芯中传导</p><ul><li>光也是一种波,当光线在纤芯和包层的边界上反射时,会由于反射角产生相位变化</li><li>当朝反射面前进的光线和被反射回来的光线交会时,如果两条光线的相位不一致,就会彼此发生干涉抵消,只有那些相位一致的光线才会继续在光纤中传导<br><img src="/images/HowNetworksWorks/107.png" alt></li></ul></li></ul><p><img src="/images/HowNetworksWorks/108.png" alt></p><ul><li><p>大多数角度都会因为相位不同而被干涉抵消,只有少数按照特定角度入射以保持一致的光纤才会继续传导</p></li><li><p>根据纤芯直径,光纤可以划分成几种类型,大体上包括较细的单模光纤（8～10 μm）和较粗的多模光纤（50 μm 或 62.5 μm）</p><ul><li><p>单模光纤的纤芯很细,只有入射角很小的光线才能进,因此在能够保持相位一致的角度中,只有角度最小的光线能进入光纤</p><ul><li>单模光纤的纤芯直径就是按照只允许相位一致的最小角度的光进入而设计的</li></ul></li><li><p>多模光纤的纤芯比较粗,入射角比较大的光也可以进入,这样一来,在相位一致的角度中,不仅角度最小的可以在光纤中传导,其他角度更大一些的也可以,也就是说,可以有多条光线在纤芯中同时传导</p></li></ul></li><li><p>单模和多模实际上表示相位一致的角度有一个还是多个<br>  <img src="/images/HowNetworksWorks/109.png" alt>   </p></li><li><p>单模光纤和多模光纤在光的传导方式上有所不同,这决定了它们的特性也有所不同</p><ul><li>多模光纤中可以传导多条光线,这意味着能通过的光线较多,对光源和光敏元件的性能要求也就较低,从而可以降低光源和光敏元件的价格</li><li>相对地,单模光纤的纤芯中只能传导一条光线,能通过的光线较少,相应地对于光源和光敏元件的性能要求就较高,但信号的失真会比较小</li></ul></li><li><p>信号失真与光在纤芯传导时反射的次数相关</p><ul><li>多模光纤中,多条反射角不同的光线同时传导,其中反射角越大的光线反射次数越多,走过的距离也就越长;</li><li>相对地,反射角越小的光线走过的距离越短。光通过的距离会影响其到达接收端的时间,也就是说,通过的距离越长,到达接收端的时间越长</li><li>结果,多条光线到达的时间不同,信号的宽度就会被拉伸,这就造成了失真</li><li>因此,光纤越长,失真越大,当超过允许范围时,通信就会出错<br><img src="/images/HowNetworksWorks/110.png" alt></li></ul></li><li>相对地,单模光纤则不会出现这样的问题。因为在纤芯传导的光线只有一条,不会因为行进距离的差异产生时间差,所以即便光纤很长,也不会产生严重的失真</li><li>光纤的最大长度也是由上述性质决定的。单模光纤的失真小,可以比多模光纤更长</li><li>因此多模光纤主要用于一座建筑物里面的连接,单模光纤则用于距离较远的建筑物之间的连接</li><li>FTTH 属于后者,因此主要使用单模光纤</li></ul><h4 id="通过光纤分路来降低成本"><a href="#通过光纤分路来降低成本" class="headerlink" title="通过光纤分路来降低成本"></a>通过光纤分路来降低成本</h4><p><img src="/images/HowNetworksWorks/111.png" alt></p><ul><li>用光纤来代替 ADSL 将用户端接入路由器和运营商的 BAS 连接起来的接入方式就是 FTTH ,从形态上可大致分为两种<ul><li>一种是用一根光纤直接从用户端连接到最近的电话局<ul><li>首先,用户端的光纤收发器将以太网的电信号转换成光信号</li><li>这一步只进行电信号到光信号的转换,而不会像 ADSL 一样还需要将包拆分成信元,将以太网包原原本本地转换成了光信号</li><li>接下来,光信号通过连接到光纤收发器的光纤直接到达 BAS 前面的多路光纤收发器</li><li>FTTH 一般使用单模光纤,因此其纤芯中只有特定角度的光信号能够反射并前进</li><li>然后,多路光纤收发器将光信号转换成电信号,BAS的端口接收之后,将包转发到互联网内部</li><li>把网络包发送到互联网之后,服务器会收到响应,响应包的光信号也是沿着同一条光纤传输到用户端</li><li>这里,前往互联网的上行光信号和前往用户的下行光信号在光纤中混合在一起,信号会变得无法识别</li><li>因此需要对它们进行区分,办法是上行和下行信号采用不同波长的光</li><li>波长不同的光混合后可通过棱镜原理进行分离,因此光纤中的上行和下行信号即便混合起来也可以识别</li><li>像这样在一条光纤中使用不同的波长传输多个光信号的方式叫作波分复用</li></ul></li><li>另一种光纤的接入方式是在用户附近的电线杆上安装一个名为分光器的设备,通过这个设备让光纤分路,同时连接多个用户<ul><li>在这种方式下,用户端不使用光纤收发器,而是使用一个叫作 ONU（Optical Network Unit 光网络单元） 的设备,它将以太网的电信号转换成光信号之后,会到达 BAS 前面的一个叫作 OLTC（Optical Line Terminal 光线路终端）的设备</li><li>信号的传导方式和刚才介绍的直连方式是一样的,但有一点不同,因为多个用户同时收发网络包时信号会在分光器产生碰撞</li><li>OLT 和 ONU 中具备通过调整信号收发时机来避免碰撞的功能<ul><li>OLT 会调整信号发送时机并向 ONU 下发指令,ONU 则根据 OLT 的指令来发送数据。反过来,当 BAS 端向用户发送数据时,分光器只需要将信号发给所有用户就可以了,这里并不会发生碰撞,但这样做会导致一个用户收到其他所有用户的信号,造成信息泄露的问题</li><li>因此需要在每个包前面加上用于识别 ONU 的信息,当 ONU 收到信号后,会接收发给自己的信号并将其转换成以太网信号</li></ul></li></ul></li></ul></li></ul><h3 id="接入网中使用-PPP-和隧道"><a href="#接入网中使用-PPP-和隧道" class="headerlink" title="接入网中使用 PPP 和隧道"></a>接入网中使用 PPP 和隧道</h3><h4 id="用户认证和配置下发"><a href="#用户认证和配置下发" class="headerlink" title="用户认证和配置下发"></a>用户认证和配置下发</h4><ul><li>用户发送的网络包会通过 ADSL 和 FTTH 等接入网达到运营商的 BAS</li><li>BAS 由接入网连接的路由器演变而来</li><li>ADSL 和 FFTH 接入网中,都需要用户认证和配置下发</li><li>BAS 使用 PPPoE(Point-to-Point Protocol over Ethernet 以太网的点对点协议) 方式来实现用户验证<ul><li>PPPoE 由传统的电话拨号上网使用的 PPP 协议发展而来的</li></ul></li></ul><p><img src="/images/HowNetworksWorks/112.png" alt></p><ul><li>关键在 2-3 的下发的 TCP/IP 配置信息<ul><li>在接入互联网的时候,必须为计算机分配一个公有地址,但这个地址并不是事先确定的</li><li>因为在拨号连接时,可以根据电话号码来改变接入点,而不同的接入点具有不同的 IP 地址,因此无法事先在计算机上设置这个地址</li><li>所以,在连接时运营商会向计算机下发 TCP/IP 配置信息,其中就包括为计算机分配的公有地址</li></ul></li></ul><h4 id="在以太网上传输-PPP-消息"><a href="#在以太网上传输-PPP-消息" class="headerlink" title="在以太网上传输 PPP 消息"></a>在以太网上传输 PPP 消息</h4><ul><li>ADSL 和 FTTH 接入方式也需要为计算机分配公有地址才能上网,这一点和拨号上网是相同的<ul><li>不过,ADSL 和 FTTH 中,用户和 BAS 之间是通过电缆或光纤固定连接在一起的,因此没有必要验证用户身份,所以实际上并不需要 PPP 的所有这些功能</li><li>然而,通过用户名和密码登录的步骤可以根据用户名来切换不同的运营商,这很方便 </li><li>因此,接入运营商在ADSL 和 FTTH 中一般也会使用 PPP</li></ul></li><li>传输 PPP 消息的思路和将 IP 包装入以太网包中传输的思路是一样的</li></ul><p><img src="/images/HowNetworksWorks/113.png" alt><br><img src="/images/HowNetworksWorks/114.png" alt></p><ul><li>PPPoE 是将 PPP 消息装入以太网包进行传输的方式</li></ul><h4 id="通过隧道将网络包发送给运营商"><a href="#通过隧道将网络包发送给运营商" class="headerlink" title="通过隧道将网络包发送给运营商"></a>通过隧道将网络包发送给运营商</h4><ul><li>BAS 除了作为用户认证的窗口之外,还可以使用隧道方式来传输网络包<ul><li>隧道就类似于套接字之间建立TCP连接一样</li></ul></li><li>无论任何机制,只要能够将包原封不动搬运到另一端,从原理上看就可以用来建立隧道<br><img src="/images/HowNetworksWorks/115.png" alt></li></ul><h4 id="接入网的整体工作过程"><a href="#接入网的整体工作过程" class="headerlink" title="接入网的整体工作过程"></a>接入网的整体工作过程</h4><ul><li>接入网的工作从用户端的互联网接入路由器进行连接操作开始<ul><li>首先接入路由器中需要设置运营商分配的用户名和密码</li><li>然后根据 PPPoE 的发现机制来寻找 BAS <ul><li>这个机制是 ARP 一样是基于广播来实现的<br><img src="/images/HowNetworksWorks/116.png" alt></li></ul></li></ul></li><li><p>然后进入用户认证和配置下发阶段</p><ul><li>重点在于如何将用户名和密码发送给 BAS<ul><li>有两种方式,一种是将密码加密的 CHAP（Challenge Handshake Authentication Protocol 挑战握手认证协议）</li><li>另一种是不加密的 PAP（Password Authentication Protocol 密码验证协议）</li></ul></li><li>第二个重点在,校验密码之后 BAS 如何向用户发 TCP/IP配置信息<ul><li>配置信息包括分配给上网设备的IP地址、DNS服务器的IP地址以及默认网关的IP地址<br><img src="/images/HowNetworksWorks/117.png" alt></li></ul></li></ul></li><li><p>接下来,接入网路由器判断转发目标后,按照PPPoE规则转发</p><ul><li>会在包前面加入MAC头部、PPPoE头部和PPP头部信息<br><img src="/images/HowNetworksWorks/118.png" alt></li><li>第一个 MAC 头部中,接收方 MAC 地址填写通过 PPPoE 发现机制查询到的BAS 的 MAC 地址,发送方 MAC 地址填写互联网接入路由器的 BAS 端的端口的 MAC 地址,然后以太类型填写代表 PPPoE 的 8864（十六进制）</li><li>接下来加入PPPoE头部和PPP头部,除了载荷长度以外都是可以事先确定的<ul><li>载荷长度就是需要传输的包的长度</li></ul></li></ul></li><li>接下来,网络包会到达 BAS,而 BAS 会将 MAC 头部和 PPPoE 头部去掉,取出 PPP 头部以及后面的部分,然后通过隧道机制将包发送出去</li><li>最后,PPP 包会沿隧道到达另一端的出口,也就是网络运营商的路由器</li></ul><h4 id="不分配-IP-地址的无编号端口"><a href="#不分配-IP-地址的无编号端口" class="headerlink" title="不分配 IP 地址的无编号端口"></a>不分配 IP 地址的无编号端口</h4><ul><li>一对一连接的端口可以不分配IP地址,这种方式称为无编号</li></ul><h4 id="互联网接入路由器将私有地址转换成公有地址"><a href="#互联网接入路由器将私有地址转换成公有地址" class="headerlink" title="互联网接入路由器将私有地址转换成公有地址"></a>互联网接入路由器将私有地址转换成公有地址</h4><ul><li>互联网接入路由器在转发包时需要进行地址转换</li><li>BAS 向用户下发 TCP/IP 配置信息,如果这些配置在计算机上,相当于计算机有了公有地址,就不需要地址转换</li><li>然后如果使用路由器上网,BAS下发的参数就会配置在路由器上,公有地址就分配给了路由器,计算机就没有公有地址了<ul><li>这是,计算机会被分配到一个私有地址,计算机发送的包需要通过路由器进行地址转换,然后再转发到互联网中</li></ul></li><li>有些应用程序需要将自己的IP告知通信对象,但因为地址转换这些操作无法完成<ul><li>但是目前由很多解决方案解决了这些问题</li><li>遇到这种情况,我们可以不适用路由器,而是让计算机直接接收来自 BAS 的 PPPoE 消息</li></ul></li></ul><h4 id="除-PPPoE-之外的其他方式"><a href="#除-PPPoE-之外的其他方式" class="headerlink" title="除 PPPoE 之外的其他方式"></a>除 PPPoE 之外的其他方式</h4><ul><li>PPPoA (Point-to-Point Protocol over ATM)</li><li>ADSL 使用PPPoE 方式时,是先将 PPP 消息装入以太网包中,然后再将以太网包拆分并装入信元,而 PPPoA 方式是直接将 PPP 消息装入信元</li><li>由于只是开头加不加 MAC 头部和 PPPoE 头部的区别,PPP 消息本身是没有区别的,因此密码校验、下发 TCP/IP 配置参数、收发数据包等过程都是和PPPoE 基本相同的</li><li>由于 PPPoA 没有 MAC 头部,所以 PPP 消息是无法通过以太网来传输的,这就意味着需要和 BAS 收发 PPP 消息的设备,也就是计算机和路由器,必须和 ADSL Modem 是一体的,否则 PPP 机制就无法工作了<ul><li>这个一体化的方式主要有以下两种</li><li>第一种是将计算机和 ADSL Modem 用 USB 接口连接起来,这样ADSL Modem 就和计算机成为一体了;不过,这种方式最终并没有普及</li><li>另一种方式是如图所示的,将 ADSL Modem 和路由器整合成一台设备。这种方式和 PPPoE 中使用路由器上网的方式基本没什么区别,因此得到了广泛的普及<ul><li>不过,当由于地址转换产生问题时,这种方式就不容易处理了,因为我们无法抛开路由器用计算机直接上网<br><img src="/images/HowNetworksWorks/119.png" alt></li></ul></li></ul></li><li>当然,PPPoA 和 PPPoE 相比也有一些优势<ul><li>PPPoE 方式中,需要添加 PPPoE 头部和 PPP 头部,这意味着 MTU 就相应变小了,这可能会降低网络的效率</li><li>而 PPPoA 不使用以太网包来传输 PPP 消息,因此不会发生 MTU 变小的问题</li></ul></li><li>PPPoE 会降低网络效率,PPPoA 也有 ADSL Modem 和路由器无法分离的限制,这两个问题其实都是由 PPP 引起的。因此,有一些运营商不使用 PPP,他们使用 DHCP 协议从 BAS 向用户端下发 TCP/IP 配置信息<ul><li>DHCP:Dynamic Host Configuration Protocol,动态主机配置协议</li><li>使用信元的 PPPoE 和 PPPoA 方式中,BAS 需要配备比较昂贵的 ATM 接口,因此不使用信元还可以控制成本</li><li>DHCP 经常用于通过公司网络向客户端计算机下发 TCP/IP 配置信息<ul><li>首先客户端请求配置信息,然后 DHCP服务器下发配置信息,非常简单,不需要像 PPP 那样需要多个步骤,也不需要验证用户名和密码</li><li>没有用户名和密码就意味着无法通过用户名来切换运营商网络,但这种方式也有优势,它可以单纯地直接传输以太网包,不需要添加额外的 PPP 头部,因此不会占用 MTU<br><img src="/images/HowNetworksWorks/120.png" alt> </li></ul></li></ul></li><li><p>此外,采用 DHCP 的运营商使用的 ADSL Modem 也和 PPPoE、PPPoA方式不同,这种 ADSL Modem 不使用信元,而是直接将以太网包调制成ADSL 信号,因此没有 ADSL Modem 和路由器无法分离的问题</p></li><li><p>还有一种 DHCP 方式,它不使用 PPP,而是将以太网包直接转,而是将以太网包直接转换成换成 ADSL</p></li><li>ADSL 信号发送给信号发送给 DSLAM</li></ul><h3 id="网络运营商的内部"><a href="#网络运营商的内部" class="headerlink" title="网络运营商的内部"></a>网络运营商的内部</h3><h3 id="POP-和-NOC"><a href="#POP-和-NOC" class="headerlink" title="POP 和 NOC"></a>POP 和 NOC</h3><p><img src="/images/HowNetworksWorks/121.png" alt></p><ul><li>POP:Point of Presense 接入点</li><li>现在网络包已经到达网络运营商的路由器,网络包会从这里进入互联网内部</li><li>互联网的实体是由多个运营商网络相互连接组成的</li><li>ADSL、FTTH等接入网是与用户签约的运营商设备相连接的,这些设备称为POP,互联网的入口就位于这里</li></ul><p><img src="/images/HowNetworksWorks/122.png" alt></p><ul><li>根据不同的接入网类型使用不同类型的路由器<ul><li>专线使用具备通信线路端口的一般路由器,因为专线不需要用户认证,配置下发等功能<ul><li>专线是固定连接线路,不需要进行身份认证,参数是根据传真、书面等方式下发后进行手动配置的,因此也不需要 PPP、DHCP 等机制;其实,这就是最古老的互联网接入方式</li></ul></li><li>电话/ISDN等拨号方式使用称作RAS的路由器,拨号接入需要对用户拨电话的动作进行应答<ul><li>RAS也具备身份认证、配置下发功能</li></ul></li><li>PPPoE 方式中,ADSL、FTTH 接入服务商会使用 BAS,运营商的路由器则与 BAS 相连<ul><li>PPoE 中的身份认证和配置下发操作由接入服务商的 BAS 来负责,运营商的路由器只负责对包进行转发,因此这里也是使用一般的路由器就可以了</li></ul></li><li>如果 ADSL 采用 PPPoA 方式接入,那么工作过程会有所不同,DSLAM 通过 ATM 交换机与 ADSL 的运营商的 BAS 相连,然后再连接到运营商的路由器<ul><li>用户端传输的信号先经过 ADSL Modem 拆分成 ATM 信元并进行调制,然后 DSLAM 将信号还原成信元,通过 ATM 交换机转发到 BAS,最后 BAS 将信元还原成网络包,再通过运营商的路由器转发到互联网内部</li></ul></li></ul></li></ul><ul><li>接入网部分,传输的网络包相对少,而线路数量很多,需要配置大量端口,因此端口多价格低的路由器适合用在此场景</li><li>运营商POP部分要处理大量的接入网传过来的网络包,这里需要分配转发性能和数据吞吐量高的路由器</li><li>NOC（Network Operation Center）是运营商的核心设备,从POP传过来的网络包会集中到这里,然后再转发到其他POP或者运营商</li></ul><h4 id="室外通信线路的连接"><a href="#室外通信线路的连接" class="headerlink" title="室外通信线路的连接"></a>室外通信线路的连接</h4><ul><li>POP和NOC遍布全国各地,规模有大有小,和平常的机房一样都是位于一幢建筑物中,但运营商的网络中需要传输大量的包,一般更多的是使用光纤</li><li>拥有光纤的运营商可以选择自己用光纤将NOC和POP直接连接起来</li><li>维护和修建光纤设施,需要不少费用,没有光纤的运营商就需要租借别人的光纤<ul><li>拥有光纤的公司一般会对外提供光纤租用服务</li><li>这样没有光纤的运营商页可以通过租用别人的光纤将相距较远的NOC和POP连接起来</li></ul></li></ul><h3 id="跨越网络运营商的网络包"><a href="#跨越网络运营商的网络包" class="headerlink" title="跨越网络运营商的网络包"></a>跨越网络运营商的网络包</h3><h4 id="运营商之间的路由器信息交换"><a href="#运营商之间的路由器信息交换" class="headerlink" title="运营商之间的路由器信息交换"></a>运营商之间的路由器信息交换</h4><ul><li>如果路由表中没有相应的路由信息,路由器就无法对包进行转发,因此仅仅用线路将路由器连起来,还是无法完成包转发的</li><li>运营商之间可以交换路由信息,让相连接的路由器告知路由信息</li><li><p>获得对方的路由信息之后,我们也需要将自身的路由信息告知对方。这样一来,对方也可以将发往我们所在子网的包转发过来。这个路由信息交换的过程是由路由器自动完成的,这里使用的机制称为 BGP（Border Gateway Protocol 边界网关协议）<br><img src="/images/HowNetworksWorks/123.png" alt></p></li><li><p>根据所告知的路由信息的内容,这种路由交换可分为两类</p><ul><li>一类是将互联网中的路由全部告知对方。<ul><li>如图,如果运营商 D 将互联网上所有路由都告知运营商 E</li><li>则运营商 E 不但可以访问运营商 D,还可以访问运营商 D 后面的运营商 B、A 和 C</li><li>然后,通过运营商 D 就可以向所有的运营商发送包</li><li>像这样,通过运营商 D 来发送网络包的方式称为 转接</li></ul></li><li>另一种类型是两个运营商之间仅将与各自网络相关的路由信息告知对方<ul><li>这样,只有双方之间的网络可以互相收发网络包,这种方式称为非转接,也叫对等</li></ul></li></ul></li></ul><p><img src="/images/HowNetworksWorks/124.png" alt></p><h4 id="与公司网络中自动更新路由表机制的区别"><a href="#与公司网络中自动更新路由表机制的区别" class="headerlink" title="与公司网络中自动更新路由表机制的区别"></a>与公司网络中自动更新路由表机制的区别</h4><ul><li>路由器之间相互交换信息自动更新路由表的方式在公司网络中也会用到,不过公司内部和运营商之间在路由交换方式上是有区别的<ul><li>公司中使用的方式是寻找与目的地之间的最短路由,并按照最短路由来转发包,因此,周围的所有路由器都是平等对待的</li><li>公司内部采用这样的方式没问题,但运营商之间就不行了</li><li>假设某个运营商拥有一条连接日本和美国的高速线路,那么要访问美国的地址时,可能这条线路是最短路由</li><li>如果单纯采用最短路由的方式,那么其他运营商的包就都会走这条线路,这时,该运营商需要向其他运营商收取相应的费用,否则就成义务劳动了<ul><li>同时页无法区分哪些运营商有无付费,也无法阻止没付费的运营商使用这条线路</li></ul></li><li>因此,互联网中不能单纯的采用最短路由</li></ul></li><li>运营商之间的路由交换是在特定的路由器间一对一进行的,这样就可以只将路由信息提供给那些付了费的运营商<ul><li>该机制也可以设置其他判断因素,设置路线优先级</li></ul></li></ul><h4 id="IX-的必要性"><a href="#IX-的必要性" class="headerlink" title="IX 的必要性"></a>IX 的必要性</h4><ul><li><p>IX:Internet eXchange 互联网交换中心<br><img src="/images/HowNetworksWorks/125.png" alt></p></li><li><p>设置中心设备,通过连接中心设备的方式来减少路线数量</p></li></ul><h4 id="运营商如何通过-IX-互相连接"><a href="#运营商如何通过-IX-互相连接" class="headerlink" title="运营商如何通过 IX 互相连接"></a>运营商如何通过 IX 互相连接</h4><ul><li>IX 的部署场所需要能够防御一定的自然灾害、保持继续工作</li><li>IX 所在的场所一般都装有自主发电设备<ul><li>这个要求不局限于IX,运营商NOC等也一样<br><img src="/images/HowNetworksWorks/126.png" alt></li></ul></li><li>IX 的核心是具有大量高速以太网端口的二层交换机<ul><li>原理和一般交换机相同</li></ul></li><li>IX 的交换机和一般的交换机在工作方式上没有区别,路由器发送网络包时,先通过 ARP 查询下一个路由器的 MAC 地址,然后将其写入 MAC 头部发送出去即可<ul><li>只要填写了正确的 MAC 地址,就可以向任何运营商的路由器发送包</li></ul></li></ul><h2 id="服务器端的局域网运作方式"><a href="#服务器端的局域网运作方式" class="headerlink" title="服务器端的局域网运作方式"></a>服务器端的局域网运作方式</h2><h3 id="Web-服务器的部署地点"><a href="#Web-服务器的部署地点" class="headerlink" title="Web 服务器的部署地点"></a>Web 服务器的部署地点</h3><p><img src="/images/HowNetworksWorks/127.png" alt></p><ul><li>a 的方式需要为客户端和服务器各自分配公有地址,然而目前公有地址不够用,这种方式已经不是主流了<ul><li>另外还有安全问题</li></ul></li><li>b 可以解决一定的安全问题</li><li>c 将服务器放在运营商那边,或者是租用运营商的服务器,利用可运营商的安全等等各自服务,相对更为可靠</li></ul><h3 id="防火墙的结构和原理"><a href="#防火墙的结构和原理" class="headerlink" title="防火墙的结构和原理"></a>防火墙的结构和原理</h3><ul><li>防火墙基本思路是只允许往特定服务器中的特定应用程序的包通过,屏蔽其他的包</li><li>防火墙可分为包过滤、应用层网关、电路层网关等</li></ul><h4 id="设置包过滤的规则"><a href="#设置包过滤的规则" class="headerlink" title="设置包过滤的规则"></a>设置包过滤的规则</h4><ul><li>网络包的头部包含了用于控制通信操作的控制信息,只要检查这些信息就可以获得很多有用的信息</li></ul><p><img src="/images/HowNetworksWorks/128.png" alt></p><ul><li>下图允许 Web 服务器从外网访问,禁止 Web 服务器访问互联网</li></ul><p><a href="/images/HowNetworksWorks/129.png"></a></p><ul><li>设置接受方和发送方的地址信息过滤网络包 </li><li>还可以限定某个应用程序的包通过,设置TCP或UDP头部的端口号 </li><li><p>设置TCP的控制位信息,阻断TCP建立连接</p></li><li><p>而UDP,没有连接操作,无法根据控制位来判断访问方向</p><ul><li>代表例子就是对DNS服务器的访问</li><li>这种情况只能二者择其一,要么冒风险允许该应用程序的所有包通过,要么牺牲便利性阻止该应用程序的所有包通过</li></ul></li></ul><p><a href="/images/HowNetworksWorks/130.png"></a></p><ul><li>实际上,在防火墙允许包通过之后,就没有什么特别的机制了<ul><li>因此包过滤并不是防火墙专用的一种特殊机制,而是应该看作在路由器的包转发功能基础上附加的一种功能</li><li>只不过当判断规则比较复杂时,通过路由器的命令难以维护这些规则,而且对阻止的包进行记录对于路由器来说负担也比较大,因此才出现了专用的硬件和软件</li><li>如果规则不复杂,也不需要记录日志,那么用内置包过滤功能的普通路由器来充当防火墙也是可以的</li></ul></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>当访问量上升时,可以增加带宽来解决一定的问题</li><li>带宽高可用使网络速度变快,但是并不能解决所有问题</li><li><p>使用多台服务器来分担负载的方法更加有效,这种架构统称为分布式架构</p></li><li><p>分担负载的方法有几种,最简单的是用多台服务器,减少每台服务器的访问量</p><ul><li>要实现这种方法,必须需要一种机制将客户端发送的请求分配到每台服务器上</li><li>做法也有很多种,最简单是通过DNS服务器来分配<ul><li>访问服务器时,客户端需要先向 DNS 服务器查询服务器的 IP地址,如果在 DNS 服务器中填写多个名称相同的记录,则每次查询时DNS 服务器都会按顺序返回不同的 IP 地址<ul><li>对于域名 <a href="http://www.lab" target="_blank" rel="noopener">www.lab</a>. glasscom.com,如果我们给它分配如下 3 个 IP 地址<ul><li>192.0.2.60</li><li>192.0.2.70</li><li>192.0.2.80<ul><li>当第 1 次查询这个域名时,服务器会返回如下内容</li></ul></li><li>192.0.2.60 192.0.2.70 192.0.2.80<ul><li>当第 2 次查询这个域名时,服务器会返回如下内容</li></ul></li><li>192.0.2.70 192.0.2.80 192.0.2.60<ul><li>当第 3 次查询这个域名时,服务器会返回如下内容</li></ul></li><li>192.0.2.80 192.0.2.60 192.0.2.70<ul><li>第4次就回到第一次的结果,这种方式称为 轮询（round-robin）</li></ul></li></ul></li></ul></li></ul></li><li>这种方式是有缺点的,假如其中一台服务器故障,就无法跳过该服务器,依然指向该服务器;因为DNS服务器并不能确认Web服务器是否正常工作<br><a href="/images/HowNetworksWorks/131.png"></a></li></ul></li><li><p>为了可以跳过故障服务器,可用使用一种叫做负载均衡器的设备</p><ul><li>使用负载均衡器时,首先要用负载均衡器的 IP 地址代替 Web 服务器的实际地址注册到 DNS 服务器上<ul><li>假设有一个域名 <a href="http://www.lab.glasscom.com,我们将这个域名对应的" target="_blank" rel="noopener">www.lab.glasscom.com,我们将这个域名对应的</a> IP 地址设置为负载均衡器的 IP 地址并注册到 DNS 服务器上</li><li>于是,客户端会认为负载均衡器就是一台 Web 服务器,并向其发送请求</li><li>然后由负载均衡器来判断将请求转发给哪台 Web 服务器<br><a href="/images/HowNetworksWorks/132.png"></a></li></ul></li></ul></li><li><p>负载均衡器可以定期采集 Web 服务器的 CPU、内存使用率,并根据这些数据判断服务器的负载状况,也可以向 Web 服务器发送测试包,根据响应所需的时间来判断负载状况</p></li><li><p>当操作跨多个页面时,则不考虑 Web 服务器的负载,而是必须将请求发送到同一台 Web 服务器上</p><ul><li>要实现这一点,关键在于我们必须要判断一个操作是否跨了多个页面</li><li>HTTP 的基本工作方式是在发送请求消息之前先建立 TCP 连接,当服务器发送响应消息后断开连接,下次访问 Web 服务器的时候,再重新建立 TCP 连接 </li><li>因此,在 Web 服务器看来,每一次HTTP 访问都是相互独立的,无法判断是否和之前的请求相关</li><li>之所以会这样,是因为 Web 中使用的 HTTP 协议原本就是这样设计的<ul><li>Web 服务器最早并不是用来运行CGI 程序的,而是主要用来提供静态文件的,而静态文件不需要判断请求之间的相关性,因此最早设计 HTTP 规格的时候,就有意省略了请求之间相关性的判断</li></ul></li><li>如果要判断请求之间的相关性,就必须在 Web 服务器一端保存相应的信息,这会增加服务器的负担</li><li>于是,人们想出了一些方案来判断请求之间的相关性</li><li>可以在发送表单数据时在里面加上用来表示关联的信息,或者是对 HTTP 规格进行扩展,在 HTTP 头部字段中加上用来判断相关性的信息<ul><li>这种信息就是 Cookie </li></ul></li><li>这样,负载均衡器就可以通过这些信息来作出判断,将一系列相关的请求发送到同一台Web 服务器,对于不相关的请求则发送到负载较低的服务器了</li></ul></li></ul><h3 id="使用缓存服务器分担负载"><a href="#使用缓存服务器分担负载" class="headerlink" title="使用缓存服务器分担负载"></a>使用缓存服务器分担负载</h3><h4 id="缓存服务器基本思路"><a href="#缓存服务器基本思路" class="headerlink" title="缓存服务器基本思路"></a>缓存服务器基本思路</h4><ul><li><p>除了使用多台功能相同的 Web 服务器分担负载之外,还有另外一种方法,就是将整个系统按功能分成不同的服务器</p><ul><li>如 Web 服务器、数据库服务器</li><li>缓存服务器就是一种按功能来分担负载的方法</li></ul></li><li><p>缓存服务器是一台通过代理机制对数据进行缓存的服务器</p><ul><li>代理介于Web 服务器和客户端之间,具有对 Web 服务器访问进行中转的功能</li><li>当进行中转时,它可以将 Web 服务器返回的数据保存在磁盘中,并可以代替Web 服务器将磁盘中的数据返回给客户端</li><li>这种保存的数据称为缓存,缓存服务器指的也就是这样的功能</li></ul></li><li>Web 服务器需要执行检查网址和访问权限,以及在页面上填充数据等内部操作过程,因此将页面数据返回客户端所需的时间较长</li><li>相对地,缓存服务器只要将保存在磁盘上的数据读取出来发送给客户端就可以了,因此可以比 Web 服务器更快地返回数据<ul><li>其实就是缓存服务器把 Web 服务器的部分工作给分离出来了,减轻了 Web 服务器的工作量</li></ul></li><li>不过,如果在缓存了数据之后,Web 服务器更新了数据,那么缓存的数据就不能用了,因此缓存并不是永久可用的 <ul><li>此外,CGI 程序等产生的页面数据每次都不同,这些数据也无法缓存</li></ul></li><li>无论如何,在来自客户端的访问中,总有一部分访问可以无需经过 Web 服务器,而由缓存服务器直接处理。</li><li>即便只有这一部分操作通过缓存服务器提高了速度,整体性能也可以得到改善</li><li>此外,通过让缓存服务器处理一部分请求,也可以减轻 Web服务器的负担,从而缩短 Web 服务器的处理时间</li></ul><h4 id="缓存服务器通过更新实际管理内容"><a href="#缓存服务器通过更新实际管理内容" class="headerlink" title="缓存服务器通过更新实际管理内容"></a>缓存服务器通过更新实际管理内容</h4><p><a href="/images/HowNetworksWorks/133.png"></a></p><p><a href="/images/HowNetworksWorks/134.png"></a></p><ul><li>如果一台缓存服务器对应多台 Web 服务器,就需要根据请求信息的URI中的目录进行判断<ul><li>然后缓存服务器充当客户端的身份去向目标Web服务器发送请求信息</li><li>它会先创建套接字,然后连接到Web服务器的套接字,并发送请求</li><li>接着缓存服务器会在响应消息中加上 Via 头部字段,表示这个消息是经过缓存服务器中转的</li><li>最后缓存服务器充当了Web服务器的身份向客户端发送响应消息<ul><li>同时,缓存服务器会将响应消息保存在缓存中,并记录保存时间</li></ul></li></ul></li><li>在这个过程中充当了中间人的方式就是代理的基本原则</li><li>在中转消息的过程中,缓存服务器还会顺便将页面数据保存下来,随着缓存数据的积累,用户访问的数据命中缓存的几率也会提高</li></ul><p><a href="/images/HowNetworksWorks/135.png"></a></p><ul><li>如果缓存服务器中已有缓存信息的话<ul><li>缓存服务器会添加一个 If-Modified-Since 头部字段并将请求转发给 Web 服务器</li><li>询问 Web 服务器用户请求的数据是否已经发生变化<ul><li>这时, Web 服务器只要查询一下数据的最后更新时间就好了,比返回页面数据的负担要小一些;而且返回的响应消息也比较短,能相应地减少负担</li></ul></li><li>然后,Web 服务器会根据 If-Modified-Since 的值与服务器上的页面数据的最后更新时间进行比较</li><li>如果在指定时间内数据没有变化,就会返回一个像上图一样的表示没有变化的响应消息</li><li>接下来,返回消息到达缓存服务器,然后缓存服务器就会知道 Web 服务器上的数据和本地缓存中的数据是一样的,于是就会将缓存的数据返回给客户端</li></ul></li></ul><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><ul><li>上面将的是在Web服务器一端部署一个代理,然后利用其缓存功能来改善服务器性能</li><li>还有另一种方法是在客户端一侧部署缓存服务器</li><li>实际上,缓存服务器使用的代理机制最早就是放在客户端一侧的,这才是代理的原型,称为正向代理（forward proxy）<ul><li>正向代理刚刚出现的时候,其目的之一就是缓存,这个目的和服务器端的缓存服务器相同</li><li>不过,当时的正向代理还有另外一个目的,那就是用来实现防火墙</li></ul></li></ul><p><a href="/images/HowNetworksWorks/136.png"></a></p><ul><li>代理在转发过程可以查看请求的内容,可以根据内容判断是否允许访问<ul><li>包过滤方式的防火墙只能根据IP地址和端口号判断,因此无法实现这一目标</li></ul></li></ul><p><a href="/images/HowNetworksWorks/137.png"></a></p><ul><li><p>在使用正向代理时,一般需要在浏览器的设置窗口中的“代理服务器”一栏中填写正向代理的 IP 地址,浏览器发送请求消息的过程也会发生相应的变化</p><ul><li>在没有设置正向代理的情况下,浏览器会根据网址栏中输入的http://… 字符串判断 Web 服务器的域名,并向其发送请求消息</li><li>当设置了正向代理时,浏览器会忽略网址栏的内容,直接将所有请求发送给正向代理</li><li>请求消息的内容也会有一些不同<ul><li>没有正向代理时,浏览器会从网址中提取出 Web 服务器域名后面的文件名或目录名,然后将其作为请求的URI 进行发送</li><li>而有正向代理时,浏览器会像图 5.9 这样,在请求的 URI字段中填写完整的 http://… 网址</li></ul></li></ul></li><li><p>使用正向代理时,URI 部分为http://… 这样的完整网址,因此可以根据这个网址来转发,不需要像服务器端的缓存服务器一样实现设置好转发目标 Web 服务器,而且可以发给任意Web 服务器;而服务器端的缓存服务器只能向事先设置好的目标进行转发。</p></li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul><li>通过将请求消息中的 URI 中的目录名与 Web 服务器进行关联,使得代理能够转发一般的不包含完整网址的请求消息</li><li>前面所说的服务器端的缓存服务器采用的就是这种方式,这种方式称为反向代理</li></ul><h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><ul><li>前面说过缓存服务器对应多台Web服务器时,一种方式是根据请求信息的URI中的目录进行判断转发目标</li><li>另一种方式是查看请求信息的包头部,根据接受方的IP地址去访问目标,这种方式称为透明代理</li><li>这种方法也可以转发一般的请求消息,因此不需要像正向代理一样设置浏览器参数,也不需要在缓存服务器上设置转发目标,可以将请求转发给任意 Web 服务器</li><li><p>透明代理集合了正向代理和反向代理的优点,是一个非常方便的方式,但也需要注意一点,那就是如何才能让请求消息到达透明代理</p><ul><li>由于透明代理不需要设置在浏览器中,那么浏览器还是照常向 Web 服务器发送请求消息</li><li><p>反向代理采用的是通过 DNS 服务器解析引导的方法,但透明代理是不能采用这种方法的,否则透明代理本身就变成了访问目标,也就无法通过接收方 IP 地址判断转发目标了,这就失去了透明代理的意义</p></li><li><p>于是,我们必须将透明代理放在请求消息从浏览器传输到 Web 服务器的路径中,当消息经过时进行拦截</p></li><li>如果请求消息有多条路径可以到达 Web 服务器,那么就必须在这些路径上都放置透明代理,因此一般是将网络设计成只有一条路可以走的结构,然后在这一条路径上放置透明代理</li><li>连接互联网的接入网就是这样一个关口,因此可以在接入网的入口处放置反向代理</li></ul></li><li>使用透明代理时,用户不会察觉到代理的存在,也不会注意到 HTTP 消息是如何被转发的,因此大家更倾向于将透明代理说成是缓存 <ul><li>最近有很多场合中已经将透明代理直接叫作“缓存”而不是“代理”了,不过无论叫什么名字,其内部结构是相同的</li></ul></li></ul><h3 id="内容分发服务"><a href="#内容分发服务" class="headerlink" title="内容分发服务"></a>内容分发服务</h3><h4 id="利用内容分发服务分担负载"><a href="#利用内容分发服务分担负载" class="headerlink" title="利用内容分发服务分担负载"></a>利用内容分发服务分担负载</h4><p><a href="/images/HowNetworksWorks/138.png"></a></p><ul><li>将缓存服务器部署在距离用户很近的地方,同时Web 服务器运营者还可以控制这些服务器,但这种方式也有问题</li><li>对于在互联网上公开的服务器来说,任何地方的人都可以来访问它,因此如果真的要实现这个方式,必须在所有的运营商 POP 中都部署缓存服务器才行,这个数量太大了,非常不现实<ul><li>要解决这个问题也有一些办法<ul><li>首先,我们可以筛选出一些主要的运营商,这样可以减少缓存服务器的数量</li><li>尽管这样做可能会导致有些用户访问到缓存服务器还是要经过很长的距离,但总比直接访问 Web 服务器的路径要短多了,因此还是可以产生一定的效果</li></ul></li></ul></li><li>即便减少了数量,作为一个 Web 服务器运营者,如果自己和这些运营商签约并部署缓存服务器,无论是费用还是精力都是吃不消的</li><li><p>为了解决这个问题,一些专门从事相关服务的厂商出现了,他们来部署缓存服务器,并租借给 Web 服务器运营者</p><ul><li>这种服务称为内容分发服务 CDS (Content Delivery Service)</li><li>现在更常用的名字叫 CDN (Content Delivery Network / Content Distribution Network)</li></ul></li><li><p>提供 CDS 服务的厂商称为 CDSP（Content Delivery Service Provider）</p><ul><li>他们会与主要的供应商签约,并部署很多台缓存服务器 </li><li>另一方面,CDSP 会与 Web 服务器运营者签约,使得 CDSP 的缓存服务器配合 Web 服务器工作</li></ul></li><li>只要 Web 服务器与缓存服务器建立关联,那么当客户端访问 Web 服务器时,实际上就是在访问 CDSP 的缓存服务器了</li><li>缓存服务器可以缓存多个网站的数据,因此 CDSP 的缓存服务器就可以提供给多个 Web 服务器的运营者共享。<ul><li>这样一来,每个网站运营者的平均成本就降低了,从而减少了网站运营者的负担</li><li>而且,和运营商之间的签约工作也由 CDSP 统一负责,网站运营者也节省了精力</li></ul></li><li>总之,依然是采用了解耦的思想,把部分工作给分担出去了</li></ul><h4 id="寻找最近的缓存服务器"><a href="#寻找最近的缓存服务器" class="headerlink" title="寻找最近的缓存服务器"></a>寻找最近的缓存服务器</h4><p><a href="/images/HowNetworksWorks/139.png"></a></p><ul><li>如何从众多的缓存服务器中找到离客户端最近的一个,并让客户端去访问那台服务器</li><li><p>第一个方法是像负载均衡一样用 DNS 服务器来分配访问</p><ul><li><p>可以在 DNS 服务器返回 Web 服务器 IP 地址时,对返回的内容进行一些加工,使其能够返回距离客户端最近的缓存服务器的 IP 地址</p><p><a href="/images/HowNetworksWorks/140.png"></a></p></li><li><p>如果按照 DNS 服务器的一般工作方式来看,它只能以轮询方式按顺序返回 IP 地址,完全不考虑客户端与缓存服务器的远近,因此可能会返回离客户端较远的缓存服务器 IP 地址</p></li><li>如果要让用户访问最近的缓存服务器,则不应采用轮询方式,而是应该判断客户端与缓存服务器的距离,并返回距离客户端最近的缓存服务器IP 地址</li></ul></li></ul><p><a href="/images/HowNetworksWorks/141.png"></a></p><ul><li>首先需要事先从缓存服务器部署地点的路由器收集路由信息</li><li>接下来,DNS 服务器根据路由表查询从本机到 DNS 查询消息的发送方,也就是客户端 DNS 服务器的路由信息</li><li>例如,根据上图路由器 A的路由表,可以查出路由器 A 到客户端 DNS 服务器的路由。</li><li>通过互联网内部的路由表中的路由信息可以知道先通过运营商 X,然后通过运营商 Y,最后到达运营商 Z 这样的信息,通过这样的信息可以大致估算出距离</li><li>依次查询所有路由器的路由表之后,我们就可以通过比较找出哪一台路由器距离客户端 DNS 服务器最近<ul><li>提供路由表的路由器位于缓存服务器的位置,而客户端 DNS 服务器也应该和客户端在同一位置,这样就等于估算出了缓存服务器与客户端之间的距离,从而能够判断出哪台缓存服务器距离客户端最近了</li><li>实际上,客户端 DNS 服务器不一定和客户端在同一位置,因此可能无法得出准确的距离,但依然可以达到相当的精度</li></ul></li></ul><h4 id="重定向服务器分配访问目标"><a href="#重定向服务器分配访问目标" class="headerlink" title="重定向服务器分配访问目标"></a>重定向服务器分配访问目标</h4><p><a href="/images/HowNetworksWorks/142.png"></a></p><ul><li>另一个让客户端访问最近的缓存服务器的方法<ul><li>HTTP 规格中定义了很多头部字段,其中有一个叫作 Location 的字段</li><li>当 Web 服务器数据转移到其他服务器时可以使用这个字段,它的意思是“您要访问的数据在另一台服务器上,请访问那台服务器吧。”这种将客户端访问引导到另一台Web 服务器的操作称为重定向,通过这种方法也可以将访问目标分配到最近的缓存服务器<br><a href="/images/HowNetworksWorks/143.png"></a></li></ul></li><li>使用重定向告知客户端最近的缓存服务器时,首先需要将重定向服务器注册到 Web 服务器端的 DNS 服务器上<ul><li>这样一来,客户端会将 HTTP请求消息发送到重定向服务器上</li><li>重定向服务器和刚才一种方法中的 DNS服务器一样,收集了来自各个路由器的路由信息,并根据这些信息找到最近的缓存服务器,然后将缓存服务器的地址放到 Location 字段中返回响应</li></ul></li><li>这种方法的缺点在于增加了 HTTP 消息的交互次数,相应的开销也比较大,但它也有优点<ul><li>对 DNS 服务器进行扩展的方法是估算客户端 DNS 服务器到缓存服务器之间的距离,因此精度较差;相对而言,重定向的方法是根据客户端发送来的 HTTP 消息的发送方 IP 地址来估算距离的,因此精度较高</li></ul></li></ul><h4 id="缓存的更新方法会影响性能"><a href="#缓存的更新方法会影响性能" class="headerlink" title="缓存的更新方法会影响性能"></a>缓存的更新方法会影响性能</h4><ul><li>还有一个因素会影响缓存服务器的效率,那就是缓存内容的更新方法</li><li>缓存本来的思路是将曾经访问过的数据保存下来,然后当再次访问时拿出来用,以提高访问操作的效率</li><li>不过,这种方法对于第一次访问是无效的,而且后面的每次访问都需要向原始服务器查询数据有没有发生变化,如果遇到网络拥塞,就会使响应时间恶化</li><li>要改善这一点,有一种方法是让 Web 服务器在原始数据发生更新时,立即通知缓存服务器,使得缓存服务器上的数据一直保持最新状态,这样就不需要每次确认原始数据是否有变化了,而且从第一次访问就可以发挥缓存的效果<ul><li>内容分发服务采用的缓存服务器就具备这样的功能</li></ul></li><li>此外,除了事先编写好内容的静态页面之外,还有一些在收到请求后由 CGI 程序生成的动态页面,这种动态页面是不能保存在缓存服务器上的<ul><li>这种情况下,我们可以不保存整个页面,而是将应用程序生成的部分,也就是每次内容都会发生变化的动态部分,与内容不会发生变化的静态部分分开,只将静态部分保存在缓存中</li></ul></li></ul><h2 id="请求到达-Web-服务器-响应返回浏览器—短短几秒的“漫长旅途”迎来终点"><a href="#请求到达-Web-服务器-响应返回浏览器—短短几秒的“漫长旅途”迎来终点" class="headerlink" title="请求到达 Web 服务器,响应返回浏览器—短短几秒的“漫长旅途”迎来终点"></a>请求到达 Web 服务器,响应返回浏览器—短短几秒的“漫长旅途”迎来终点</h2><h3 id="服务器概览"><a href="#服务器概览" class="headerlink" title="服务器概览"></a>服务器概览</h3><ul><li>服务器的程序可以同时和多台客户端计算机进行通信</li><li>服务器需要同时和多个客户端通信,但一个程序来处理多个客户端的请求是很难的,因为服务器必须把握每一个客户端的操作状态<ul><li>一般的做法是,每有一个客户端连接进来,就启动一个新的服务器程序,确保服务器程序和客户端是一对一的状态</li></ul></li></ul><p><a href="/images/HowNetworksWorks/144.png"></a></p><ul><li>这样,在工作时就不必考虑其他客户端的连接情况,只要关心自己对应的客户端就可以了<ul><li>通过这样的方式,可以降低程序编写的难度。服务器操作系统具有多任务、多线程功能,可以同时运行多个程序,服务器程序的设计正是利用了这一功能</li><li>多任务和多线程的区别在于任务和线程的区别;在操作系统内部,任务是作为单独的程序来对待的,而线程则是一个程序中的一部分</li></ul></li></ul><p><a href="/images/HowNetworksWorks/145.png"></a></p><ul><li>客户端的数据收发需要经过下面 4 个阶段<ul><li>（1）创建套接字（创建套接字阶段）</li><li>（2）用管道连接服务器端的套接字（连接阶段）</li><li>（3）收发数据（收发阶段）</li><li>（4）断开管道并删除套接字（断开阶段）</li></ul></li><li><p>相对地,服务器是将阶段（2）改成了等待连接,具体如下</p><ul><li>（1）创建套接字（创建套接字阶段）</li><li>（2-1）将套接字设置为等待连接状态（等待连接阶段）</li><li>（2-2）接受连接（接受连接阶段）</li><li>（3）收发数据（收发阶段）</li><li>（4）断开管道并删除套接字（断开阶段）</li></ul></li><li><p>由于等待连接的模块在服务器程序启动时就已经在运行了,所以在刚启动时,应该还没有客户端的连接包到达</p><ul><li>如果包没有到达,就会转为等待包到达的状态,并在包到达的时候继续执行接受连接操作</li><li>一旦客户端的包到达,就会返回响应包并开始接受连接操作</li><li><p>协议栈会给等待连接的套接字复制一个副本,然后将连接对象等控制信息写入新的套接字中</p><p><a href="/images/HowNetworksWorks/146.png"></a></p></li></ul></li><li><p>在复制出一个新的套接字之后,原来那个处于等待连接状态的套接字会怎么样呢</p><ul><li>它还会以等待连接的状态继续存在,当再次调用 accept,客户端连接包到达时,它又可以再次执行接受连接操作</li><li>接受新的连接之后,和刚才一样,协议栈会为这个等待连接的套接字复制一个新的副本,然后让客户端连接到这个新的副本套接字上</li><li>像这样每次为新的连接创建新的套接字就是这一步操作的一个关键点<ul><li>如果不创建新副本,而是直接让客户端连接到等待连接的套接字上,那么就没有套接字在等待连接了,这时如果有其他客户端发起连接就会遇到问题</li><li>为了避免出现这样的情况,协议栈采用了这种创建套接字的新副本,并让客户端连接到这个新副本上的方法</li></ul></li></ul></li><li><p>创建新套接字时端口号也是一个关键点</p><ul><li>端口号是用来识别套接字的,因此我们以前说不同的套接字应该对应不同的端口号,但如果这样做,这里就会出现问题</li><li>因为在接受连接的时候,新创建的套接字副本就必须和原来的等待连接的套接字具有不同的端口号才行</li><li>这样一来,比如客户端本来想要连接 80 端口上的套接字,结果从另一个端口号返回了包,这样一来客户端就无法判断这个包到底是要连接的那个对象返回的,还是其他程序返回的</li><li>因此,新创建的套接字副本必须和原来的等待连接的套接字具有相同的端口号</li><li>但是这样一来又会引发另一个问题。</li><li>端口号是用来识别套接字的,如果一个端口号对应多个套接字,就无法通过端口号来定位到某一个套接字了</li><li>当客户端的包到达时,如果协议栈只看 TCP 头部中的接收方端口号,是无法判断这个包到底应该交给哪个套接字的</li></ul></li><li><p>这个问题可以用下面的方法来解决,即要确定某个套接字时,不仅使用服务器端套接字对应的端口号,还同时使用客户端的端口号再加上 IP 地址,总共使用下面 4 种信息来进行判断</p><ul><li>客户端 IP 地址</li><li>客户端端口号</li><li>服务器 IP 地址</li><li><p>服务器端口号</p><p><a href="/images/HowNetworksWorks/147.png"></a></p></li></ul></li><li><p>既然通过客户端 IP 地址、客户端端口号、服务器 IP 地址、服务器端口号这 4 种信息可以确定某个套接字,那么要指代某个套接字时用这 4 种信息就好了,为什么还要使用描述符呢</p><ul><li>原因是,在套接字刚刚创建好,还没有建立连接的状态下,这 4 种信息是不全的</li><li>此外,为了指代一个套接字,使用一种信息（描述符）比使用 4 种信息要简单</li><li><p>出于上面两个原因,应用程序和协议栈之间是使用描述符来指代套接字的</p><p><a href="/images/HowNetworksWorks/148.png"></a></p></li></ul></li></ul><h3 id="服务器的接收操作"><a href="#服务器的接收操作" class="headerlink" title="服务器的接收操作"></a>服务器的接收操作</h3><h4 id="网卡信号转换"><a href="#网卡信号转换" class="headerlink" title="网卡信号转换"></a>网卡信号转换</h4><p>  <a href="/images/HowNetworksWorks/149.png"></a></p><ul><li>客户端发送的网络包已经到达服务器</li><li><p>网卡接收到光信号或电信号,将其还原成数字信号</p><ul><li>局域网中传输的网络包信号是由 1 和 0 组成的数字信息与用来同步的时钟信号叠加而成的,因此只要从中分离出时钟信号,然后根据时钟信号进行同步,就可以读取并还原出 1 和 0 的数字信息了</li></ul><p><a href="/images/HowNetworksWorks/150.png"></a></p></li><li><p>接下来根据包末尾的帧校验序列 FCS 来校验错误</p><ul><li>根据 CRC-32 来计算接收到的数字信号和包末尾的 FCS 值比较</li><li>FCS 值是在发送时根据转换成电信号之前的数字信息进行计算得到的,因此如果根据信号还原出的数字信息与发送前的信息一致,则计算出的FCS 也应该与包末尾的 FCS 一致</li><li>如果两者不一致,则可能是因为噪声等影响导致信号失真,数据产生了错误,这时接收的包是无效的,因此需要丢弃</li></ul></li><li><p>当 FCS 一致,接下来就检查 MAC 头部中的 MAC 地址的接收方是不是自己</p></li><li>被还原后的数字信号被保存在网卡内部的缓冲区</li><li><p>以上的操作都是由网卡的 MAC 模块完成的<br><a href="/images/HowNetworksWorks/151.png"></a></p></li><li><p>在这个过程中,服务器的 CPU 并不是一直在监控网络包的到达,而是在执行其他的任务,因此 CPU 并不知道此时网络包已经到达了</p></li><li>但接下来的接收操作需要 CPU 来参与,因此网卡需要通过中断将网络包到达的事件通知给 CPU</li><li>接下来,CPU 就会暂停当前的工作,并切换到网卡的任务</li><li>然后,网卡驱动会开始运行,从网卡缓冲区中将接收到的包读取出来,根据 MAC 头部的以太类型字段判断协议的种类,并调用负责处理该协议的软件<ul><li>这里,以太类型的值应该是表示 IP 协议,因此会调用 TCP/IP 协议栈,并将包转交给它<br><a href="/images/HowNetworksWorks/152.png"></a></li></ul></li></ul><h4 id="IP-模块的接收操作"><a href="#IP-模块的接收操作" class="headerlink" title="IP 模块的接收操作"></a>IP 模块的接收操作</h4><ul><li>当网络包转交到协议栈时,IP 模块会首先开始工作,检查 IP 头部</li><li><p>IP 模块首先会检查 IP 头部的格式是否符合规范,然后检查接收方 IP 地址,看包是不是发给自己的</p><ul><li>当服务器启用类似路由器的包转发功能时,对于不是发给自己的包,会像路由器一样根据路由表对包进行转发 </li></ul></li><li><p>确认包是发给自己的之后,接下来需要检查包有没有被分片,检查 IP头部的内容就可以知道是否分片</p><ul><li>如果是分片的包,则将包暂时存放在内存中,等所有分片全部到达之后将分片组装起来还原成原始包</li><li>如果没有分片,则直接保留接收时的样子,不需要进行重组</li></ul></li><li><p>接下来需要检查 IP 头部的协议号字段,并将包转交给相应的模块</p><ul><li>如果协议号为 06（十六进制）,则将包转交给 TCP 模块</li><li>如果是 11（十六进制）,则转交给 UDP 模块</li></ul><p><a href="/images/HowNetworksWorks/153.png"></a></p></li></ul><h4 id="TCP-模块处理连接网络包"><a href="#TCP-模块处理连接网络包" class="headerlink" title="TCP 模块处理连接网络包"></a>TCP 模块处理连接网络包</h4><p><a href="/images/HowNetworksWorks/154.png"></a></p><ul><li>当 TCP 头部中的控制位 SYN 为 1 时,表示这是一个发起连接的包</li><li>这时,TCP 模块会执行接受连接的操作<ul><li>不过在此之前,需要先检查包的接收方端口号</li><li>并确认在该端口上有没有与接收方端口号相同且正在处于等待连接状态的套接字</li><li>如果指定端口号没有等待连接的套接字,则向客户端返回错误通知的包 </li></ul></li><li>如果存在等待连接的套接字,则为这个套接字复制一个新的副本并将发送方 IP 地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中,同时分配用于发送缓冲区和接收缓冲区的内存空间</li><li><p>然后生成代表接收确认的 ACK 号,用于从服务器向客户端发送数据的序号初始值,表示接收缓冲区剩余容量的窗口大小,并用这些信息生成 TCP 头部,委托IP 模块发送给客户端</p></li><li><p>这个包到达客户端之后,客户端会返回表示接收确认的 ACK 号,当这个 ACK 号返回服务器后,连接操作就完成了</p></li><li>这时,服务器端的程序应该进入调用 accept 的暂停状态,当将新套接字的描述符转交给服务器程序之后,服务器程序就会恢复运行</li></ul><p><a href="/images/HowNetworksWorks/155.png"></a></p><h4 id="TCP-模块处理数据网络包"><a href="#TCP-模块处理数据网络包" class="headerlink" title="TCP 模块处理数据网络包"></a>TCP 模块处理数据网络包</h4><ul><li>在 TCP 处理连接包之后,进入到数据收发阶段</li><li>首先,TCP 模块会检查收到的包对应哪一个套接字<ul><li>在服务器端,可能有多个已连接的套接字对应同一个端口号,因此仅根据接收方端口号无法找到特定的套接字</li><li>这时我们需要根据 IP 头部中的发送方 IP 地址和接收方 IP 地址,以及 TCP 头部中的接收方端口号和发送方端口号共 4 种信息,找到上述 4 种信息全部匹配的套接字</li></ul></li><li>找到对应的套接字后,TCP 模块会对比该套接字中保存的数据收发状态和收到的包的 TCP 头部中的信息是否匹配,以确定数据收发操作是否正常</li><li>最后,TCP模块会从包中提出数据,并存放到接收缓冲区中,与上次收到的数据块连接起来。这样一来,数据就被还原成分包之前的状态了<ul><li>当收到的数据进入接收缓冲区后,TCP 模块就会生成确认应答的 TCP 头部,并根据接收包的序号和数据长度计算出 ACK 号,然后委托 IP 模块发送给客户端</li></ul></li></ul><p><a href="/images/HowNetworksWorks/156.png"></a></p><h4 id="TCP-模块的断开操作"><a href="#TCP-模块的断开操作" class="headerlink" title="TCP 模块的断开操作"></a>TCP 模块的断开操作</h4><ul><li>在 TCP 协议的规则中,断开操作可以由客户端或服务器任何一方发起,具体的顺序是由应用层协议决定的<ul><li>Web 中,这一顺序随 HTTP 协议版本不同而不同,在 HTTP1.0 中,是服务器先发起断开操作</li></ul></li><li>这时,服务器程序会调用 Socket 库的 close,TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部,并委托 IP 模块发送给客户端</li><li>当客户端收到这个包之后,会返回一个 ACK 号</li><li>接下来客户端调用 close,生成一个FIN 为 1 的 TCP 头部发给服务器</li><li>服务器再返回 ACK 号,这时断开操作就完成</li></ul><h3 id="Web-服务器程序解释请求消息并作出响应"><a href="#Web-服务器程序解释请求消息并作出响应" class="headerlink" title="Web 服务器程序解释请求消息并作出响应"></a>Web 服务器程序解释请求消息并作出响应</h3><h4 id="URI-转换和运行程序"><a href="#URI-转换和运行程序" class="headerlink" title="URI 转换和运行程序"></a>URI 转换和运行程序</h4><p><a href="/images/HowNetworksWorks/157.png"></a></p><ul><li>服务器接收到数据后,根据 URI 去读取内容并向客户端返回数据</li><li>不过 Web 服务器的目录并不是磁盘的实际目录,而是用的虚拟目录<ul><li>如果是实际目录的话,就会有安全隐患</li></ul></li><li>而 URI 中写的就是在这个虚拟目录结构下的路径名</li><li>因此,当读取文件时,需要先查询虚拟目录与实际目录的对应关系,并将 URI 转换成实际的文件名后,才能读取文件并返回数据</li></ul><p><a href="/images/HowNetworksWorks/158.png"></a></p><ul><li>运行 CGI 程序</li></ul><p><a href="/images/HowNetworksWorks/159.png"></a></p><p><a href="/images/HowNetworksWorks/160.png"></a></p><h4 id="Web-服务器的访问控制"><a href="#Web-服务器的访问控制" class="headerlink" title="Web 服务器的访问控制"></a>Web 服务器的访问控制</h4><ul><li><p>Web 服务器的基本工作方式就是根据请求消息的内容判断数据源,并从中获取数据返回给客户端,不过在执行这些操作之前,Web 服务器还可以检查事先设置的一些规则,并根据规则允许或禁止访问</p></li><li><p>Web 服务器的访问控制规则主要有以下 3 种</p><ul><li>（1） 客户端 IP 地址</li><li>（2） 客户端域名</li><li>（3） 用户名和密码</li></ul></li><li>根据客户端 IP 地址设置的规则,这个情况很简单,在调用accept 接受连接时,就已经知道客户端的 IP 地址了,只要检查其是否允许访问就可以了</li><li>当根据客户端域名设置规则时,需要先根据客户端 IP 地址查询客户端域名,这需要使用 DNS 服务器<ul><li>一般我们使用 DNS 服务器都是根据域名查询 IP 地址,其实根据 IP 地址反查域名也可以使用 DNS 服务器</li><li>具体来说,这个过程是这样的</li><li>收到客户端的请求消息后,Web 服务器会委托协议栈告知包的发送方 IP 地址,然后用这个 IP 地址生成查询消息并发送给最近的 DNS 服务器</li><li>接下来,DNS 服务器找出负责管辖该 IP 地址的 DNS 服务器,并将查询转发给它查询到相应的域名之后返回结果</li><li>然后 Web 服务器端的 DNS 服务器再将结果转发给 Web 服务器</li><li>这样一来,我们就可以根据发送方IP 地址查询到域名</li><li>接下来,为了保险起见,还需要用这个域名查询一下IP 地址,看看结果与发送方 IP 地址是否一致<ul><li>这是因为有一种在 DNS 服务器上注册假域名的攻击方式,因此我们需要进行双重检查</li></ul></li></ul></li></ul><p><a href="/images/HowNetworksWorks/161.png"></a></p><ul><li>根据用户名和密码设置规则</li></ul><p><a href="/images/HowNetworksWorks/162.png"></a></p><h3 id="浏览器接收响应消息并显示内容"><a href="#浏览器接收响应消息并显示内容" class="headerlink" title="浏览器接收响应消息并显示内容"></a>浏览器接收响应消息并显示内容</h3><ul><li>Web 服务器发送的响应消息会被分成多个包发送给客户端,然后客户端需要接收数据</li><li><p>首先,网卡将信号还原成数字信息,协议栈将拆分的网络包组装起来并取出响应消息,然后将消息转交给浏览器</p><ul><li>这个过程和服务器的接收操作相同</li></ul></li><li><p>要显示内容,首先需要判断响应消息中的数据属于哪种类型</p></li></ul><p><a href="/images/HowNetworksWorks/163.png"></a></p><ul><li>当数据类型为文本时,还需要判断编码方式,这时需要用 charset 附加表示文本编码方式的信息</li><li>除了通过 Content-Type 判断数据类型,还需要检查 Content-Encoding 头部字段<ul><li>如果消息中存放的内容是通过压缩或编码技术对原始数据进行转换得到的,那么 Content-Encoding 的值就表示具体的转换方式,通过这个字段的值,我们可以知道如何将消息中经过转换的数据还原成原始数据</li></ul></li></ul><h2 id="网络包的路途"><a href="#网络包的路途" class="headerlink" title="网络包的路途"></a>网络包的路途</h2><p><img src="/images/HowNetworksWorks/last.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器生成消息—浏览器内部&quot;&gt;&lt;a href=&quot;#浏览器生成消息—浏览器内部&quot; class=&quot;headerlink&quot; title=&quot;浏览器生成消息—浏览器内部&quot;&gt;&lt;/a&gt;浏览器生成消息—浏览器内部&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/HowNetworksWorks/1.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Network" scheme="http://www.orekiyuta.cn/tags/Network/"/>
    
  </entry>
  
</feed>
