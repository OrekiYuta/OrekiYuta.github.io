<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learn to use Vue.js</title>
      <link href="/archives/LearnToUseVue/"/>
      <url>/archives/LearnToUseVue/</url>
      
        <content type="html"><![CDATA[<h3 id="How-to-use-Vue-js"><a href="#How-to-use-Vue-js" class="headerlink" title="How to use Vue.js"></a>How to use Vue.js</h3><p>初步使用 Vue</p><p><img src="/images/Vue/01.png" alt></p><ul><li>引入Vue.js , 实例化一个对象 myApp,里面的 el , data 为关键字</li><li>el 相当于元素选择器 element，这里 <code>#App</code> 选择了 <code>id=&quot;App&quot;</code> 的元素</li><li>data 里面定义任意名称字段，然后在 <em>双大括号</em>  中显示</li></ul><h3 id="v-if-、-v-for"><a href="#v-if-、-v-for" class="headerlink" title="v-if 、 v-for"></a>v-if 、 v-for</h3><ol><li><p>基础用法</p><p> <img src="/images/Vue/02.png" alt></p><ul><li><code>v-if=&quot;seen&quot;</code>中的 seen 关联了 data 中 seen , v-if 中的参数为 true 则显示,反之</li><li><code>v-for=&quot;fruit in fruits&quot;</code> 中的 fruits 关联了 data 中的 fruits , 遍历fruits 数组中的内容赋给 fruit , 最后在 <em>双大括号</em>  取 fruit 对象中的值</li></ul></li><li><p>v-if 、v-else-if 、v-else</p><p> <img src="/images/Vue/12.png" alt></p><ul><li><p>这个比较容易理解 , 直接在后面写入表达式 , 然后根据结果真假进行显示与否</p><p><img src="/images/Vue/12-1.png" alt></p></li></ul></li><li><p>数组列表渲染-添加索引</p><p> <img src="/images/Vue/14.png" alt></p><ul><li><p>这里对比前面的循环多了个索引 index , 主要表示了当前对象在数组列表中的位置</p><p><img src="/images/Vue/14-1.png" alt></p></li></ul></li><li><p>对象迭代</p><p> <img src="/images/Vue/15.png" alt></p><ul><li><p>取出 mygame 对象中的键值对</p><p>  <img src="/images/Vue/15-1.png" alt></p></li><li><p>值得注意的是 <code>(value, key) in mygame</code> 中键值对的顺序 , 前者必定是值 , 后者必定是键 , 这是设计初就定义好的。</p></li><li><p>命名 value 和 key 只是为了提高可读性而已 , 其实取什么名都不影响结果</p><p>  <img src="/images/Vue/15-2.png" alt></p><p>  <img src="/images/Vue/15-3.png" alt></p></li></ul></li></ol><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>设置元素状态为显示</p><p><img src="/images/Vue/13.png" alt></p><ul><li>这个也好理解 , 根据 result 对象的布尔值进行显示或隐藏</li><li>这个与 v-if 的区别在于 v-if 是对 DOM 进行操作的 , 而 v-show 只是设置了标签的 display 属性而已 , 并没有操作 DOM</li></ul><p><img src="/images/Vue/13-1.png" alt></p><p><img src="/images/Vue/13-2.png" alt></p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>为元素进行数据绑定</p><p><img src="/images/Vue/03.png" alt></p><ul><li>首先 data 中的 myName 的值是双向绑定到了 <code></code> 中 , 初始文本为 myName 的值</li><li>然后我想修改 <code></code> 的值怎么办,那就为一个元素设置 <code>v-model</code> 属性,属性值就设为想要绑定的那个字段名即可,这里就设置为 <code>v-model=&quot;myName&quot;</code></li><li>最终在input中输入的结果会呈现在 <em>双大括号</em>  中</li></ul><a id="more"></a><h3 id="v-bind-class"><a href="#v-bind-class" class="headerlink" title="v-bind:class"></a>v-bind:class</h3><ol><li><p>为元素的 class 属性绑定值</p><p> <img src="/images/Vue/10.png" alt></p><ul><li>首先常规的元素 class 一般为 <code>&lt;p class=&quot;xxx&quot; /&gt;</code> 的形式 , 这样的形式只能不断的在其后面添加 class 名才能对元素加以控制,显得不够灵活</li><li>Vue 能够用过 Js 对其 class 属性进行控制 , 提高了 class 属性的复用性</li><li>这里 <code>v-bind:class=&quot;{active:isActive}&quot;</code> 意思是首先有一个 <code>class=&quot;active&quot;</code> 的元素 , 我们突然不想让它的 class 值为 active 了 , 怎么办 ? 但是又不可能随时手工去移除 , 所以就在双引号内写入表达式 <code>{active:isActive}</code> </li><li><code>active:isActive</code> 中的 isActive 可任意取名 , 然后在 data 中给 isActive 字段赋予一个布尔值 , 然后 v-bind:class 就能根据双引号内的表达式进行布尔判断 , 实现显示与移除</li><li><p><code>v-bind:class</code> 可简写为 <code>:class</code></p><p><img src="/images/Vue/10-1.png" alt></p><p><img src="/images/Vue/10-2.png" alt></p></li></ul></li><li><p>为元素的 class 属性绑定对象</p><p> <img src="/images/Vue/11.png" alt></p><ul><li>上面的例子是在 class 属性的双引号内写入表达式 , 然后绑定了样式的属性名</li><li>这里的话 , 直接在双引号内输入任意字段名 , 然后在 data 中写入该字段名对象 , 接着在该对象内写入布尔参数</li><li><p>最终效果为 class 绑定了 myClass 对象 ，class 属性根据对象内容的参数布尔值 , 实现了同时对一个元素添加多个属性值效果</p><p><img src="/images/Vue/11-1.png" alt></p><p><img src="/images/Vue/11-2.png" alt></p></li></ul></li></ol><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ol><li><p>为元素进行事件绑定</p><p> <img src="/images/Vue/04.png" alt></p><ul><li><code>v-on:click</code> 绑定了一个点击事件,点击事件 <code>btnClick(&#39;Orekiyuta&#39;)</code> 的方法名为 btnClick ,关联了 myApp 实例中的 methods 关键字中的 btnClick 字段 , 然后把方法里的值赋给了 data 中的 myName </li><li><code>v-on:</code> 可简写为 <code>@</code></li><li>同理,其他事件也是这样 ( keydown , keyup , dbclick , load , etd . )</li></ul></li><li><p>v-on:(event)</p><p> <img src="/images/Vue/16.png" alt></p><ul><li><code>v-on:keyup=&quot;txtKeyup($event)&quot;</code> 在这里 <code>$event</code> 为关键字获取事件内容 , 不能修改成其他 </li><li><code>v-on:keyup=&quot;txtKeyup($event)&quot;</code> 和 <code>v-on:keyup=&quot;txtKeyup&quot;</code> 为一样的效果 , 默认为获取事件</li><li><p>v-on:(event) 可简写为 @(event) , 例如 <code>@keyup=&quot;txtkeyup&quot;</code></p><p>  松开按键</p><p>  <img src="/images/Vue/16-1.png" alt></p><p>  点击按钮</p><p>  <img src="/images/Vue/16-2.png" alt></p></li><li><p>修改方法形参不影响结果 , 形参定义成 event 也是便于理解而已 ; <code>v-on:(evenr)</code> 获取了键盘的事件传给方法的形参 , 形参接受了数据在函数里做相应的处理</p><p>  <img src="/images/Vue/16-3.png" alt>   </p></li></ul></li></ol><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>组件,把当个页面拆分开成各个部件的一种思想,把页面各个部分认为是一个组件,然后操作各个组件元素,最后重新组合为页面;也是一种解耦思想吧</p><p><img src="/images/Vue/05.png" alt></p><ul><li>在这里首先是自定义了一个名为 orekiyuta 的 component , 然后设置了它的 pros 和 template </li><li>这个组件在代码中表现为 <code>&lt;orekiyuta/&gt;</code> 的形式 , 它的 pros 可理解为接受传入的数据 , template 则是定义了 <code>&lt;orekiyuta/&gt;</code> 最终会渲染成何种元素,这里为 <code>&lt;li/&gt;</code></li><li>最终结果是从数组 fruits 中遍历数据赋给 fruit , 然后 <code>v-bind</code> 把 fruit 和 组件的名为 eatfruits 的 props 绑定在一起 , 这样就可以在 template 中通过 <code>eatfruits.name</code> 取得数据</li></ul><h3 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h3><p>过滤器,把元数据格式化输出,就是把所得到的数据改变下输出格式,常见的日期格式就个例子,<br>把数据和其表现形式分离操作,也是MVC常用的一种思想</p><p><img src="/images/Vue/06.png" alt></p><ul><li>用法为在需要格式化的数据后加上管道符和过滤器名 <code>XXX | filterName</code></li><li>filters 和 methods 内容为同样的写法 , 也就关键字不一样而已</li></ul><h3 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h3><p>计算属性,用于把从服务端传过来的元数据加以计算处理的,这样有便于各种不同算法处理的同一数据的展示</p><p><img src="/images/Vue/07.png" alt></p><ul><li>和前面 methods 、filters 写法一样 , 差别在于用法</li><li>用法直接在 <em>双大括号</em>  中写入计算属性的方法名</li></ul><h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p>监听属性,用于监听变量的变化,然后执行相应处理</p><p><img src="/images/Vue/08.png" alt></p><ul><li>用法为在 Watch 关键字内 写入需要监听的变量,这里监听了 data 中的 变量 price </li><li>一旦 price 的值发生改变,就触发后面的 <code>function (newVal, oldVal)</code> , 方法中的默认形参为新值和旧值</li><li>和前面的计算属性不一样的是 , 在这里 <code></code> <code></code> 是定义为变量输出的</li></ul><p><img src="/images/Vue/08-1.png" alt></p><p><img src="/images/Vue/08-2.png" alt></p><ul><li>这样一来 priceInTax 和 priceChinaRMB 初始值为 0 , 而我们想在页面第一次加载的时候就让三种价格输出</li></ul><p><img src="/images/Vue/08-3.png" alt></p><ul><li>这样就可以在这个Vue对象实例的时候先不给 price 赋值,而在它实例化完成之后再对 price 赋值 , 这样监听属性就能执行一次处理</li></ul><p><img src="/images/Vue/08-4.png" alt></p><h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h3><p>设置计算属性,之前的计算属性只是单纯的取出数据 get , 这里多了个存数据方法 set</p><p><img src="/images/Vue/09.png" alt></p><ul><li>首先页面初始化时会先读取 price 、priceInTax 、priceChinaRMB 各自的值 ; priceInTax 触发的是 get 方法 , 根据 price 值计算出了 priceInTax 的值</li><li>然后点击事件给计算属性中的 priceInTax 赋予了一个新的值 , 触发 priceInTax 的 set 方法 ,根据 priceInTax 的值 计算出 Price 的 值</li></ul><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ol><li><p><code>input[type=&quot;text&quot;]</code> : 用  <code>v-model</code> 为表单文本框绑定变量 , 实现数据同步</p><p> <img src="/images/Vue/17.png" alt></p><p> <img src="/images/Vue/17-1.png" alt></p></li><li><p><code>input[type=&quot;checkout&quot;]</code> : 用  <code>v-model</code> 绑定复选框 , 并把选中的复选框的值添加到数组对象中 , 数组内顺序由选中顺序决定 </p><p> <img src="/images/Vue/18.png" alt></p><p> <img src="/images/Vue/18-1.png" alt></p><ul><li><p>取消选中某一元素后 , 数组后一位元素向前移动一位</p><p><img src="/images/Vue/18-2.png" alt></p></li><li><p>需要注意的是 checkedGames 对象为数组对象 [] , 如果修改成变量 “” 就会同时选定 , 且结果是布尔值</p><p><img src="/images/Vue/18-3.png" alt></p><p><img src="/images/Vue/18-4.png" alt></p></li></ul></li><li><p><code>input[type=&quot;radio&quot;]</code> : 用  <code>v-model</code> 绑定单选框 , v-model 的值相同的为一组 , 值对象就用空就行</p><p> <img src="/images/Vue/19.png" alt></p></li><li><p><code>select</code> : 用  <code>v-model</code> 绑定下拉框列表 </p><p> <img src="/images/Vue/20.png" alt></p><ul><li>在 <code>likedNBAStar: &quot;&quot;</code> 这里用 <code>&quot;&quot;</code> 和 <code>null</code> 效果一样</li><li><p>在 <code>likedNBAStars: []</code> 这里用 <code>null</code> <code>&quot;&quot;</code> <code>{}</code> <code>[]</code> 结果一样都是数组 </p><p><img src="/images/Vue/20-1.png" alt></p></li></ul></li><li><p>表单修饰符</p><ol><li><p><code>.lazy</code></p><ul><li><code>用户名：&lt;input v-model.lazy=&quot;username&quot;&gt;</code></li><li>用户输入内容时不做绑定数据的更新处理,在控件的 onchange 事件中更新绑定的变量 </li><li>也就是说用户输入完成后 , 光标离开的瞬间触发 onchange 事件 , 一次性更新内容</li><li>一般的数据双向绑定都是用户输入的同时更新 , 这样做的话有助于提高性能</li></ul></li><li><p><code>.number</code></p><ul><li><code>年龄：&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></li><li>将用户输入的内容转换为数值类型，如果用户输入非数值的时候，则返回NaN</li><li>在页面表现为无法输入非数字类型内容</li></ul></li><li><p><code>.trim</code></p><ul><li><code>意见：&lt;input v-model.trim=&quot;content&quot;&gt;</code></li><li>自动去掉用户输入内容两端的空格</li></ul></li></ol></li></ol><p><img src="/images/Vue/21.png" alt></p><p>总结下来 , 基本就是通过 <code>v-model</code> 绑定 data 中的一个对象 , 至于对象是什么类型 , 取决于需求</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ol><li><p>创建全局组件</p><p> <img src="/images/Vue/22.png" alt></p><p> <img src="/images/Vue/22-1.png" alt></p><ul><li>值得注意的是以 <code>Vue.component()</code> 形式创建的是全局组件 , 意思是只要是用到 Vue 对象的地方都可以用到该组件</li></ul></li><li><p>创建局部组件</p><p> <img src="/images/Vue/23.png" alt></p><ul><li>首先声明了一个 Js 对象 WeatherComponent , 然后在该对象内部声明了 template 属性 , 这个 template 为关键字</li><li>然后声明了一个名为 myApp 的 Vue 实例 , 在该实例内部的 components 属性内部写了一个组件名 <code>my-weather</code> , 跟在后面的 <code>WeatherComponent</code> 意思是用到名为 WeatherComponent 的 Js 对象</li><li>这样的过程就是局部注册组件</li><li><p>这样的写法就是 my-weather 这个组件只能在 myApp 这个实例的作用域里面才能生效 , 意思就是 <code>&lt;my-weather/&gt;</code> 只有写在 <code>&lt;div id=&quot;myApp&quot;/&gt;</code> 内部才生效</p><p>  <img src="/images/Vue/23-1.png" alt></p></li></ul></li><li><p>表行组件</p><p> 首先观察以下内容</p><p> <img src="/images/Vue/24.png" alt></p><p> <img src="/images/Vue/24-1.png" alt></p><ul><li>由于 <code>&lt;table/&gt;</code> 内部无法识别 <code>&lt;my-row*&gt;</code> , 因此我们定义的组件只能渲染在 table 标签外部</li><li><p>我们定义的组件渲染的顺序排在了 table 之前 , ( 个人应该是页面DOM组织时 Js 的优先级高于原生 HTML ) //这里有待研究</p><p>如果需要让组件内容正常的显示在 table 中 , 需要用这种写法 <code>&lt;tr is=&quot;my-row1&quot;&gt;&lt;/tr&gt;</code></p><p><img src="/images/Vue/24-2.png" alt></p></li></ul></li><li><p>数据函数</p><p> <img src="/images/Vue/25.png" alt></p><ul><li>这里需要注意的是 template 属性内的 todayWeather 对象 , 需要在 data 中写成函数形式</li></ul></li><li><p>给组件传递参数</p><p> <img src="/images/Vue/26.png" alt></p><ul><li>这里数据传递的关键在于 test-result 组件标签的 <code>:score</code> 属性通过 v-bind 和组件内部 props 属性值 score 进行了绑定</li><li>这样就组件就可以接受从外部传递过来的参数值</li></ul></li><li><p>给组件传递变量</p><p> <img src="/images/Vue/27.png" alt></p><ul><li>首先是用 v-model 给 input 的值绑定了 myApp 的 data 属性中的 myname 对象 </li><li>然后在自定义的组件中用 <code>:pname</code> 把 myname 对象和组件中的 props 属性中的 pname 值进行绑定</li><li>通过 myname 对象把值传递到 template 属性值的 <em>双大括号中</em></li></ul></li><li><p>参数验证</p><p> <img src="/images/Vue/28.png" alt></p><ul><li>在 component 中的 props 属性不再是之前的数组 , 而是设置成对象 </li><li>分别设置了 name , age , detail 对象 , 在各自的对象中进行了相应的参数校验 </li><li>detail 与 name , age 的不同在于 name , age 为单一的属性对象 , 而 datail 设置了 object 对象 , 便可以在其中描述多个内容 ; 在这里的话设置了默认返回值</li></ul></li><li><p>事件传递</p><ol><li><p>v-on : 侦听组件事件，当组件触发事件后进行事件处理。</p></li><li><p>$emit : 触发事件，并将数据提交给事件侦听者。</p><p><img src="/images/Vue/29.png" alt></p></li></ol><ul><li>首先给组件传递了 a 、 b 值 , 然后点击事件触发 add 方法</li><li>然后在方法内部用 <code>$emit</code> 触发事件 , 给 add_event 事件传递 inResult 参数</li><li>因此组件 <code>&lt;add-method /&gt;</code> 绑定的 add_event 事件被触发 , 然后调用 getAddResult 方法</li><li>将刚才传递过来的 inResult 参数赋给 outResult 参数 , 最终显示在页面 </li></ul></li><li><p>slot </p><p> 主要作用是将自定义组件标签之间的内容保留到指定位置</p><ul><li><p>一般来说没有使用 slot 的情况下 , 组件编译时会忽略组件标签之间的内容</p><p><img src="/images/Vue/30-2.png" alt></p><p><img src="/images/Vue/30.png" alt></p></li><li><p>用法为在 template 中指定位置插入 <code>&lt;slot&gt;&lt;/slot&gt;</code></p></li><li><p>在文章以上的所有内容都是在标签的属性中操作数据显示 , 而这里主要对标签间的内容进行操作</p><p><img src="/images/Vue/30-1.png" alt></p></li><li><p>观察所得 , slot 不仅保留了字符 , 还保留了空格</p></li><li>所以 slot 使用后会对组件标签之间的所有内容进行保留 , 空格当作空字符一起合并</li></ul></li><li><p>组合 slot</p><p> 在上面使用了 slot 之后 , 或许会有点疑问 , 上面是一次性操作了标签内所有的内容 , 要是我想只对局部内容操作该怎么办呢？那就需要为 slot 命名区分开 , 再对其进行处理</p><p> <img src="/images/Vue/31.png" alt></p><ul><li>通过在组件内添加块元素 <code>&lt;span/&gt;</code> 为 slot 命名 , 然后在 template 中 再次通过名称对其进行保留处理</li><li><p>仔细观察 , 这时如果不给 slot 命名的话 , 使用 <code>&lt;slot&gt;&lt;/slot&gt;</code> 也一样会进行保留操作 , 由于这里组件 <code>&lt;nba-all-stars/&gt;</code> 之间无内容 , 所以不显示</p><p><img src="/images/Vue/31-1.png" alt></p></li><li><p>再次观察可知, 标签之间的空格不会被编译器认为是空字符</p><p><img src="/images/Vue/31-1.png" alt></p></li><li><p>但是一旦标签内有字符 , 空格就被认为和空字符 </p></li><li>同时 <code>&lt;span/&gt;</code> 标签占据的位置也会被认为是空字符</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ark.exploit.log</title>
      <link href="/archives/Ark-exploit-log/"/>
      <url>/archives/Ark-exploit-log/</url>
      
        <content type="html"><![CDATA[<h3 id="Date-2019-11-23-18-18-27"><a href="#Date-2019-11-23-18-18-27" class="headerlink" title="Date: 2019-11-23 18:18:27"></a>Date: 2019-11-23 18:18:27</h3><ul><li>Ctrl + Alt + N 内联变量(相当于提取变量的逆向操作)</li></ul><h3 id="Date-2019-11-20-22-01-04"><a href="#Date-2019-11-20-22-01-04" class="headerlink" title="Date: 2019-11-20 22:01:04"></a>Date: 2019-11-20 22:01:04</h3><ul><li><p>Pro Environment Deployment Review</p><ul><li>服务器端用git pull 拉取开发环境提交的最新代码</li><li>修改配置文件信息;👉<a href="https://maven.apache.org/guides/introduction/introduction-to-profiles.html" target="_blank" rel="noopener">Maven官方文档</a><ul><li>环境分离,Maven提供在本地使用Pom配置</li><li>服务端用.m2/setting.xml 配置文件  </li></ul></li><li>配置jdk,maven环境<ul><li>用flyway工具按脚本生成数据库表 <code>mvn clean compile flyway:migrate -Ppro</code> pro是在配置中 profiles节点自定义的名称  </li><li>配置了环境分离的话,可以在开发环境和服务端分别按配置构建数据库连接进行便利开发,因为开发环境的配置不能随意填写</li><li>开发环境最好和服务部署环境保持一致性</li></ul></li><li>用 <code>mvn clean compile</code> <code>mvn package</code> 构建jar包</li><li>运行jar包即可 <code>java -jar target/xxxx-0.0.1 -SNAPSHOT.jar</code></li><li>访问服务端即可</li></ul><hr><ul><li>在服务器部署方面采用docker会更方便后续工作</li><li>docker主要步骤为:   拉取镜像/构建镜像→构建容器→运行容器</li><li>首先得安装docker,运行 <code>service docker start</code></li><li>在这里以MySQL为例:</li><li><code>docker image pull mysql</code> 首先会从本地查看有没有mysql镜像,没有再去docker仓库拉取</li><li><code>docker image ls</code></li><li><code>docker container run mysql</code> 生成的容器会持久化存在，不需要可删除</li><li><code>docker ps</code> <code>docker container ls -all</code></li><li><code>docker run -it --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -v xx/xx : xx/xx mysql</code> 端口映射,文件夹映射</li><li>需要深入了解网络IP</li><li><code>docker exec -it mysql /bin/bash</code> 进入容器启动容器命令行</li><li><code>docker exec -it mysql -h localhost -u root -p</code></li></ul><hr><ul><li>对于项目而言可以采用 dockerFile 方式把环境和项目和操作步骤写入dockerFile文件里</li><li>然后构建项目镜像,就可以方便的在不同环境利用docker部署</li><li>也可以把项目容器和数据库容器等多个容器用docker compose 方式构建</li><li>多下点功夫去看官方英文文档<a id="more"></a><h3 id="Date-2019-11-15-17-06-49"><a href="#Date-2019-11-15-17-06-49" class="headerlink" title="Date: 2019-11-15 17:06:49"></a>Date: 2019-11-15 17:06:49</h3></li></ul></li><li><p>Ctrl + shift + U 选中内容小写</p></li></ul><h3 id="Date-2019-11-08-17-06-50"><a href="#Date-2019-11-08-17-06-50" class="headerlink" title="Date: 2019-11-08 17:06:50"></a>Date: 2019-11-08 17:06:50</h3><ul><li>Ctrl + Alt + M 把选中代码提取成方法</li><li>Ctrl + Alt + P 把选择代码提取成形式参数</li></ul><h3 id="Date-2019-11-02-16-51-41"><a href="#Date-2019-11-02-16-51-41" class="headerlink" title="Date: 2019-11-02 16:51:41"></a>Date: 2019-11-02 16:51:41</h3><ul><li><p>页面debug方法:</p><ol start="0"><li><p>在调试处加入debugger</p><p> <img src="/images/Ark/12.png" alt>    </p></li><li><p>运行页面进行相应调试</p><p> <img src="/images/Ark/13.png" alt>    </p></li></ol></li></ul><h3 id="Date-2019-11-01-16-55-42"><a href="#Date-2019-11-01-16-55-42" class="headerlink" title="Date: 2019-11-01 16:55:42"></a>Date: 2019-11-01 16:55:42</h3><ul><li>Ctrl+F6 调整方法参数位置</li></ul><h3 id="Date-2019-10-28-21-05-57"><a href="#Date-2019-10-28-21-05-57" class="headerlink" title="Date: 2019-10-28 21:05:57"></a>Date: 2019-10-28 21:05:57</h3><ul><li><p>数据库字段默认值设置了default 0 ,但是就是不生效。</p><ol start="0"><li><p>问题逐一排查，先debug了看了下提交的字段为null,按道理更新数据之后该条记录中的null应该为默认值0;但是仍是null。</p></li><li><p>思考……是不是之前应用了的MybatisGenerator的用法不对呢。</p></li><li><p>通过分析源码，发现insert()和insertSelective的区别了,加入是insert就把所有值插入,但是要注意加入数据库字段有default,default是不会起作用的,而后者就不会忽略default</p></li><li><p>同理updateByPrimaryKeys,updateByPrimaryKeySelective</p><p> <img src="/images/Ark/11.png" alt>    </p></li></ol></li></ul><h3 id="Date-2019-10-26-00-15-59"><a href="#Date-2019-10-26-00-15-59" class="headerlink" title="Date: 2019-10-26 00:15:59"></a>Date: 2019-10-26 00:15:59</h3><ul><li>Alt+F7 查看依赖处</li></ul><h3 id="Date-2019-10-25-01-17-27"><a href="#Date-2019-10-25-01-17-27" class="headerlink" title="Date: 2019-10-25 01:17:27"></a>Date: 2019-10-25 01:17:27</h3><ul><li><p>在数据库后期维护时，如果增加字段，要修改Mapper,Model等已有代码，这时就很麻烦; </p><p>MyBatis Generator 可以帮助完成这些操作，配置Maven依赖，配置xml,运行命令 <code>mvn -Dmybatis.generator.overwrite=true mybatis-generator:generate</code></p></li></ul><h3 id="Date-2019-10-21-01-12-13"><a href="#Date-2019-10-21-01-12-13" class="headerlink" title="Date: 2019-10-21 01:12:13"></a>Date: 2019-10-21 01:12:13</h3><ul><li><p>Ctrl+F12 快速展示源码的方法列表</p><p>  <img src="/images/Ark/10.png" alt>    </p></li><li><p>Win+Alt+← 后退   +→ 前进</p></li></ul><h3 id="Date-2019-10-19-17-59-27"><a href="#Date-2019-10-19-17-59-27" class="headerlink" title="Date: 2019-10-19 17:59:27"></a>Date: 2019-10-19 17:59:27</h3><ul><li>Ctrl+Win+W  会自动选中已选中的页面标签最外层</li></ul><h3 id="Date-2019-10-16-12-20-25"><a href="#Date-2019-10-16-12-20-25" class="headerlink" title="Date: 2019-10-16 12:20:25"></a>Date: 2019-10-16 12:20:25</h3><ul><li><p>Lombok 通过注解自动化生成getter和setter，同时也有它的缺点，Google一下，你就知道！</p><p>  <img src="/images/Ark/09.png" alt>    </p></li></ul><h3 id="Date-2019-10-15-19-16-56"><a href="#Date-2019-10-15-19-16-56" class="headerlink" title="Date: 2019-10-15 19:16:56"></a>Date: 2019-10-15 19:16:56</h3><ul><li><p>IEDA快捷生成DIV,输入标签.类名 按Tag键;同理纯标签的话，输入标签名按Tag生成</p><p>  <img src="/images/Ark/05.png" alt></p><p>  <img src="/images/Ark/06.png" alt></p></li><li><p>Ctrl+D 复制光标当前所在行内容到下一行</p></li><li><p>Flyway集成错误： org.flywaydb.core.api.FlywayException: Version may only contain 0..9 and . (dot). Invalid version: 3.Creare.question.table -&gt; [Help 1]</p><p>  <img src="/images/Ark/07.png" alt></p><p>  解决方案：根据错误提示,发现是命名格式错误,修改即可</p><p>  <img src="/images/Ark/08.png" alt></p></li></ul><h3 id="Date-2019-10-13-16-57-00"><a href="#Date-2019-10-13-16-57-00" class="headerlink" title="Date: 2019-10-13 16:57:00"></a>Date: 2019-10-13 16:57:00</h3><ul><li><p>flyway  类似版本管理工具一样，管理数据库</p><p>  <img src="/images/Ark/04.png" alt></p></li><li><p>rm ~/ArCanoe.* 删除已有库</p></li><li><p>H2数据库仅支持单链接，执行相关内容，需要关闭之前的链接</p></li></ul><h3 id="Date-2019-10-11-16-04-50"><a href="#Date-2019-10-11-16-04-50" class="headerlink" title="Date: 2019-10-11 16:04:50"></a>Date: 2019-10-11 16:04:50</h3><ul><li>Crtl+E 切换最近编辑的窗口</li></ul><h3 id="Date-2019-10-10-20-38-00"><a href="#Date-2019-10-10-20-38-00" class="headerlink" title="Date: 2019-10-10 20:38:00"></a>Date: 2019-10-10 20:38:00</h3><ul><li><p>Alt+Enter 提示添加jar包或其它</p></li><li><p>Ctrl+Alt+V 快速创建变量</p><p>  <img src="/images/Ark/02.png" alt></p><p>  <img src="/images/Ark/03.png" alt></p></li><li><p>Shift+Enter 自动换行并将光标移动到下一行前面</p></li></ul><h3 id="Date-2019-10-10-11-13-13"><a href="#Date-2019-10-10-11-13-13" class="headerlink" title="Date: 2019-10-10 11:13:13"></a>Date: 2019-10-10 11:13:13</h3><ul><li><p>IDEA(Shift+F6) 重命名文件</p></li><li><p>Crtl+Shift+F12  代码栏最大化</p></li></ul><h3 id="Date-2019-10-09-20-16-26"><a href="#Date-2019-10-09-20-16-26" class="headerlink" title="Date: 2019-10-09 20:16:26"></a>Date: 2019-10-09 20:16:26</h3><ul><li><p>不知道传什么变量的时候，IDEA(Crtl+P)提示</p><p>  <img src="/images/Ark/01.png" alt></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Install+Migrate</title>
      <link href="/archives/Hexo-Install-Migrate/"/>
      <url>/archives/Hexo-Install-Migrate/</url>
      
        <content type="html"><![CDATA[<h3 id="安装Git-Node"><a href="#安装Git-Node" class="headerlink" title="安装Git,Node"></a>安装Git,Node</h3><p><img src="/images/Hexo-IM/01.png" alt></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>先创建一个文件夹，然后cd到这个目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli  //安装</span><br><span class="line">hexo -v   //查看版本</span><br></pre></td></tr></table></figure><p><img src="/images/Hexo-IM/02.png" alt></p><a id="more"></a><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo init myblog  //任意文件夹名 myblog</span><br></pre></td></tr></table></figure><p><img src="/images/Hexo-IM/03.png" alt></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>进入myblog文件夹 启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd myblog</span><br><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="/images/Hexo-IM/04.png" alt></p><h3 id="检查页面；迁移设备"><a href="#检查页面；迁移设备" class="headerlink" title="检查页面；迁移设备"></a>检查页面；迁移设备</h3><p>在浏览器输入<code>localhost:4000</code>,即可看到页面</p><ul><li>迁移更新设备的话，做到这一步，把原来的博客文件复制到此替换即可</li></ul><h3 id="连接Github"><a href="#连接Github" class="headerlink" title="连接Github"></a>连接Github</h3><ul><li><p>创建Github仓库，命名 <code>xxx.github.io</code></p><p>  <img src="/images/Hexo-IM/05.png" alt></p></li><li><p>生成SHH</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>  <img src="/images/Hexo-IM/06.png" alt></p><p>  <img src="/images/Hexo-IM/07.png" alt></p></li><li><p>添加SSH到github</p><p>  将刚才生成的id_rsa.pub的内容复制到key</p><p>  <img src="/images/Hexo-IM/08.png" alt></p><p>  检查是否建立连接成功</p><p>  <img src="/images/Hexo-IM/09.png" alt></p></li></ul><h3 id="Hexo部署到GitHub"><a href="#Hexo部署到GitHub" class="headerlink" title="Hexo部署到GitHub"></a>Hexo部署到GitHub</h3><ul><li><p>修改配置文件 <code>_config.yml</code></p><p>  <img src="/images/Hexo-IM/10.png" alt></p></li><li><p>安装deploy-git 部署命令</p><p>  <code>npm install hexo-deployer-git --save</code></p><p>  常用命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean      //清除之前生成的东西</span><br><span class="line">hexo g          //更新      </span><br><span class="line">hexo d          //部署</span><br><span class="line">hexo s --debug  //本地调试</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git flow</title>
      <link href="/archives/Git-flow/"/>
      <url>/archives/Git-flow/</url>
      
        <content type="html"><![CDATA[<h3 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h3><p>Git flow : </p><p>for ( =&gt; local-code =&gt; submit to local-repository =&gt; submit to server-repository =&gt; from remote-repository update code =&gt; )</p><p>Detail : </p><p>localfolder -&gt; git Stage -&gt; git local -&gt; git remote</p><p>本地工作文件夹 -&gt; 索引区 -&gt; 本地库 -&gt; 远程库（服务器端）</p><hr><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p><code>git init</code>        //初始化</p><p><code>git config -l</code>  //查看配置信息</p><p><code>git config --global user.name &quot;XXX&quot;</code></p><p><code>git config --global user.email &quot;xxx@zz.com&quot;</code></p><p>//查看帮助信息</p><p><code>git config --help</code></p><p><code>git help config</code></p><p><code>git help commit</code></p><p><code>git help ...</code> </p><hr><a id="more"></a><h3 id="提交本地仓库"><a href="#提交本地仓库" class="headerlink" title="提交本地仓库"></a>提交本地仓库</h3><ol><li><code>mkdir mygit</code> //建立本地工作文件夹</li><li><code>cd mygit</code>    //进入文件夹</li><li><code>git init</code>    //初始化git库</li><li><p><code>nano 文件名</code> //编辑本地文件,比如 <code>nano test.htm</code> </p><p> <img src="/images/Git/01.png" alt></p><p> <img src="/images/Git/02.png" alt></p></li><li><p><code>git status</code> //查看本地文件夹状态</p><p> <img src="/images/Git/03.png" alt></p><p> //当前状态为 <em>红色</em> 提示文件未添加到索引区</p></li><li><p><code>git add 文件名</code>//添加文件到索引区，比如 <code>git add test.htm</code></p><p> <img src="/images/Git/04.png" alt></p><p> //提交成功再次查看状态为绿色,成功添加到索引区</p></li><li><p><code>git commit -m &quot;备注信息&quot;</code> //将索引区内容提交至本地仓库</p><p> <img src="/images/Git/05.png" alt></p></li><li><p><code>git log</code> //查看提交日志</p><p> <img src="/images/Git/06.png" alt> </p></li></ol><hr><h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><ol><li><p>首先修改下原有文件内容 <code>nano test.htm</code> </p><p> <img src="/images/Git/07.png" alt></p></li><li><p>查看状态</p><p> <img src="/images/Git/08.png" alt></p></li><li><p>添加到索引区</p><p> <img src="/images/Git/09.png" alt></p></li><li><p>提交到本地库</p><p> <img src="/images/Git/10.png" alt></p></li><li><p>查看日志</p><p> <img src="/images/Git/11.png" alt></p></li><li><p>在以后日志必定会越来越多，就可以用以下方法查看</p></li></ol><ul><li><p><code>git log -1</code> //后面的数字代表最近的几条记录</p><p>  <img src="/images/Git/12.png" alt></p></li><li><p><code>git log --oneline</code> //将日志信息缩短为一行显示 ; ID号也缩短为前7位了</p><p>  <img src="/images/Git/13.png" alt></p></li><li><p><code>git log -p</code> //查看更改的详细信息</p><p>  <img src="/images/Git/14.png" alt></p><p>  //和数字组合用法,查看最近一次更改的详细信息</p><p>  <img src="/images/Git/15.png" alt></p><p>  //加上oneline,对比上图可见头部信息缩短了</p><p>  <img src="/images/Git/16.png" alt></p></li><li><p><code>git log --stat</code> //对每次的提交的内容进行统计的信息</p><p>  <img src="/images/Git/17.png" alt></p></li><li><p><code>git log --help</code> //查看其他命令用法</p></li></ul><hr><h3 id="工作状态回退"><a href="#工作状态回退" class="headerlink" title="工作状态回退"></a>工作状态回退</h3><ul><li><p>未添加到索引区</p><ol><li><p>修改文件内容</p><p> <img src="/images/Git/19.png" alt></p></li><li><p>查看状态</p><p> <img src="/images/Git/20.png" alt></p></li><li><p><code>git checkout -- 文件名</code> //突然不想要已修改的部分内容了，状态回退一下</p><p> <img src="/images/Git/21.png" alt></p></li><li><p>查看源文件,刚才修改内容已经被回退</p><p> <img src="/images/Git/22.png" alt></p></li></ol></li><li><p>已添加到索引区</p><ol><li><p>修改内容然后添加到索引区</p><p> <img src="/images/Git/23.png" alt></p><p> <img src="/images/Git/24.png" alt></p></li><li><p><code>git reset HEAD 文件名</code> 将添加内容从索引区回退   </p><p> <img src="/images/Git/25.png" alt></p></li><li><p>接着继续做&lt;未添加到索引区&gt;的步骤即可回退到文件未修改状态  </p></li></ol><ul><li><p><code>git add .</code>  //Git 不同版本的用法区别</p><p>  <img src="/images/Git/18.png" alt>  </p></li></ul></li></ul><hr><h3 id="比较修改内容"><a href="#比较修改内容" class="headerlink" title="比较修改内容"></a>比较修改内容</h3><ol><li><p><code>git diff</code> //比较工作文件夹</p><p> <img src="/images/Git/26.png" alt></p></li><li><p><code>git diff --cached</code> //比较索引区</p><p> <img src="/images/Git/27.png" alt></p></li></ol><hr><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li><p>执行多个操作（修改内容，添加文件）</p><p> <img src="/images/Git/28.png" alt><br> <img src="/images/Git/29.png" alt>    </p></li><li><p>查看状态并添加到索引区</p><p> <img src="/images/Git/30.png" alt></p></li><li><p><code>git mv 旧文件名 新文件名</code>  //修改文件名</p><p> <img src="/images/Git/31.png" alt></p><p> //修改前缀认为添加新文件，修改后缀认为重命名</p><p> <img src="/images/Git/32.png" alt></p><p> //同时修改认为添加新文件</p><p> <img src="/images/Git/33.png" alt></p></li><li><p><code>git rm --cached 文件名</code> //从索引区删除</p><p> <img src="/images/Git/34.png" alt></p></li><li><p>查看下日志</p><p> <img src="/images/Git/35.png" alt></p></li></ol><hr><h3 id="忽略管理"><a href="#忽略管理" class="headerlink" title="忽略管理"></a>忽略管理</h3><p>设置Git忽略的文件，这些文件不参与Git库的提交和管理。（动态文件，比如Node.js的 node_modules 文件夹）</p><ol><li><p>新建两个文件;ingnore.tmp为需要被忽略的文件, .gitignore为配置文件</p><p> <img src="/images/Git/36.png" alt></p></li><li><p>查看状态</p><p> // 目前状态为两个文件都将被Git管理</p><p> <img src="/images/Git/37.png" alt></p></li><li><p>在 .gitignore 中添加 <code>*.tmp</code> 忽略这类文件:即使是在同级目录文件夹内的.tmp 都会被忽略</p><p> <img src="/images/Git/38.png" alt></p></li><li><p>查看状态</p><p> //.tmp 已被忽略 ; </p><p> <img src="/images/Git/39.png" alt></p></li></ol><hr><h3 id="更新最后的提交记录"><a href="#更新最后的提交记录" class="headerlink" title="更新最后的提交记录"></a>更新最后的提交记录</h3><p>在上次提交过一次记录，后来发现内容有误，需要修改下内容但是又不想再提交一条修改记录，而是添加到上次提交的记录中去。</p><ol><li><p>在.gitignore 中再添加一条信息</p><p> <img src="/images/Git/40.png" alt></p></li><li><p>查看状态</p><p> <img src="/images/Git/41.png" alt></p></li><li><p>添加到索引区</p><p> <img src="/images/Git/42.png" alt></p></li><li><p><code>git commit --amend</code> //提交到最后的一条记录中去</p><p> <img src="/images/Git/43.png" alt></p></li></ol><hr><h3 id="版本回退-切换"><a href="#版本回退-切换" class="headerlink" title="版本回退/切换"></a>版本回退/切换</h3><p><code>git reset --hard HEAD</code> //回退到最新提交版本</p><p><code>git reset --hard HEAD~</code> //回退到最新提交的上一次版本</p><p><code>git reset --hard HEAD~n</code> //回退到倒数第N版本</p><p><code>git reset --hard 版本ID号</code> //回退到指定版本号</p><ol><li><p>先提交几次记录</p><p> <img src="/images/Git/44.png" alt></p><p> <img src="/images/Git/45.png" alt></p></li><li><p>回退到上个版本</p><p> <img src="/images/Git/46.png" alt></p></li><li><p>回退到最新版本，指的是此刻版本头HEAD指向的版本</p><p> <img src="/images/Git/47.png" alt></p></li><li><p>根据版本ID号回到指定版本 ; 通过头指针指向我们需要的版本,其他在头部之上的版本只是未显示而已,但仍在库中。</p><p> <img src="/images/Git/48.png" alt></p></li><li><p><code>git reflog</code> //要是忘记的版本号,可执行该命令查询之前版本切换的操作信息，从而确定需要切换的版本号</p><p> <img src="/images/Git/49.png" alt></p></li></ol><hr><h3 id="分支使用⭐"><a href="#分支使用⭐" class="headerlink" title="分支使用⭐"></a>分支使用⭐</h3><p>&emsp;&emsp;以上的操作都是在主分支上执行的,但是在实际应用中不应该多次在主分支操作。</p><p>&emsp;&emsp;在项目中每个人都有自己的要执行的任务,每个人执行的任务都不同,那么就需要在主分支上建立自己的分支,在自己的分支上不断的完善后再向主分支进行合并。</p><p><img src="/images/Git/gitbranch.png" alt></p><p><code>git branch 分支名</code>  //建立新分支</p><p><code>git checkout 分支名</code>  //切换分支</p><ol><li><p>查看下当前已有分支情况</p><p> <img src="/images/Git/50.png" alt></p></li><li><p>建立分支，切换分支</p><p> //建立的分支拥有的内容 与 在建立分支的那个时刻的主分支(被分支的分支)的内容一致</p><p> <img src="/images/Git/51.png" alt></p></li><li><p>添加文件，提交记录</p><p> <img src="/images/Git/52.png" alt></p></li><li><p>查看当前分支日志</p><p> <img src="/images/Git/53.png" alt></p></li><li><p>切换到主分支,查看日志</p><p> <img src="/images/Git/54.png" alt></p></li></ol><ul><li><p>在分支修改后没有提交的情况下，是不允许切换分支的</p><p>  <img src="/images/Git/55.png" alt></p></li><li><p>通过git在本地创建仓库，切换分支时另外一个分支的内容在哪里?</p><p>  &emsp;&emsp;项目文件都保存在.git目录下，始终存在，包括历史的各种版本，只不过不能从文件名字搜索到，因为Git是Content Addresing的。每次切换到一个分支，或者是check out一个历史版本，Git就从数据库（就是.git目录）中把这个版本的文件和目录都找出来，Copy一份放这当前的项目目录下。</p></li></ul><hr><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ol><li><p><code>git merge 分支名</code> //先得切换到主分支，再进行合并</p><p> <img src="/images/Git/56.png" alt></p></li><li><p><code>git branch -d 分支名</code> // 删除分支</p><p> <img src="/images/Git/57.png" alt></p></li></ol><hr><h3 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h3><ol><li><p><code>git checkout -b 分支名</code> //建立分支并切换到该分支</p><p> <img src="/images/Git/58.png" alt></p></li><li><p>修改文件内容，提交</p><p> <img src="/images/Git/59.png" alt></p><p> <img src="/images/Git/60.png" alt></p></li><li><p>切换分支，继续修改同样文件的内容，提交</p><p> <img src="/images/Git/61.png" alt></p><p> <img src="/images/Git/62.png" alt></p></li><li><p>在主分支上合并开发分支</p><p> //有冲突，需要手动修改</p><p> <img src="/images/Git/63.png" alt></p><p> //打开有冲突的文件</p><p> <img src="/images/Git/65.png" alt>   </p><p> //这是VSCode的功能（当前所处分支|被合并分支|两者都要|比较）</p><p> <img src="/images/Git/64.png" alt></p></li><li><p>修改完毕后,回到主分支，查看状态并提交</p><p> <img src="/images/Git/66.png" alt></p></li></ol><hr><h3 id="使用Tag标签"><a href="#使用Tag标签" class="headerlink" title="使用Tag标签"></a>使用Tag标签</h3><ul><li><p>版本号: 1.1.4   （NNN.abc.xxx）</p></li><li><p>有些为四位数 1.1.4.2356 最后的数字为编译次数</p><ul><li>NNN:大版本号</li><li>abc:每次做出的小更新时，发布的版本号</li><li>xxx:每次bug修正时发布的版本号</li></ul></li></ul><ol><li><p><code>git tag 版本号</code> //把当前代码状态作为一个版本发布</p><p> <img src="/images/Git/67.png" alt>   </p></li><li><p>修复bug，再次发布新版本</p><p> <img src="/images/Git/68.png" alt></p></li><li><p>新功能追加，再次发布新版本</p><p> <img src="/images/Git/69.png" alt></p></li><li><p>查看版本</p><p> <img src="/images/Git/70.png" alt></p></li></ol><hr><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>在Git中可以将经常使用的命令以别名缩写的方式简化使用,根据个人习惯或者开发组规范吧。</p><p><code>git config --global alias.别名 原命令名</code></p><p>例如：</p><ul><li><code>git config --global alias.co checkout</code></li><li><code>git config --global alias.br branch</code></li><li><code>git config --global alias.cm commit</code></li><li><code>git config --global alias.st status</code></li><li><code>...</code></li></ul><hr><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ol><li><p>创建Github仓库</p><p> <img src="/images/Git/71.png" alt></p></li><li><p>克隆仓库到本地</p><p> <img src="/images/Git/72.png" alt></p></li><li><p>进入仓库查看状态</p><p> <img src="/images/Git/73.png" alt></p></li><li><p>向仓库添加内容后，查看状态，提交到本地仓库</p><p> <img src="/images/Git/74.png" alt>   </p></li><li><p>查看当前状态，所处分支</p><p> <img src="/images/Git/75.png" alt></p></li><li><p>查看要推送的URL,然后推送到远端</p><p> <img src="/images/Git/76.png" alt> </p></li><li><p>进入GitHub查看,推送成功！</p><p> <img src="/images/Git/77.png" alt></p></li></ol><ul><li><code>git branch -a</code> //查看全部分支情况</li><li><code>git branch 分支名1 remotes/origin/分支名2</code>  //以远程分支名2为依据建立本地分支名1 （这两个是同一个东西来的） </li><li><code>git remote -v</code> //查看获取和推送的URL</li><li><code>git push origin 分支名</code> //推送到指定分支</li><li><code>git pull</code> //拉取远端变更内容</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS:SVN Configure</title>
      <link href="/archives/CentOS-SVNConfigure/"/>
      <url>/archives/CentOS-SVNConfigure/</url>
      
        <content type="html"><![CDATA[<ol><li><code>ssh root@xx.xxx.xxx.xxx</code>   //通过SSH连接服务器</li><li><code>svn</code>                      //先查看是否安装了svn</li><li><code>yum install svn</code>         //安装svn</li><li><code>svn --version</code>          //查看svn版本</li><li>输入<code>svn</code>按Tab补全  ; 会出现很多以svn开头的,可以选择使用</li><li><code>svnadmin create /opt/svn/916213802</code>      //在根目录下创建SVN仓库</li><li><code>svnserve -d -r /opt/svn/916213802/</code>   //启动svn服务</li><li><code>ps -ef | grep svnserve</code>   //查看svnserve 是否启动<a id="more"></a></li><li><code>netstat -an | grep 3690</code>   //3690是svn默认端口,查看是否开放</li><li>由于阿里云安全组不开放该端口,所以要去阿里云服务器开启<em>3690</em> 端口<br><img src="/images/CentOSSVNConfigure/01.png" alt></li><li><code>cd /opt/svn/916213802/conf/</code>  //进入仓库查看配置文件        </li><li><code>vim authz</code>   //设置用户<br><img src="/images/CentOSSVNConfigure/02.png" alt></li><li><code>vim passwd</code>  //设置用户和密码<br><img src="/images/CentOSSVNConfigure/03.png" alt></li><li><code>vim svnserve.conf</code>  //设置其他参数<br><img src="/images/CentOSSVNConfigure/04.png" alt></li><li><code>killall svn</code>   //关闭svn进程也可以在12的基础上<code>killall pid</code></li><li><code>svnserve -d -r /opt/svn/916213802</code>  //再次启动svnserve服务</li><li><code>svn checkout svn://47.107.xxx.xxx/916213802 --username 91621380205 --password 91621380205</code><br>//本地连接服务器SVN ,执行后下载svn上的项目到本地当前目录,可不用–username和–password</li></ol><hr><ul><li><code>pwd</code>   //查看当前目录</li><li><code>cd /</code>  //进入根目录</li><li><code>ls</code> 查看当前目录下文件</li><li><code>ll</code> 查看当前目录下文件</li><li>执行第<em>7</em> 步后,再执行第<em>17</em> 步测试连接,如果连接得上就不用操作步骤<em>8-10</em> ;</li><li>部署项目的话把项目放在本地checkout下来的文件夹里,<em>同步</em> 上去就可以了.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Linux </tag>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-ArtificialSimulation</title>
      <link href="/archives/Java-ArtificialSimulation/"/>
      <url>/archives/Java-ArtificialSimulation/</url>
      
        <content type="html"><![CDATA[<h3 id="Create-a-project"><a href="#Create-a-project" class="headerlink" title="Create a project"></a>Create a project</h3><p>Create New Project =&gt; Maven =&gt; Next =&gt; for (Fill in information =&gt; Next) =&gt; Finish<br> <img src="/images/Java-AS/0x011.png" alt><br> <img src="/images/Java-AS/0x012.png" alt><br> <img src="/images/Java-AS/0x013.png" alt><br> <img src="/images/Java-AS/0x014.png" alt></p><h3 id="Environment-and-Tools"><a href="#Environment-and-Tools" class="headerlink" title="Environment and Tools"></a>Environment and Tools</h3><ol><li>Java环境 JDK <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载</a></li><li>IDEA  <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">下载</a></li><li>准备好ChromeDriver <a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">下载</a><br>选择好对应版本(我这里选择的是74.0.3729.68 win)</li><li>Selenium 依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;selenium-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.141.59&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h3 id="Get-set"><a href="#Get-set" class="headerlink" title="Get set"></a>Get set</h3><ol><li>在pom.xml中导入Selenium依赖 =&gt; 等待下载</li><li>在src-&gt;main-&gt;java中创建Java类,创建main方法.—-<em>在IDEA中输入psvm+回车_快速创建main方法</em></li><li>把准备好的ChromeDriver.exe放在src-&gt;main-&gt;resources目录中</li></ol><h3 id="Codeing"><a href="#Codeing" class="headerlink" title="Codeing"></a>Codeing</h3><ol><li><p>设置webdriver路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"webdriver.chrome.driver"</span>,Scan.class.getClassLoader().getResource(<span class="string">"chromedriver.exe"</span>).getPath());</span><br></pre></td></tr></table></figure></li><li><p>创建webdriver对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebDriver webDriver =<span class="keyword">new</span> ChromeDriver();</span><br></pre></td></tr></table></figure></li><li><p>打开页面(这里我以<code>www.lagou.com</code>为操作对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webDriver.get(<span class="string">"https://www.lagou.com/zhaopin/Java/?labelWords=label"</span>);</span><br></pre></td></tr></table></figure></li><li><p>审查网页元素<br>在模拟人工操作前,需要先分析页面对象的元素组成,观察到我们需要模拟点击的导航条”工作经验”是在<code>&lt;li class=&quot;muti-chosen&quot;&gt;</code>内的<code>&lt;span&gt;</code>之间,这样就确定了第一层筛选,然后再从<code>&lt;span&gt;</code>中筛选出<code>&lt;a&gt;</code>,根据<code>Text()</code>确定了元素位置.<br><img src="/images/Java-AS/0x044.png" alt></p></li><li><p>选择根据页面结构获取对象(我这里选择了Xpath)</p></li></ol><ul><li><p>首先获取第一层筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webDriver.findElement(By.xpath(<span class="string">"//li[@class='multi-chosen']//span[contains(text(),'工作经验')]"</span>));</span><br></pre></td></tr></table></figure></li><li><p>然后选择上面的代码提取成对象—-<em>IDEA快捷键(ctrl+alt+V)</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebElement chosenElement = webDriver.findElement(By.xpath(<span class="string">"//li[@class='multi-chosen']//span[contains(text(),'工作经验')]"</span>))</span><br></pre></td></tr></table></figure></li><li><p>接着同样的操作,写出第二层筛选和点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebElement chosenElement = webDriver.findElement(By.xpath(<span class="string">"//li[@class='multi-chosen']//span[contains(text(),'工作经验')]"</span>));</span><br><span class="line">WebElement optionElement = chosenElement.findElement(By.xpath(<span class="string">"../a[contains(text(),'应届毕业生')]"</span>));</span><br><span class="line">optionElement.click();</span><br></pre></td></tr></table></figure></li><li><p>再次观察页面,发现各个导航条只有文本描述差异,所以接下来把上面两个文本对象抽成变量(选中”工作经验”和”应届毕业生”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String chosenTitle = <span class="string">"工作经验"</span>;</span><br><span class="line">String optionTitle = <span class="string">"应届毕业生"</span>; <span class="comment">//移动代码位置(先选择该行ctrl+shift+↑or↓)</span></span><br><span class="line"></span><br><span class="line">WebElement chosenElement = webDriver.findElement(By.xpath(<span class="string">"//li[@class='multi-chosen']//span[contains(text(),'"</span> + chosenTitle + <span class="string">"')]"</span>));</span><br><span class="line">WebElement optionElement = chosenElement.findElement(By.xpath(<span class="string">"../a[contains(text(),'"</span> + optionTitle + <span class="string">"')]"</span>));</span><br><span class="line">optionElement.click();</span><br></pre></td></tr></table></figure></li><li><p>然后思考,把上面三行抽成方法,之后只需传递两个参数就可以控制了(选中上面三行代码抽成方法—-<em>IDEA快捷键(ctrl+alt+M)</em>,该操作前需要做第二步的提取变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String chosenTitle = <span class="string">"工作经验"</span>;</span><br><span class="line">String optionTitle = <span class="string">"应届毕业生"</span>;</span><br><span class="line">clickOption(webDriver, chosenTitle, optionTitle);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clickOption</span><span class="params">(WebDriver webDriver, String chosenTitle, String optionTitle)</span> </span>&#123;</span><br><span class="line">WebElement chosenElement = webDriver.findElement(By.xpath(<span class="string">"//li[@class='multi-chosen']//span[contains(text(),'"</span> + chosenTitle + <span class="string">"')]"</span>));</span><br><span class="line">WebElement optionElement = chosenElement.findElement(By.xpath(<span class="string">"../a[contains(text(),'"</span> + optionTitle + <span class="string">"')]"</span>));</span><br><span class="line">optionElement.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写到这里观察上面变量和方法形参,合并一下优化代码.把文本传回方法参数里.—-<em>IDEA快捷键(ctrl+alt+N)</em> (选中方法里的参数)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clickOption(webDriver, <span class="string">"工作经验"</span>, <span class="string">"应届毕业生"</span>);<span class="comment">//接着分析页面,执行五个操作</span></span><br><span class="line">clickOption(webDriver, <span class="string">"学历要求"</span>, <span class="string">"本科"</span>);</span><br><span class="line">clickOption(webDriver, <span class="string">"融资阶段"</span>, <span class="string">"不限"</span>);</span><br><span class="line">clickOption(webDriver, <span class="string">"公司规模"</span>, <span class="string">"不限"</span>);</span><br><span class="line">clickOption(webDriver, <span class="string">"行业领域"</span>, <span class="string">"移动互联网"</span>);</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>解析单页元素<br><img src="/images/Java-AS/0x046.png" alt></li></ol><ul><li><p>观察页面元素发现主要信息都是在<code>&lt;li class=&quot;con_list_item default_list&quot;&gt;</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webDriver.findElements(By.className(<span class="string">"con_list_item"</span>));</span><br></pre></td></tr></table></figure></li><li><p>这里findElements是因为有多个元素,上面的findElement是只有一个元素,接着依然是抽取变量—-<em>IDEA快捷键(ctrl+alt+V)</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WebElement&gt; jobElements = webDriver.findElements(By.className(<span class="string">"con_list_item"</span>));</span><br></pre></td></tr></table></figure></li><li><p>页面有多组信息就要用循环了咯,循环遍历对象JobElements;—-<em>在IDEA中输入<code>jobElemnets.for</code>+回车_就会补全语法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (WebElement jobElement : jobElements) &#123;</span><br><span class="line">    WebElement moneyElement = jobElement.findElement(By.className(<span class="string">"position"</span>)).findElement(By.className(<span class="string">"money"</span>));</span><br><span class="line">    System.out.println(moneyElement.getText());</span><br><span class="line">    String companyName = jobElement.findElement(By.className(<span class="string">"company_name"</span>)).getText();<span class="comment">//在IDEA中输入sout+回车_快速创建打印方法</span></span><br><span class="line">    System.out.println(companyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化一下代码_把上面代码抽成方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extractJobsByPagination(webDriver);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractJobsByPagination</span><span class="params">(WebDriver webDriver)</span> </span>&#123;</span><br><span class="line">List&lt;WebElement&gt; jobElements = webDriver.findElements(By.className(<span class="string">"con_list_item"</span>));</span><br><span class="line"><span class="keyword">for</span> (WebElement jobElement : jobElements) &#123;</span><br><span class="line">    WebElement moneyElement = jobElement.findElement(By.className(<span class="string">"position"</span>)).findElement(By.className(<span class="string">"money"</span>));</span><br><span class="line">    String companyName = jobElement.findElement(By.className(<span class="string">"company_name"</span>)).getText();</span><br><span class="line">    System.out.println(companyName + <span class="string">" : "</span> + moneyElement.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写到这里可以尝试运行一下了,观察下输出结果.</p></li></ul><ol start="7"><li>解析分页元素<br><img src="/images/Java-AS/0x071.png" alt><br><img src="/images/Java-AS/0x072.png" alt></li></ol><ul><li>观察下一页按钮可点击和不可点击时的变化<br><img src="/images/Java-AS/0x073.png" alt></li><li>测试下按钮事件</li><li>进行逻辑判断,然后触发点击事件.最后在if里进行递归调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WebElement nextPageBtn = webDriver.findElement(By.className(<span class="string">"pager_next"</span>));</span><br><span class="line"><span class="keyword">if</span>(!nextPageBtn.getAttribute(<span class="string">"class"</span>).contains(<span class="string">"pager_next_disabled"</span>))&#123;</span><br><span class="line">nextPageBtn.click();</span><br><span class="line">System.out.println(<span class="string">"--------下一页---------"</span>);</span><br><span class="line"><span class="comment">//然后这里让线程睡眠一秒钟,以免跳转响应时间不够,再来个异常处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            hread.sleep(<span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">        extractJobsByPagination(webDriver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><p><img src="/images/Java-AS/0x081.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
            <tag> Xpath </tag>
            
            <tag> Selenium </tag>
            
            <tag> ChromeDriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CrackRefrain</title>
      <link href="/archives/CrackRefrain/"/>
      <url>/archives/CrackRefrain/</url>
      
        <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>在局域网内先扫描端口</li><li>看开启了哪些服务</li><li>搜索看哪些服务可以利用(window smb ,数据库)</li><li>尝试破解,漏洞不需要</li><li>进入成功.执行命令操作</li></ol><a id="more"></a><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ol><li>登录 <code>mysql -h#ip地址# -u#用户名# -p#密码#</code></li><li>自己的 <code>mysql -u#root(默认)# -p密码</code></li><li><code>select * from mysql.user;</code> 查询系统用户表</li><li>由于host=’localhost’,所以别人连不进来; 修改host=’%’,就是所有人都可以连进来;<br> <code>update mysql.user set host=&#39;%&#39; where  user=&#39;root&#39;;</code></li><li>修改完毕后 刷新 <code>flsuh privileges;</code></li><li><p>可以重新登录mysql 查看修改后情况</p></li><li><p>查看任务进程 <code>tasklist</code></p></li><li>关闭任务进程 <code>taskkill /f /pid #pid号#</code></li><li><p>启动mysql服务 <code>net start mysql</code> 停止mysql服务 <code>net stop mysql</code></p></li><li><p>进去别人的MySQL 首先看下数据库<code>show databases;</code></p></li><li>选择数据库 use xxx; </li><li>看下表 show tables;</li><li>执行表操作 select * from xxx;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Crack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FieldworkDaily</title>
      <link href="/archives/FieldworkDaily/"/>
      <url>/archives/FieldworkDaily/</url>
      
        <content type="html"><![CDATA[<h3 id="Days-01-190527-10-35AM"><a href="#Days-01-190527-10-35AM" class="headerlink" title="Days-01-190527;10:35AM"></a>Days-01-190527;10:35AM</h3><p>&emsp;&emsp;今日は初めでのじつしゅうひ、朝07：50そとでる。くろまで1時間半ががりました、30ぶんちこくました。ここにきでがら、いつものよに、なにもかんじない。んんんんんんんんんんんんんんん</p><p>べんきょしよ…</p><h3 id="Days-02-190528-11-39AM"><a href="#Days-02-190528-11-39AM" class="headerlink" title="Days-02-190528;11:39AM"></a>Days-02-190528;11:39AM</h3><p>&emsp;&emsp; きょうのあさ、07：45おきろ。さくやははやくねます、ねでかぜをひいた、あさおきてけりをします。そのあと,いつものよに。バスとてでんしゃ…45ぶんぐらいががりました。さくじつよりずいぶんはやくなりました。けさもまたスキヤンポートためしました、MySQLサーバーをとうろくしました、MySQLサービスつうじてほかのりとのコンピューターをせいぎょしてコンピューターめいれいをじつこうしました。いるいるを勉強しました。</p><p>きょうのごごはEasyUIをよく勉強するつもりです。<br><a id="more"></a></p><h3 id="Days-04-190530-16-08PM"><a href="#Days-04-190530-16-08PM" class="headerlink" title="Days-04-190530;16:08PM"></a>Days-04-190530;16:08PM</h3><p>&emsp;&emsp;きのはいそがしい、いちにちは　.Net Coreのことを勉強しまし。やっとよあけににんむをあえた。今日はJava-Springbootのルートマップを勉強なる、いろいろを、たくさわがりました。いい感じです…<br>これがらも頑張ってべんきょうします。</p><h3 id="Days-05-190531-09-30AM"><a href="#Days-05-190531-09-30AM" class="headerlink" title="Days-05-190531;09:30AM"></a>Days-05-190531;09:30AM</h3><p>&emsp;&emsp;きょうのあさ起きては元気、じゅぎょうははんにちだけです。よかったです。きょうもしっかりべんきょうしなけばなりません。ごごのじゅぎょうをやすむのはうそです…(T.T)。いまは14時22分、先ほどはDeleteそうさをかんりょうしました。あとでUpdateを勉強したらじゅぎょうがおわりますた。つかれました。</p><h3 id="Days-06-190603-09-56AM"><a href="#Days-06-190603-09-56AM" class="headerlink" title="Days-06-190603;09:56AM"></a>Days-06-190603;09:56AM</h3><p>&emsp;&emsp;こんしゅうのじっしゅうはまたはじまりました。すごいひとがおおすぎて、じぶんはなにむわがりません。これがら1時にきぎょうにけんがくにいきます、けんがくしてがっこうにがえります。きょうのじっしゅうはこれでおわります。</p><h3 id="Days-07-190604-09-33AM"><a href="#Days-07-190604-09-33AM" class="headerlink" title="Days-07-190604;09:33AM"></a>Days-07-190604;09:33AM</h3><p>&emsp;&emsp;きのうのごご、がっこうにかえるついでに、スーパーによっておかしをたくさんかいいました。いまこうざをきいています。</p><h3 id="Days-08-190605-15-22PM"><a href="#Days-08-190605-15-22PM" class="headerlink" title="Days-08-190605;15:22PM"></a>Days-08-190605;15:22PM</h3><p>&emsp;&emsp;きのうははれ、きょはあめ。つまらない、つかれる。</p><h3 id="Days-11-190610-20-49PM"><a href="#Days-11-190610-20-49PM" class="headerlink" title="Days-11-190610;20:49PM"></a>Days-11-190610;20:49PM</h3><p>&emsp;&emsp;さくやJavaウェブサイトのはちゅうるいのちいさいプロジェクトをかんせいしました。そしてきょうはブログをかきました。いいかんじ、きょうはSVNについてまたしらべました。わるくない…</p><h3 id="Days-15-190614-12-34PM"><a href="#Days-15-190614-12-34PM" class="headerlink" title="Days-15-190614;12:34PM"></a>Days-15-190614;12:34PM</h3><p>&emsp;&emsp;きょはじっしゅうのさいごのひ、グループプロジェクトがかんせいしました、それにとうべんも通った。このみしゅうがんのあいだに、たしかにおおくのちしきをべんきょうしました。つぎのひもこのようにべんきょうしつづけます。(=^・^=)</p>]]></content>
      
      
      
        <tags>
            
            <tag> jnote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AzureLaneCrack</title>
      <link href="/archives/AzureLaneCrack/"/>
      <url>/archives/AzureLaneCrack/</url>
      
        <content type="html"><![CDATA[<p><a href="#资源获取">资源</a> | <a href="#立绘">提取立绘</a> | <a href="#语音">提取语音</a> | <a href="#SD小人">提取SD小人</a></p><hr><h3 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h3><p>碧蓝航线的资源主要来源于起始安装包/游戏增量更新<br>(1)官网下载安装包,解压后资源在assets\AssetBundles<br>(2)从模拟器或者手机内获取增量内容, 资源在同样路径   </p><hr><h3 id="立绘"><a href="#立绘" class="headerlink" title="立绘"></a>立绘</h3><p>(1)    解压AssetStudio.x64.0.12.46,运行AssetStudioGUI.exe<br>GitHub地址：<a href="https://github.com/Perfare/AssetStudio" target="_blank" rel="noopener">https://github.com/Perfare/AssetStudio</a><br>点击release,下载最新版本.<br> <img src="/images/AzureLaneCrack/image1.png" alt></p><p>(2)    点击File-Load folder 选择资源名为Painting的文件夹(安装包和增量更新的操作都是一样的),等待载入.<br> <img src="/images/AzureLaneCrack/image2.png" alt></p><p>(3)    点击Asset List 下方Name排列的就是各个加密立绘<br> <img src="/images/AzureLaneCrack/image3.png" alt></p><p>(4)    点击Export-All assets 导出全部资源文件到一个新文件夹里.<br> <img src="/images/AzureLaneCrack/image4.png" alt><br><a id="more"></a><br>(5)    Mesh文件夹里面是立绘的骨骼序列, Texture2D是文件夹里是加密后的立绘.<br> <img src="/images/AzureLaneCrack/image5.png" alt></p><p>(6)    立绘还原,解压AzurLanePaintingExtract.v0.7.2,运行.exe<br> GitHub地址：<a href="https://github.com/Goodjooy/AzurLinePaintingRestore" target="_blank" rel="noopener">https://github.com/Goodjooy/AzurLinePaintingRestore</a><br> <img src="/images/AzureLaneCrack/image6.png" alt>  </p><p>(7)    点击加载文件夹,选择刚才导出的Mesh和Texture2D文件夹,即可看到完整的立绘.<br> <img src="/images/AzureLaneCrack/image7.png" alt></p><p>(8)    点击设置-工具,如果出现空白弹窗,表示没有需要添加的新舰娘名,如果有,双击每个选项可以添加舰娘名,完成后确认.<br> <img src="/images/AzureLaneCrack/image8.png" alt></p><p>(9)    点击导出-导出全部,等待导出.<br> <img src="/images/AzureLaneCrack/image9.png" alt><br> <img src="/images/AzureLaneCrack/image10.png" alt></p><hr><h3 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h3><p>(1)    解压 碧蓝航线语音提取.rar  </p><p>(2)    语音路径为assets\AssetBundles\cue()  </p><p>(3)    新建一个输出语音文件夹(cue-output).<br> <img src="/images/AzureLaneCrack/image11.png" alt>  </p><p>(4)    将cue与cue-output一起拖向BlhxCueDecoder.exe.等待导出.<br> <img src="/images/AzureLaneCrack/image12.png" alt> </p><p>(5)    导出时间较长,导出完毕后对照语音表即可识别对应舰娘语音.<br> <img src="/images/AzureLaneCrack/image13.png" alt> </p><hr><h3 id="SD小人"><a href="#SD小人" class="headerlink" title="SD小人"></a>SD小人</h3><p>(1)    SD小人立绘文件夹为char.打开AssetStudio,导入文件夹.<br> <img src="/images/AzureLaneCrack/image14.png" alt></p><p>(2)    得到如图加密过后的SD小人立绘.<br> <img src="/images/AzureLaneCrack/image15.png" alt></p><p>(3)    同理Export-All asset导出到一个文件夹里.<br> <img src="/images/AzureLaneCrack/image16.png" alt></p><p>(4)    TextAsset文件夹里为SD小人部件序列.<br> <img src="/images/AzureLaneCrack/image17.png" alt></p><p>(5)    批量改名去掉txt,将bat文件拖入TextAsset文件夹,双击运行.<br> <img src="/images/AzureLaneCrack/image18.png" alt><br> <img src="/images/AzureLaneCrack/image19.png" alt></p><p>(6)    将TextAsset文件夹里的内容,复制到Texture2D文件夹里.<br> <img src="/images/AzureLaneCrack/image20.png" alt></p><p>(7)    还原SD小人,需要Java环境和skeletonViewer.jar,运行jar.<br> <img src="/images/AzureLaneCrack/image21.png" alt> </p><p>(8)    点击Open,在Texture2D文件夹里选择.skel文件.<br> <img src="/images/AzureLaneCrack/image22.png" alt></p><p>(9)    得到SD小人立绘,Animation中的则是对应拥有的动作.<br> <img src="/images/AzureLaneCrack/image23.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> AzureLane </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>インデックス</title>
      <link href="/archives/jnote/"/>
      <url>/archives/jnote/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;きょうはれいわがんねんのはじまりで、しがもしよにちである。<br>ずつとまえからブログをがこうとおもつでいましたが、<br>あまりにもなまけでいたので、ながながはちめられませんでした。<br>このいちがけつがん、おおくのネットちしきをしり、<br>さいこにGitHubにでんがいするというがたちになりました。<br>このようなけいしきはわたしのサーバーのしげんをせつやくしました、<br>がんりもべんりでし。<br>このブロクをかくのはじつはおもなどうりょくはやはりしごとをさがすためです、<br>りれきしよにてんじできるがらです。<br>プログラムぎじゅつをがくいがいに、ここでじぶんのしゅみをがきます。<br>じぶんのせいかつのいちぶをここにきるくしで、<br>こんかいはちゅうとはんばではないこをねがいます。<br>わたしはなにもてんじできるものがなくで、<br>せいこうしたけいけんがありません。<br>ものごころがつくから、しっぱいばかりでした。<br>つまり、いまのわたしはしっぱいしゃです。<br><a id="more"></a><br>なんねんごのわたしへ：<br>&emsp;&emsp;にほんごのレベレはまだこのたんぶんのようにちゅうとはんばでしが？<br>&emsp;&emsp;まだこうかいしでいますが？<br>&emsp;&emsp;まだプログラマをしていますか？  </p>]]></content>
      
      
      
        <tags>
            
            <tag> jnote </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
